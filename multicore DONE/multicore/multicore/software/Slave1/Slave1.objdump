
Slave1.elf:     file format elf32-littlenios2
Slave1.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00120240

Program Header:
    LOAD off    0x00001000 vaddr 0x00120000 paddr 0x00120000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00120020 paddr 0x00120020 align 2**12
         filesz 0x00007834 memsz 0x00007834 flags r-x
    LOAD off    0x00008854 vaddr 0x00127854 paddr 0x001293e4 align 2**12
         filesz 0x00001b90 memsz 0x00001b90 flags rw-
    LOAD off    0x0000af74 vaddr 0x0012af74 paddr 0x0012af74 align 2**12
         filesz 0x00000000 memsz 0x00000154 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00120000  00120000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000220  00120020  00120020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000074b4  00120240  00120240  00001240  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000160  001276f4  001276f4  000086f4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001b90  00127854  001293e4  00008854  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000154  0012af74  0012af74  0000af74  2**2
                  ALLOC, SMALL_DATA
  6 .MEMSlave1    00000000  0012b0c8  0012b0c8  0000a3e4  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  0000a3e4  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000b58  00000000  00000000  0000a408  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0001d5d8  00000000  00000000  0000af60  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00007a40  00000000  00000000  00028538  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0000844b  00000000  00000000  0002ff78  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00001c08  00000000  00000000  000383c4  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00002cad  00000000  00000000  00039fcc  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00004f0a  00000000  00000000  0003cc79  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000030  00000000  00000000  00041b84  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000328  00000000  00000000  00041bb8  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  00044b75  2**0
                  CONTENTS, READONLY
 18 .cpu          00000009  00000000  00000000  00044b78  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  00044b81  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  00044b82  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   0000000a  00000000  00000000  00044b83  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    0000000a  00000000  00000000  00044b8d  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   0000000a  00000000  00000000  00044b97  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 00000008  00000000  00000000  00044ba1  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 0000002d  00000000  00000000  00044ba9  2**0
                  CONTENTS, READONLY
 26 .jdi          0000c3ff  00000000  00000000  00044bd6  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     000bcd72  00000000  00000000  00050fd5  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00120000 l    d  .entry	00000000 .entry
00120020 l    d  .exceptions	00000000 .exceptions
00120240 l    d  .text	00000000 .text
001276f4 l    d  .rodata	00000000 .rodata
00127854 l    d  .rwdata	00000000 .rwdata
0012af74 l    d  .bss	00000000 .bss
0012b0c8 l    d  .MEMSlave1	00000000 .MEMSlave1
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Slave1_bsp//obj/HAL/src/crt0.o
00120288 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 hello_world.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
00120984 l     F .text	00000008 __fp_lock
0012098c l     F .text	00000008 __fp_unlock
001209a0 l     F .text	000001a0 __sinit.part.1
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
00127854 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 refill.c
00122430 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 alt_close.c
00123960 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
00123a80 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
00123aac l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
00123bac l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
00123ca0 l     F .text	00000064 alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
00123d84 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_open.c
00123f60 l     F .text	00000050 alt_get_errno
00123fb0 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_read.c
00124440 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
001293cc l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_write.c
0012469c l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
001247e4 l     F .text	00000038 alt_dev_reg
0012481c l     F .text	00000050 alt_get_errno
0012486c l     F .text	0000006c alt_avalon_mutex_reg
00128228 l     O .rwdata	00001060 JTAGSlave1
00129288 l     O .rwdata	00000010 mutex_0
00129298 l     O .rwdata	000000c4 uart_0
0012935c l     O .rwdata	00000048 video_character_buffer_with_dma_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
00124c5c l     F .text	00000204 altera_avalon_jtag_uart_irq
00124e60 l     F .text	000000a8 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_mutex.c
00125480 l     F .text	00000050 alt_get_errno
001254d0 l     F .text	0000007c alt_mutex_trylock
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
00125910 l     F .text	00000098 altera_avalon_uart_irq
001259a8 l     F .text	000000e0 altera_avalon_uart_rxirq
00125a88 l     F .text	00000144 altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
00125c20 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
00125e4c l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 altera_up_avalon_video_character_buffer_with_dma.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
001264b4 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
00126bb8 l     F .text	000000c0 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
0012af9c g     O .bss	00000004 alt_instruction_exception_handler
00122e08 g     F .text	00000054 _isatty_r
00123ea8 g     F .text	00000078 alt_main
00122364 g     F .text	000000b8 _puts_r
0012afc8 g     O .bss	00000100 alt_irq
00122e5c g     F .text	0000005c _lseek_r
001293e4 g       *ABS*	00000000 __flash_rwdata_start
001228cc g     F .text	00000098 __sflags
0012b0c8 g       *ABS*	00000000 __alt_heap_start
00122720 g     F .text	0000005c __sseek
00120cd4 g     F .text	00000010 __sinit
001272a8 g     F .text	00000154 __swbuf_r
001261d4 g     F .text	00000100 alt_up_char_buffer_string
00120b40 g     F .text	00000064 __sfmoreglue
00123f40 g     F .text	00000020 __malloc_unlock
00126108 g     F .text	000000cc alt_up_char_buffer_draw
001230d8 g     F .text	0000015c memmove
00120cbc g     F .text	00000018 _cleanup
00125604 g     F .text	00000040 altera_avalon_mutex_trylock
00126e8c g     F .text	00000020 altera_nios2_gen2_irq_init
00000000  w      *UND*	00000000 __errno
00120000 g     F .entry	0000001c __reset
00125694 g     F .text	00000074 altera_avalon_mutex_is_mine
00120020 g       *ABS*	00000000 __flash_exceptions_start
001216bc g     F .text	00000058 _fstat_r
0012af74 g     O .bss	00000004 errno
0012269c g     F .text	00000008 __seofread
0012af88 g     O .bss	00000004 alt_argv
001313a4 g       *ABS*	00000000 _gp
001280a8 g     O .rwdata	00000180 alt_fd_list
001205c0 g     F .text	00000058 delay10ms
00126660 g     F .text	00000090 alt_find_dev
00122fa0 g     F .text	00000138 memcpy
001262d4 g     F .text	0000005c alt_up_char_buffer_clear
00120994 g     F .text	0000000c _cleanup_r
00126c78 g     F .text	00000078 alt_io_redirect
001276f4 g       *ABS*	00000000 __DTOR_END__
0012241c g     F .text	00000014 puts
00126f38 g     F .text	0000009c alt_exception_cause_generated_bad_addr
0012505c g     F .text	0000020c altera_avalon_jtag_uart_read
00000000  w      *UND*	00000000 malloc
00123bfc g     F .text	000000a4 isatty
00126eac g     F .text	0000008c alt_icache_flush
0012af80 g     O .bss	00000004 __malloc_top_pad
00122964 g     F .text	000004a4 __sfvwrite_r
001225f4 g     F .text	00000054 _sbrk_r
00123234 g     F .text	0000005c _read_r
001293c4 g     O .rwdata	00000004 alt_max_fd
00120618 g     F .text	00000100 _fclose_r
00120954 g     F .text	00000030 fflush
0012af7c g     O .bss	00000004 __malloc_max_sbrked_mem
00123dd4 g     F .text	000000d4 lseek
00125708 g     F .text	00000050 altera_avalon_mutex_first_lock
001293a4 g     O .rwdata	00000004 _global_impure_ptr
00123290 g     F .text	000005a0 _realloc_r
0012b0c8 g       *ABS*	00000000 __bss_end
00126ac8 g     F .text	000000f0 alt_iic_isr_register
00126d88 g     F .text	00000104 alt_tick
00125868 g     F .text	000000a8 altera_avalon_uart_init
00120cf4 g     F .text	00000018 __fp_lock_all
00126a7c g     F .text	0000004c alt_ic_irq_enabled
00126cf0 g     F .text	00000098 alt_alarm_stop
0012af90 g     O .bss	00000004 alt_irq_active
001200fc g     F .exceptions	000000d0 alt_irq_handler
00128080 g     O .rwdata	00000028 alt_dev_null
0012554c g     F .text	00000054 altera_avalon_mutex_open
00126470 g     F .text	00000044 alt_dcache_flush_all
001293e4 g       *ABS*	00000000 __ram_rwdata_end
001293bc g     O .rwdata	00000008 alt_dev_list
001246ec g     F .text	000000f8 write
0012709c g     F .text	000000a0 _putc_r
001293d0 g     O .rwdata	00000008 alt_mutex_list
00127854 g       *ABS*	00000000 __ram_rodata_end
00123afc g     F .text	000000b0 fstat
0012b0c8 g       *ABS*	00000000 end
00126048 g     F .text	00000080 alt_up_char_buffer_init
00125e9c g     F .text	000001ac altera_avalon_uart_write
00121698 g     F .text	00000024 fseek
00124b98 g     F .text	000000c4 altera_avalon_jtag_uart_init
001201cc g     F .exceptions	00000074 alt_instruction_exception_entry
001276f4 g       *ABS*	00000000 __CTOR_LIST__
00133880 g       *ABS*	00000000 __alt_stack_pointer
001257b8 g     F .text	00000060 altera_avalon_uart_write_fd
00125818 g     F .text	00000050 altera_avalon_uart_close_fd
00125268 g     F .text	00000218 altera_avalon_jtag_uart_write
00120ce4 g     F .text	00000004 __sfp_lock_acquire
00122eb8 g     F .text	000000e8 memchr
00120f54 g     F .text	000002f0 _free_r
001241d4 g     F .text	00000228 alt_printf
0012752c g     F .text	00000194 __call_exitprocs
001293ac g     O .rwdata	00000004 __malloc_sbrk_base
00120240 g     F .text	0000004c _start
0012af94 g     O .bss	00000004 _alt_tick_rate
0012af98 g     O .bss	00000004 _alt_nticks
00124490 g     F .text	000000fc read
0012490c g     F .text	00000128 alt_sys_init
00122308 g     F .text	0000005c _open_r
00127418 g     F .text	00000114 __register_exitproc
00125644 g     F .text	00000050 altera_avalon_mutex_unlock
00124f08 g     F .text	00000068 altera_avalon_jtag_uart_close
00127854 g       *ABS*	00000000 __ram_rwdata_start
001276f4 g       *ABS*	00000000 __ram_rodata_start
0012afa0 g     O .bss	00000028 __malloc_current_mallinfo
00124a34 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
00126804 g     F .text	000000b4 alt_get_fd
00122878 g     F .text	00000054 _close_r
00127020 g     F .text	0000007c memcmp
00124af4 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0012b0c8 g       *ABS*	00000000 __alt_stack_base
00124b44 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
00123830 g     F .text	00000130 __swsetup_r
00120ba4 g     F .text	00000118 __sfp
00127c78 g     O .rwdata	00000408 __malloc_av_
00120cf0 g     F .text	00000004 __sinit_lock_release
00122648 g     F .text	00000054 __sread
001266f0 g     F .text	00000114 alt_find_file
00126504 g     F .text	000000a4 alt_dev_llist_insert
00123f20 g     F .text	00000020 __malloc_lock
001245ec g     F .text	000000b0 sbrk
0012072c g     F .text	00000228 _fflush_r
00120e14 g     F .text	0000001c fopen
0012af74 g       *ABS*	00000000 __bss_start
001221e4 g     F .text	00000124 memset
0012028c g     F .text	00000334 main
0012af8c g     O .bss	00000004 alt_envp
0012af78 g     O .bss	00000004 __malloc_max_total_mem
001260c8 g     F .text	00000040 alt_up_char_buffer_open_dev
00124a94 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
001273fc g     F .text	0000001c __swbuf
0012277c g     F .text	00000008 __sclose
00133880 g       *ABS*	00000000 __alt_heap_limit
00120718 g     F .text	00000014 fclose
001255c4 g     F .text	00000040 altera_avalon_mutex_lock
00121a3c g     F .text	000007a8 _malloc_r
001293c8 g     O .rwdata	00000004 alt_errno
00121714 g     F .text	000000b8 _fwalk
0012713c g     F .text	000000c8 putc
00120e30 g     F .text	00000124 _malloc_trim_r
001276f4 g       *ABS*	00000000 __CTOR_END__
00127204 g     F .text	000000a4 strcmp
001276f4 g       *ABS*	00000000 __flash_rodata_start
001276f4 g       *ABS*	00000000 __DTOR_LIST__
001248d8 g     F .text	00000034 alt_irq_init
0012458c g     F .text	00000060 alt_release_fd
00126fd4 g     F .text	00000014 atexit
0012281c g     F .text	0000005c _write_r
001293a8 g     O .rwdata	00000004 _impure_ptr
0012af84 g     O .bss	00000004 alt_argc
00126604 g     F .text	0000005c _do_dtors
00121244 g     F .text	00000454 _fseek_r
0012244c g     F .text	000001a8 __srefill_r
00120020 g       .exceptions	00000000 alt_irq_entry
00120d0c g     F .text	00000018 __fp_unlock_all
001293b4 g     O .rwdata	00000008 alt_fs_list
00120000 g       *ABS*	00000000 __alt_mem_MEMSlave1
00120020 g       *ABS*	00000000 __ram_exceptions_start
001268e8 g     F .text	00000050 alt_ic_isr_register
001293e4 g       *ABS*	00000000 _edata
00125758 g     F .text	00000060 altera_avalon_uart_read_fd
0012b0c8 g       *ABS*	00000000 _end
00120240 g       *ABS*	00000000 __ram_exceptions_end
00124f70 g     F .text	000000ec altera_avalon_jtag_uart_ioctl
001269d8 g     F .text	000000a4 alt_ic_irq_disable
001226a4 g     F .text	0000007c __swrite
001293b0 g     O .rwdata	00000004 __malloc_trim_threshold
00126fe8 g     F .text	00000038 exit
001217cc g     F .text	000000b8 _fwalk_reent
00133880 g       *ABS*	00000000 __alt_data_end
00120020 g     F .exceptions	00000000 alt_exception
00120ce8 g     F .text	00000004 __sfp_lock_release
00125bcc g     F .text	00000054 altera_avalon_uart_close
00120d24 g     F .text	000000f0 _fopen_r
001276c0 g     F .text	00000034 _exit
00126330 g     F .text	00000140 alt_alarm_start
00121884 g     F .text	000001b8 __smakebuf_r
00122784 g     F .text	00000098 strlen
0012407c g     F .text	00000158 open
001243fc g     F .text	00000044 alt_putchar
001268b8 g     F .text	00000030 alt_icache_flush_all
001293d8 g     O .rwdata	00000004 alt_priority_mask
00126938 g     F .text	000000a0 alt_ic_irq_enable
001255a0 g     F .text	00000024 altera_avalon_mutex_close
00125c70 g     F .text	000001dc altera_avalon_uart_read
001293dc g     O .rwdata	00000008 alt_alarm_list
001265a8 g     F .text	0000005c _do_ctors
001239b0 g     F .text	000000d0 close
00123d04 g     F .text	00000080 alt_load
00000000  w      *UND*	00000000 free
00120cec g     F .text	00000004 __sinit_lock_acquire



Disassembly of section .entry:

00120000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
  120000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
  120004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
  120008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
  12000c:	00bffd16 	blt	zero,r2,120004 <__alt_data_end+0xfffec784>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  120010:	004004b4 	movhi	at,18
    ori r1, r1, %lo(_start)
  120014:	08409014 	ori	at,at,576
    jmp r1
  120018:	0800683a 	jmp	at
  12001c:	00000000 	call	0 <__reset-0x120000>

Disassembly of section .exceptions:

00120020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
  120020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
  120024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
  120028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  12002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  120030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  120034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  120038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  12003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  120040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
  120044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
  120048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  12004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  120050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  120054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  120058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  12005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  120060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  120064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  120068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  12006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  120070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  120074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  120078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  12007c:	10000326 	beq	r2,zero,12008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
  120080:	20000226 	beq	r4,zero,12008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  120084:	01200fc0 	call	1200fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  120088:	00000706 	br	1200a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
  12008c:	df401215 	stw	ea,72(sp)
        ldhu.n  r2, 0(r4)
        ldhu.n  r3, 2(r4)
        slli.n  r3, r3, 16
        or.n    r2, r2, r3 /* Instruction that caused exception */
#else
        ldw   r2, -4(ea)   /* Instruction that caused exception */
  120090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
  120094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
  120098:	01201cc0 	call	1201cc <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
  12009c:	1000021e 	bne	r2,zero,1200a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
  1200a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  1200a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
  1200a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  1200ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  1200b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  1200b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  1200b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  1200bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  1200c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  1200c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  1200c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  1200cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  1200d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
  1200d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  1200d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  1200dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  1200e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  1200e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  1200e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  1200ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  1200f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
  1200f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
  1200f8:	ef80083a 	eret

001200fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  1200fc:	defff904 	addi	sp,sp,-28
  120100:	dfc00615 	stw	ra,24(sp)
  120104:	df000515 	stw	fp,20(sp)
  120108:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
  12010c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  120110:	0005313a 	rdctl	r2,ipending
  120114:	e0bffe15 	stw	r2,-8(fp)

  return active;
  120118:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
  12011c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
  120120:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
  120124:	00800044 	movi	r2,1
  120128:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  12012c:	e0fffb17 	ldw	r3,-20(fp)
  120130:	e0bffc17 	ldw	r2,-16(fp)
  120134:	1884703a 	and	r2,r3,r2
  120138:	10001426 	beq	r2,zero,12018c <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  12013c:	008004f4 	movhi	r2,19
  120140:	10abf204 	addi	r2,r2,-20536
  120144:	e0fffd17 	ldw	r3,-12(fp)
  120148:	180690fa 	slli	r3,r3,3
  12014c:	10c5883a 	add	r2,r2,r3
  120150:	10c00017 	ldw	r3,0(r2)
  120154:	008004f4 	movhi	r2,19
  120158:	10abf204 	addi	r2,r2,-20536
  12015c:	e13ffd17 	ldw	r4,-12(fp)
  120160:	200890fa 	slli	r4,r4,3
  120164:	1105883a 	add	r2,r2,r4
  120168:	10800104 	addi	r2,r2,4
  12016c:	10800017 	ldw	r2,0(r2)
  120170:	1009883a 	mov	r4,r2
  120174:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
  120178:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  12017c:	0005313a 	rdctl	r2,ipending
  120180:	e0bfff15 	stw	r2,-4(fp)

  return active;
  120184:	e0bfff17 	ldw	r2,-4(fp)
  120188:	00000706 	br	1201a8 <alt_irq_handler+0xac>
      }
      mask <<= 1;
  12018c:	e0bffc17 	ldw	r2,-16(fp)
  120190:	1085883a 	add	r2,r2,r2
  120194:	e0bffc15 	stw	r2,-16(fp)
      i++;
  120198:	e0bffd17 	ldw	r2,-12(fp)
  12019c:	10800044 	addi	r2,r2,1
  1201a0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
  1201a4:	003fe106 	br	12012c <__alt_data_end+0xfffec8ac>

    active = alt_irq_pending ();
  1201a8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
  1201ac:	e0bffb17 	ldw	r2,-20(fp)
  1201b0:	103fdb1e 	bne	r2,zero,120120 <__alt_data_end+0xfffec8a0>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
  1201b4:	0001883a 	nop
}
  1201b8:	e037883a 	mov	sp,fp
  1201bc:	dfc00117 	ldw	ra,4(sp)
  1201c0:	df000017 	ldw	fp,0(sp)
  1201c4:	dec00204 	addi	sp,sp,8
  1201c8:	f800283a 	ret

001201cc <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
  1201cc:	defffb04 	addi	sp,sp,-20
  1201d0:	dfc00415 	stw	ra,16(sp)
  1201d4:	df000315 	stw	fp,12(sp)
  1201d8:	df000304 	addi	fp,sp,12
  1201dc:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
  1201e0:	000531fa 	rdctl	r2,exception
  1201e4:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
  1201e8:	e0bffd17 	ldw	r2,-12(fp)
  1201ec:	10801f0c 	andi	r2,r2,124
  1201f0:	1004d0ba 	srli	r2,r2,2
  1201f4:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
  1201f8:	0005333a 	rdctl	r2,badaddr
  1201fc:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
  120200:	d0a6fe17 	ldw	r2,-25608(gp)
  120204:	10000726 	beq	r2,zero,120224 <alt_instruction_exception_entry+0x58>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
  120208:	d0a6fe17 	ldw	r2,-25608(gp)
  12020c:	e0fffd17 	ldw	r3,-12(fp)
  120210:	1809883a 	mov	r4,r3
  120214:	e17fff17 	ldw	r5,-4(fp)
  120218:	e1bffe17 	ldw	r6,-8(fp)
  12021c:	103ee83a 	callr	r2
  120220:	00000206 	br	12022c <alt_instruction_exception_entry+0x60>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
  120224:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
  120228:	0005883a 	mov	r2,zero
}
  12022c:	e037883a 	mov	sp,fp
  120230:	dfc00117 	ldw	ra,4(sp)
  120234:	df000017 	ldw	fp,0(sp)
  120238:	dec00204 	addi	sp,sp,8
  12023c:	f800283a 	ret

Disassembly of section .text:

00120240 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
  120240:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
  120244:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
  120248:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
  12024c:	00bffd16 	blt	zero,r2,120244 <__alt_data_end+0xfffec9c4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  120250:	06c004f4 	movhi	sp,19
    ori sp, sp, %lo(__alt_stack_pointer)
  120254:	dece2014 	ori	sp,sp,14464
    movhi gp, %hi(_gp)
  120258:	068004f4 	movhi	gp,19
    ori gp, gp, %lo(_gp)
  12025c:	d684e914 	ori	gp,gp,5028
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  120260:	008004b4 	movhi	r2,18
    ori r2, r2, %lo(__bss_start)
  120264:	10abdd14 	ori	r2,r2,44916

    movhi r3, %hi(__bss_end)
  120268:	00c004b4 	movhi	r3,18
    ori r3, r3, %lo(__bss_end)
  12026c:	18ec3214 	ori	r3,r3,45256

    beq r2, r3, 1f
  120270:	10c00326 	beq	r2,r3,120280 <_start+0x40>

0:
    stw zero, (r2)
  120274:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  120278:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  12027c:	10fffd36 	bltu	r2,r3,120274 <__alt_data_end+0xfffec9f4>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  120280:	0123d040 	call	123d04 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  120284:	0123ea80 	call	123ea8 <alt_main>

00120288 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  120288:	003fff06 	br	120288 <__alt_data_end+0xfffeca08>

0012028c <main>:
#include "altera_avalon_uart.h"
#include "altera_avalon_uart_regs.h"
#include "altera_up_avalon_video_character_buffer_with_dma.h"

int main()
{
  12028c:	deffec04 	addi	sp,sp,-80
  120290:	dfc01315 	stw	ra,76(sp)
  120294:	df001215 	stw	fp,72(sp)
  120298:	df001204 	addi	fp,sp,72
	char str1[]={"SLAVE1 (Green ON)"};
  12029c:	00959074 	movhi	r2,22081
  1202a0:	109314c4 	addi	r2,r2,19539
  1202a4:	e0bff415 	stw	r2,-48(fp)
  1202a8:	008a0834 	movhi	r2,10272
  1202ac:	108c5144 	addi	r2,r2,12613
  1202b0:	e0bff515 	stw	r2,-44(fp)
  1202b4:	00995974 	movhi	r2,25957
  1202b8:	109c91c4 	addi	r2,r2,29255
  1202bc:	e0bff615 	stw	r2,-40(fp)
  1202c0:	009393f4 	movhi	r2,20047
  1202c4:	10881b84 	addi	r2,r2,8302
  1202c8:	e0bff715 	stw	r2,-36(fp)
  1202cc:	00800a44 	movi	r2,41
  1202d0:	e0bff80d 	sth	r2,-32(fp)
	char str2[]={"SLAVE1 (Red ON)"};
  1202d4:	009314c4 	movi	r2,19539
  1202d8:	e0bff88d 	sth	r2,-30(fp)
  1202dc:	00959044 	movi	r2,22081
  1202e0:	e0bff90d 	sth	r2,-28(fp)
  1202e4:	008c5144 	movi	r2,12613
  1202e8:	e0bff98d 	sth	r2,-26(fp)
  1202ec:	008a0804 	movi	r2,10272
  1202f0:	e0bffa0d 	sth	r2,-24(fp)
  1202f4:	00995484 	movi	r2,25938
  1202f8:	e0bffa8d 	sth	r2,-22(fp)
  1202fc:	00881904 	movi	r2,8292
  120300:	e0bffb0d 	sth	r2,-20(fp)
  120304:	009393c4 	movi	r2,20047
  120308:	e0bffb8d 	sth	r2,-18(fp)
  12030c:	00800a44 	movi	r2,41
  120310:	e0bffc0d 	sth	r2,-16(fp)
	char str3[]={"SLAVE1 (OFF)"};
  120314:	009314c4 	movi	r2,19539
  120318:	e0bffc8d 	sth	r2,-14(fp)
  12031c:	00959044 	movi	r2,22081
  120320:	e0bffd0d 	sth	r2,-12(fp)
  120324:	008c5144 	movi	r2,12613
  120328:	e0bffd8d 	sth	r2,-10(fp)
  12032c:	008a0804 	movi	r2,10272
  120330:	e0bffe0d 	sth	r2,-8(fp)
  120334:	009193c4 	movi	r2,17999
  120338:	e0bffe8d 	sth	r2,-6(fp)
  12033c:	008a5184 	movi	r2,10566
  120340:	e0bfff0d 	sth	r2,-4(fp)
  120344:	e03fff85 	stb	zero,-2(fp)
	 alt_mutex_dev *Mymutex;
		 Mymutex=altera_avalon_mutex_open("/dev/mutex_0");
  120348:	010004b4 	movhi	r4,18
  12034c:	211dbd04 	addi	r4,r4,30452
  120350:	012554c0 	call	12554c <altera_avalon_mutex_open>
  120354:	e0bff015 	stw	r2,-64(fp)
  printf("Hello from Nios II#2!\n");
  120358:	010004b4 	movhi	r4,18
  12035c:	211dc104 	addi	r4,r4,30468
  120360:	012241c0 	call	12241c <puts>
  int y=0;
  120364:	e03fee15 	stw	zero,-72(fp)
  while(altera_avalon_mutex_trylock(Mymutex,ALT_CPU_CPU_ID_VALUE ))
  120368:	0001883a 	nop
  12036c:	e13ff017 	ldw	r4,-64(fp)
  120370:	000b883a 	mov	r5,zero
  120374:	01256040 	call	125604 <altera_avalon_mutex_trylock>
  120378:	103ffc1e 	bne	r2,zero,12036c <__alt_data_end+0xfffecaec>
  	 {}
  FILE *fp;

  	 alt_up_char_buffer_dev * vga_dev;
  	 	// open the VGA port
  	 	vga_dev = alt_up_char_buffer_open_dev("/dev/video_character_buffer_with_dma_0");
  12037c:	010004b4 	movhi	r4,18
  120380:	211dc704 	addi	r4,r4,30492
  120384:	01260c80 	call	1260c8 <alt_up_char_buffer_open_dev>
  120388:	e0bff115 	stw	r2,-60(fp)

  	 	if (vga_dev == NULL)
  12038c:	e0bff117 	ldw	r2,-60(fp)
  120390:	1000041e 	bne	r2,zero,1203a4 <main+0x118>
  	 	    	alt_printf ("Error: could not open VGA device \n");
  120394:	010004b4 	movhi	r4,18
  120398:	211dd104 	addi	r4,r4,30532
  12039c:	01241d40 	call	1241d4 <alt_printf>
  1203a0:	00000306 	br	1203b0 <main+0x124>
  	 	    	else
  	 	    	alt_printf ("Opened VGA device \n");
  1203a4:	010004b4 	movhi	r4,18
  1203a8:	211dda04 	addi	r4,r4,30568
  1203ac:	01241d40 	call	1241d4 <alt_printf>
    altera_avalon_mutex_unlock (Mymutex);
  1203b0:	e13ff017 	ldw	r4,-64(fp)
  1203b4:	01256440 	call	125644 <altera_avalon_mutex_unlock>

  while(1){
	  //int x=IORD_ALTERA_AVALON_PIO_DATA(PIOSLAVE1_BASE);
	  while(altera_avalon_mutex_trylock(Mymutex,ALT_CPU_CPU_ID_VALUE ))
  1203b8:	0001883a 	nop
  1203bc:	e13ff017 	ldw	r4,-64(fp)
  1203c0:	000b883a 	mov	r5,zero
  1203c4:	01256040 	call	125604 <altera_avalon_mutex_trylock>
  1203c8:	103ffc1e 	bne	r2,zero,1203bc <__alt_data_end+0xfffecb3c>
	  	 {}
	  fp = fopen("/dev/uart_0","w");
  1203cc:	010004b4 	movhi	r4,18
  1203d0:	211ddf04 	addi	r4,r4,30588
  1203d4:	014004b4 	movhi	r5,18
  1203d8:	295de204 	addi	r5,r5,30600
  1203dc:	0120e140 	call	120e14 <fopen>
  1203e0:	e0bff215 	stw	r2,-56(fp)
	  int y0=IORD_ALTERA_AVALON_UART_RXDATA(UART_0_BASE);
  1203e4:	00804034 	movhi	r2,256
  1203e8:	10800037 	ldwio	r2,0(r2)
  1203ec:	e0bff315 	stw	r2,-52(fp)
	  int x=IORD_16DIRECT(0x41008,0);
  1203f0:	00800134 	movhi	r2,4
  1203f4:	10840204 	addi	r2,r2,4104
  1203f8:	1080002b 	ldhuio	r2,0(r2)
  1203fc:	10bfffcc 	andi	r2,r2,65535
  120400:	e0bfef15 	stw	r2,-68(fp)
	  if((y0==0xF)||(y0==0xFF)) x=0;
  120404:	e0bff317 	ldw	r2,-52(fp)
  120408:	108003e0 	cmpeqi	r2,r2,15
  12040c:	1000031e 	bne	r2,zero,12041c <main+0x190>
  120410:	e0bff317 	ldw	r2,-52(fp)
  120414:	10803fd8 	cmpnei	r2,r2,255
  120418:	1000011e 	bne	r2,zero,120420 <main+0x194>
  12041c:	e03fef15 	stw	zero,-68(fp)
	  //printf("%d", y0);
	  fclose(fp);
  120420:	e13ff217 	ldw	r4,-56(fp)
  120424:	01207180 	call	120718 <fclose>
	  altera_avalon_mutex_unlock (Mymutex);
  120428:	e13ff017 	ldw	r4,-64(fp)
  12042c:	01256440 	call	125644 <altera_avalon_mutex_unlock>

	  if(x==255) {
  120430:	e0bfef17 	ldw	r2,-68(fp)
  120434:	10803fd8 	cmpnei	r2,r2,255
  120438:	1000211e 	bne	r2,zero,1204c0 <main+0x234>
		  printf("GreenON\n");
  12043c:	010004b4 	movhi	r4,18
  120440:	211de304 	addi	r4,r4,30604
  120444:	012241c0 	call	12241c <puts>
		  if(y==256)y=0;
  120448:	e0bfee17 	ldw	r2,-72(fp)
  12044c:	10804018 	cmpnei	r2,r2,256
  120450:	1000011e 	bne	r2,zero,120458 <main+0x1cc>
  120454:	e03fee15 	stw	zero,-72(fp)
		  while(altera_avalon_mutex_trylock(Mymutex,ALT_CPU_CPU_ID_VALUE ))
  120458:	0001883a 	nop
  12045c:	e13ff017 	ldw	r4,-64(fp)
  120460:	000b883a 	mov	r5,zero
  120464:	01256040 	call	125604 <altera_avalon_mutex_trylock>
  120468:	103ffc1e 	bne	r2,zero,12045c <__alt_data_end+0xfffecbdc>
		  	  	 {}
		  alt_up_char_buffer_string(vga_dev, str1, 1, 2);
  12046c:	e0bff404 	addi	r2,fp,-48
  120470:	e13ff117 	ldw	r4,-60(fp)
  120474:	100b883a 	mov	r5,r2
  120478:	01800044 	movi	r6,1
  12047c:	01c00084 	movi	r7,2
  120480:	01261d40 	call	1261d4 <alt_up_char_buffer_string>
		  IOWR_ALTERA_AVALON_PIO_DATA(LEDGSLAVE1_BASE, y);
  120484:	00800534 	movhi	r2,20
  120488:	10840004 	addi	r2,r2,4096
  12048c:	e0ffee17 	ldw	r3,-72(fp)
  120490:	10c00035 	stwio	r3,0(r2)
		  altera_avalon_mutex_unlock (Mymutex);
  120494:	e13ff017 	ldw	r4,-64(fp)
  120498:	01256440 	call	125644 <altera_avalon_mutex_unlock>
		  y=y*2;
  12049c:	e0bfee17 	ldw	r2,-72(fp)
  1204a0:	1085883a 	add	r2,r2,r2
  1204a4:	e0bfee15 	stw	r2,-72(fp)
		  if(y==0)y=1;
  1204a8:	e0bfee17 	ldw	r2,-72(fp)
  1204ac:	1000021e 	bne	r2,zero,1204b8 <main+0x22c>
  1204b0:	00800044 	movi	r2,1
  1204b4:	e0bfee15 	stw	r2,-72(fp)
		  delay10ms(20);
  1204b8:	01000504 	movi	r4,20
  1204bc:	01205c00 	call	1205c0 <delay10ms>
	  }
	  if(x==15) {
  1204c0:	e0bfef17 	ldw	r2,-68(fp)
  1204c4:	108003d8 	cmpnei	r2,r2,15
  1204c8:	1000211e 	bne	r2,zero,120550 <main+0x2c4>
	  		  printf("redON\n");
  1204cc:	010004b4 	movhi	r4,18
  1204d0:	211de504 	addi	r4,r4,30612
  1204d4:	012241c0 	call	12241c <puts>
	  		  if(y==256)y=0;
  1204d8:	e0bfee17 	ldw	r2,-72(fp)
  1204dc:	10804018 	cmpnei	r2,r2,256
  1204e0:	1000011e 	bne	r2,zero,1204e8 <main+0x25c>
  1204e4:	e03fee15 	stw	zero,-72(fp)
	  		  while(altera_avalon_mutex_trylock(Mymutex,ALT_CPU_CPU_ID_VALUE ))
  1204e8:	0001883a 	nop
  1204ec:	e13ff017 	ldw	r4,-64(fp)
  1204f0:	000b883a 	mov	r5,zero
  1204f4:	01256040 	call	125604 <altera_avalon_mutex_trylock>
  1204f8:	103ffc1e 	bne	r2,zero,1204ec <__alt_data_end+0xfffecc6c>
	  		  	  	 {}
	  		alt_up_char_buffer_string(vga_dev, str2, 1, 2);
  1204fc:	e0bff884 	addi	r2,fp,-30
  120500:	e13ff117 	ldw	r4,-60(fp)
  120504:	100b883a 	mov	r5,r2
  120508:	01800044 	movi	r6,1
  12050c:	01c00084 	movi	r7,2
  120510:	01261d40 	call	1261d4 <alt_up_char_buffer_string>
	  		  IOWR_ALTERA_AVALON_PIO_DATA(0x241000, y);
  120514:	00800934 	movhi	r2,36
  120518:	10840004 	addi	r2,r2,4096
  12051c:	e0ffee17 	ldw	r3,-72(fp)
  120520:	10c00035 	stwio	r3,0(r2)
	  		  altera_avalon_mutex_unlock (Mymutex);
  120524:	e13ff017 	ldw	r4,-64(fp)
  120528:	01256440 	call	125644 <altera_avalon_mutex_unlock>
	  		  y=y*2;
  12052c:	e0bfee17 	ldw	r2,-72(fp)
  120530:	1085883a 	add	r2,r2,r2
  120534:	e0bfee15 	stw	r2,-72(fp)
	  		  if(y==0)y=1;
  120538:	e0bfee17 	ldw	r2,-72(fp)
  12053c:	1000021e 	bne	r2,zero,120548 <main+0x2bc>
  120540:	00800044 	movi	r2,1
  120544:	e0bfee15 	stw	r2,-72(fp)
	  		  delay10ms(20);
  120548:	01000504 	movi	r4,20
  12054c:	01205c00 	call	1205c0 <delay10ms>
	  	  }
	  if(x==0){
  120550:	e0bfef17 	ldw	r2,-68(fp)
  120554:	1000191e 	bne	r2,zero,1205bc <main+0x330>
		  printf("GreenredOFF\n");
  120558:	010004b4 	movhi	r4,18
  12055c:	211de704 	addi	r4,r4,30620
  120560:	012241c0 	call	12241c <puts>
		  while(altera_avalon_mutex_trylock(Mymutex,ALT_CPU_CPU_ID_VALUE ))
  120564:	0001883a 	nop
  120568:	e13ff017 	ldw	r4,-64(fp)
  12056c:	000b883a 	mov	r5,zero
  120570:	01256040 	call	125604 <altera_avalon_mutex_trylock>
  120574:	103ffc1e 	bne	r2,zero,120568 <__alt_data_end+0xfffecce8>
		  		  	  	 {}
		  alt_up_char_buffer_string(vga_dev, str3, 1, 2);
  120578:	e0bffc84 	addi	r2,fp,-14
  12057c:	e13ff117 	ldw	r4,-60(fp)
  120580:	100b883a 	mov	r5,r2
  120584:	01800044 	movi	r6,1
  120588:	01c00084 	movi	r7,2
  12058c:	01261d40 	call	1261d4 <alt_up_char_buffer_string>
		  IOWR_ALTERA_AVALON_PIO_DATA(LEDGSLAVE1_BASE, 0);
  120590:	0007883a 	mov	r3,zero
  120594:	00800534 	movhi	r2,20
  120598:	10840004 	addi	r2,r2,4096
  12059c:	10c00035 	stwio	r3,0(r2)
		  IOWR_ALTERA_AVALON_PIO_DATA(0x241000, 0);
  1205a0:	0007883a 	mov	r3,zero
  1205a4:	00800934 	movhi	r2,36
  1205a8:	10840004 	addi	r2,r2,4096
  1205ac:	10c00035 	stwio	r3,0(r2)
		  altera_avalon_mutex_unlock (Mymutex);
  1205b0:	e13ff017 	ldw	r4,-64(fp)
  1205b4:	01256440 	call	125644 <altera_avalon_mutex_unlock>
		  y=0;
  1205b8:	e03fee15 	stw	zero,-72(fp)
	  }


  }
  1205bc:	003f7e06 	br	1203b8 <__alt_data_end+0xfffecb38>

001205c0 <delay10ms>:
  return 0;
}


void delay10ms(unsigned long time)
{
  1205c0:	defffd04 	addi	sp,sp,-12
  1205c4:	df000215 	stw	fp,8(sp)
  1205c8:	df000204 	addi	fp,sp,8
  1205cc:	e13fff15 	stw	r4,-4(fp)
	while(time>0)
  1205d0:	00000b06 	br	120600 <delay10ms+0x40>
	{
		int i=13333;
  1205d4:	008d0544 	movi	r2,13333
  1205d8:	e0bffe15 	stw	r2,-8(fp)
		while(i>0)
  1205dc:	00000306 	br	1205ec <delay10ms+0x2c>
		i--;
  1205e0:	e0bffe17 	ldw	r2,-8(fp)
  1205e4:	10bfffc4 	addi	r2,r2,-1
  1205e8:	e0bffe15 	stw	r2,-8(fp)
void delay10ms(unsigned long time)
{
	while(time>0)
	{
		int i=13333;
		while(i>0)
  1205ec:	e0bffe17 	ldw	r2,-8(fp)
  1205f0:	00bffb16 	blt	zero,r2,1205e0 <__alt_data_end+0xfffecd60>
		i--;
		time--;
  1205f4:	e0bfff17 	ldw	r2,-4(fp)
  1205f8:	10bfffc4 	addi	r2,r2,-1
  1205fc:	e0bfff15 	stw	r2,-4(fp)
}


void delay10ms(unsigned long time)
{
	while(time>0)
  120600:	e0bfff17 	ldw	r2,-4(fp)
  120604:	103ff31e 	bne	r2,zero,1205d4 <__alt_data_end+0xfffecd54>
		int i=13333;
		while(i>0)
		i--;
		time--;
	}
}
  120608:	e037883a 	mov	sp,fp
  12060c:	df000017 	ldw	fp,0(sp)
  120610:	dec00104 	addi	sp,sp,4
  120614:	f800283a 	ret

00120618 <_fclose_r>:
  120618:	28003226 	beq	r5,zero,1206e4 <_fclose_r+0xcc>
  12061c:	defffc04 	addi	sp,sp,-16
  120620:	dc400115 	stw	r17,4(sp)
  120624:	2023883a 	mov	r17,r4
  120628:	dc000015 	stw	r16,0(sp)
  12062c:	dfc00315 	stw	ra,12(sp)
  120630:	dc800215 	stw	r18,8(sp)
  120634:	2821883a 	mov	r16,r5
  120638:	0120ce40 	call	120ce4 <__sfp_lock_acquire>
  12063c:	88000226 	beq	r17,zero,120648 <_fclose_r+0x30>
  120640:	88800e17 	ldw	r2,56(r17)
  120644:	10002926 	beq	r2,zero,1206ec <_fclose_r+0xd4>
  120648:	8080030f 	ldh	r2,12(r16)
  12064c:	10002226 	beq	r2,zero,1206d8 <_fclose_r+0xc0>
  120650:	8809883a 	mov	r4,r17
  120654:	800b883a 	mov	r5,r16
  120658:	012072c0 	call	12072c <_fflush_r>
  12065c:	1025883a 	mov	r18,r2
  120660:	80800b17 	ldw	r2,44(r16)
  120664:	10000426 	beq	r2,zero,120678 <_fclose_r+0x60>
  120668:	81400717 	ldw	r5,28(r16)
  12066c:	8809883a 	mov	r4,r17
  120670:	103ee83a 	callr	r2
  120674:	10002616 	blt	r2,zero,120710 <_fclose_r+0xf8>
  120678:	8080030b 	ldhu	r2,12(r16)
  12067c:	1080200c 	andi	r2,r2,128
  120680:	10001f1e 	bne	r2,zero,120700 <_fclose_r+0xe8>
  120684:	81400c17 	ldw	r5,48(r16)
  120688:	28000526 	beq	r5,zero,1206a0 <_fclose_r+0x88>
  12068c:	80801004 	addi	r2,r16,64
  120690:	28800226 	beq	r5,r2,12069c <_fclose_r+0x84>
  120694:	8809883a 	mov	r4,r17
  120698:	0120f540 	call	120f54 <_free_r>
  12069c:	80000c15 	stw	zero,48(r16)
  1206a0:	81401117 	ldw	r5,68(r16)
  1206a4:	28000326 	beq	r5,zero,1206b4 <_fclose_r+0x9c>
  1206a8:	8809883a 	mov	r4,r17
  1206ac:	0120f540 	call	120f54 <_free_r>
  1206b0:	80001115 	stw	zero,68(r16)
  1206b4:	8000030d 	sth	zero,12(r16)
  1206b8:	0120ce80 	call	120ce8 <__sfp_lock_release>
  1206bc:	9005883a 	mov	r2,r18
  1206c0:	dfc00317 	ldw	ra,12(sp)
  1206c4:	dc800217 	ldw	r18,8(sp)
  1206c8:	dc400117 	ldw	r17,4(sp)
  1206cc:	dc000017 	ldw	r16,0(sp)
  1206d0:	dec00404 	addi	sp,sp,16
  1206d4:	f800283a 	ret
  1206d8:	0120ce80 	call	120ce8 <__sfp_lock_release>
  1206dc:	0005883a 	mov	r2,zero
  1206e0:	003ff706 	br	1206c0 <__alt_data_end+0xfffece40>
  1206e4:	0005883a 	mov	r2,zero
  1206e8:	f800283a 	ret
  1206ec:	8809883a 	mov	r4,r17
  1206f0:	0120cd40 	call	120cd4 <__sinit>
  1206f4:	8080030f 	ldh	r2,12(r16)
  1206f8:	103fd51e 	bne	r2,zero,120650 <__alt_data_end+0xfffecdd0>
  1206fc:	003ff606 	br	1206d8 <__alt_data_end+0xfffece58>
  120700:	81400417 	ldw	r5,16(r16)
  120704:	8809883a 	mov	r4,r17
  120708:	0120f540 	call	120f54 <_free_r>
  12070c:	003fdd06 	br	120684 <__alt_data_end+0xfffece04>
  120710:	04bfffc4 	movi	r18,-1
  120714:	003fd806 	br	120678 <__alt_data_end+0xfffecdf8>

00120718 <fclose>:
  120718:	008004f4 	movhi	r2,19
  12071c:	10a4ea04 	addi	r2,r2,-27736
  120720:	200b883a 	mov	r5,r4
  120724:	11000017 	ldw	r4,0(r2)
  120728:	01206181 	jmpi	120618 <_fclose_r>

0012072c <_fflush_r>:
  12072c:	defffb04 	addi	sp,sp,-20
  120730:	dcc00315 	stw	r19,12(sp)
  120734:	dc000015 	stw	r16,0(sp)
  120738:	dfc00415 	stw	ra,16(sp)
  12073c:	dc800215 	stw	r18,8(sp)
  120740:	dc400115 	stw	r17,4(sp)
  120744:	2027883a 	mov	r19,r4
  120748:	2821883a 	mov	r16,r5
  12074c:	20000226 	beq	r4,zero,120758 <_fflush_r+0x2c>
  120750:	20800e17 	ldw	r2,56(r4)
  120754:	10005326 	beq	r2,zero,1208a4 <_fflush_r+0x178>
  120758:	8080030b 	ldhu	r2,12(r16)
  12075c:	10ffffcc 	andi	r3,r2,65535
  120760:	18e0001c 	xori	r3,r3,32768
  120764:	18e00004 	addi	r3,r3,-32768
  120768:	18002c26 	beq	r3,zero,12081c <_fflush_r+0xf0>
  12076c:	10c0020c 	andi	r3,r2,8
  120770:	1800321e 	bne	r3,zero,12083c <_fflush_r+0x110>
  120774:	80c00117 	ldw	r3,4(r16)
  120778:	10820014 	ori	r2,r2,2048
  12077c:	8080030d 	sth	r2,12(r16)
  120780:	00c0570e 	bge	zero,r3,1208e0 <_fflush_r+0x1b4>
  120784:	82000a17 	ldw	r8,40(r16)
  120788:	40002426 	beq	r8,zero,12081c <_fflush_r+0xf0>
  12078c:	9c400017 	ldw	r17,0(r19)
  120790:	10c4000c 	andi	r3,r2,4096
  120794:	98000015 	stw	zero,0(r19)
  120798:	18004626 	beq	r3,zero,1208b4 <_fflush_r+0x188>
  12079c:	81801417 	ldw	r6,80(r16)
  1207a0:	10c0010c 	andi	r3,r2,4
  1207a4:	18000626 	beq	r3,zero,1207c0 <_fflush_r+0x94>
  1207a8:	80c00117 	ldw	r3,4(r16)
  1207ac:	80800c17 	ldw	r2,48(r16)
  1207b0:	30cdc83a 	sub	r6,r6,r3
  1207b4:	10000226 	beq	r2,zero,1207c0 <_fflush_r+0x94>
  1207b8:	80800f17 	ldw	r2,60(r16)
  1207bc:	308dc83a 	sub	r6,r6,r2
  1207c0:	81400717 	ldw	r5,28(r16)
  1207c4:	9809883a 	mov	r4,r19
  1207c8:	000f883a 	mov	r7,zero
  1207cc:	403ee83a 	callr	r8
  1207d0:	00ffffc4 	movi	r3,-1
  1207d4:	10c04526 	beq	r2,r3,1208ec <_fflush_r+0x1c0>
  1207d8:	80c0030b 	ldhu	r3,12(r16)
  1207dc:	81000417 	ldw	r4,16(r16)
  1207e0:	80000115 	stw	zero,4(r16)
  1207e4:	197dffcc 	andi	r5,r3,63487
  1207e8:	8140030d 	sth	r5,12(r16)
  1207ec:	81000015 	stw	r4,0(r16)
  1207f0:	18c4000c 	andi	r3,r3,4096
  1207f4:	18000126 	beq	r3,zero,1207fc <_fflush_r+0xd0>
  1207f8:	80801415 	stw	r2,80(r16)
  1207fc:	81400c17 	ldw	r5,48(r16)
  120800:	9c400015 	stw	r17,0(r19)
  120804:	28000526 	beq	r5,zero,12081c <_fflush_r+0xf0>
  120808:	80801004 	addi	r2,r16,64
  12080c:	28800226 	beq	r5,r2,120818 <_fflush_r+0xec>
  120810:	9809883a 	mov	r4,r19
  120814:	0120f540 	call	120f54 <_free_r>
  120818:	80000c15 	stw	zero,48(r16)
  12081c:	0005883a 	mov	r2,zero
  120820:	dfc00417 	ldw	ra,16(sp)
  120824:	dcc00317 	ldw	r19,12(sp)
  120828:	dc800217 	ldw	r18,8(sp)
  12082c:	dc400117 	ldw	r17,4(sp)
  120830:	dc000017 	ldw	r16,0(sp)
  120834:	dec00504 	addi	sp,sp,20
  120838:	f800283a 	ret
  12083c:	84800417 	ldw	r18,16(r16)
  120840:	903ff626 	beq	r18,zero,12081c <__alt_data_end+0xfffecf9c>
  120844:	84400017 	ldw	r17,0(r16)
  120848:	108000cc 	andi	r2,r2,3
  12084c:	84800015 	stw	r18,0(r16)
  120850:	8ca3c83a 	sub	r17,r17,r18
  120854:	10001526 	beq	r2,zero,1208ac <_fflush_r+0x180>
  120858:	0005883a 	mov	r2,zero
  12085c:	80800215 	stw	r2,8(r16)
  120860:	04400316 	blt	zero,r17,120870 <_fflush_r+0x144>
  120864:	003fed06 	br	12081c <__alt_data_end+0xfffecf9c>
  120868:	90a5883a 	add	r18,r18,r2
  12086c:	047feb0e 	bge	zero,r17,12081c <__alt_data_end+0xfffecf9c>
  120870:	80800917 	ldw	r2,36(r16)
  120874:	81400717 	ldw	r5,28(r16)
  120878:	880f883a 	mov	r7,r17
  12087c:	900d883a 	mov	r6,r18
  120880:	9809883a 	mov	r4,r19
  120884:	103ee83a 	callr	r2
  120888:	88a3c83a 	sub	r17,r17,r2
  12088c:	00bff616 	blt	zero,r2,120868 <__alt_data_end+0xfffecfe8>
  120890:	80c0030b 	ldhu	r3,12(r16)
  120894:	00bfffc4 	movi	r2,-1
  120898:	18c01014 	ori	r3,r3,64
  12089c:	80c0030d 	sth	r3,12(r16)
  1208a0:	003fdf06 	br	120820 <__alt_data_end+0xfffecfa0>
  1208a4:	0120cd40 	call	120cd4 <__sinit>
  1208a8:	003fab06 	br	120758 <__alt_data_end+0xfffeced8>
  1208ac:	80800517 	ldw	r2,20(r16)
  1208b0:	003fea06 	br	12085c <__alt_data_end+0xfffecfdc>
  1208b4:	81400717 	ldw	r5,28(r16)
  1208b8:	000d883a 	mov	r6,zero
  1208bc:	9809883a 	mov	r4,r19
  1208c0:	01c00044 	movi	r7,1
  1208c4:	403ee83a 	callr	r8
  1208c8:	100d883a 	mov	r6,r2
  1208cc:	00bfffc4 	movi	r2,-1
  1208d0:	30801326 	beq	r6,r2,120920 <_fflush_r+0x1f4>
  1208d4:	8080030b 	ldhu	r2,12(r16)
  1208d8:	82000a17 	ldw	r8,40(r16)
  1208dc:	003fb006 	br	1207a0 <__alt_data_end+0xfffecf20>
  1208e0:	80c00f17 	ldw	r3,60(r16)
  1208e4:	00ffa716 	blt	zero,r3,120784 <__alt_data_end+0xfffecf04>
  1208e8:	003fcc06 	br	12081c <__alt_data_end+0xfffecf9c>
  1208ec:	98c00017 	ldw	r3,0(r19)
  1208f0:	183fb926 	beq	r3,zero,1207d8 <__alt_data_end+0xfffecf58>
  1208f4:	01000744 	movi	r4,29
  1208f8:	19000226 	beq	r3,r4,120904 <_fflush_r+0x1d8>
  1208fc:	01000584 	movi	r4,22
  120900:	1900101e 	bne	r3,r4,120944 <_fflush_r+0x218>
  120904:	8080030b 	ldhu	r2,12(r16)
  120908:	80c00417 	ldw	r3,16(r16)
  12090c:	80000115 	stw	zero,4(r16)
  120910:	10bdffcc 	andi	r2,r2,63487
  120914:	8080030d 	sth	r2,12(r16)
  120918:	80c00015 	stw	r3,0(r16)
  12091c:	003fb706 	br	1207fc <__alt_data_end+0xfffecf7c>
  120920:	98800017 	ldw	r2,0(r19)
  120924:	103feb26 	beq	r2,zero,1208d4 <__alt_data_end+0xfffed054>
  120928:	00c00744 	movi	r3,29
  12092c:	10c00226 	beq	r2,r3,120938 <_fflush_r+0x20c>
  120930:	00c00584 	movi	r3,22
  120934:	10ffd61e 	bne	r2,r3,120890 <__alt_data_end+0xfffed010>
  120938:	9c400015 	stw	r17,0(r19)
  12093c:	0005883a 	mov	r2,zero
  120940:	003fb706 	br	120820 <__alt_data_end+0xfffecfa0>
  120944:	80c0030b 	ldhu	r3,12(r16)
  120948:	18c01014 	ori	r3,r3,64
  12094c:	80c0030d 	sth	r3,12(r16)
  120950:	003fb306 	br	120820 <__alt_data_end+0xfffecfa0>

00120954 <fflush>:
  120954:	20000526 	beq	r4,zero,12096c <fflush+0x18>
  120958:	008004f4 	movhi	r2,19
  12095c:	10a4ea04 	addi	r2,r2,-27736
  120960:	200b883a 	mov	r5,r4
  120964:	11000017 	ldw	r4,0(r2)
  120968:	012072c1 	jmpi	12072c <_fflush_r>
  12096c:	008004f4 	movhi	r2,19
  120970:	10a4e904 	addi	r2,r2,-27740
  120974:	11000017 	ldw	r4,0(r2)
  120978:	014004b4 	movhi	r5,18
  12097c:	2941cb04 	addi	r5,r5,1836
  120980:	01217cc1 	jmpi	1217cc <_fwalk_reent>

00120984 <__fp_lock>:
  120984:	0005883a 	mov	r2,zero
  120988:	f800283a 	ret

0012098c <__fp_unlock>:
  12098c:	0005883a 	mov	r2,zero
  120990:	f800283a 	ret

00120994 <_cleanup_r>:
  120994:	014004b4 	movhi	r5,18
  120998:	2941c604 	addi	r5,r5,1816
  12099c:	01217141 	jmpi	121714 <_fwalk>

001209a0 <__sinit.part.1>:
  1209a0:	defff604 	addi	sp,sp,-40
  1209a4:	00c004b4 	movhi	r3,18
  1209a8:	dfc00915 	stw	ra,36(sp)
  1209ac:	df000815 	stw	fp,32(sp)
  1209b0:	ddc00715 	stw	r23,28(sp)
  1209b4:	dd800615 	stw	r22,24(sp)
  1209b8:	dd400515 	stw	r21,20(sp)
  1209bc:	dd000415 	stw	r20,16(sp)
  1209c0:	dcc00315 	stw	r19,12(sp)
  1209c4:	dc800215 	stw	r18,8(sp)
  1209c8:	dc400115 	stw	r17,4(sp)
  1209cc:	dc000015 	stw	r16,0(sp)
  1209d0:	18c26504 	addi	r3,r3,2452
  1209d4:	24000117 	ldw	r16,4(r4)
  1209d8:	20c00f15 	stw	r3,60(r4)
  1209dc:	07000044 	movi	fp,1
  1209e0:	00c000c4 	movi	r3,3
  1209e4:	2080bb04 	addi	r2,r4,748
  1209e8:	20c0b915 	stw	r3,740(r4)
  1209ec:	27000e15 	stw	fp,56(r4)
  1209f0:	2080ba15 	stw	r2,744(r4)
  1209f4:	2000b815 	stw	zero,736(r4)
  1209f8:	05c00204 	movi	r23,8
  1209fc:	00800104 	movi	r2,4
  120a00:	2025883a 	mov	r18,r4
  120a04:	b80d883a 	mov	r6,r23
  120a08:	81001704 	addi	r4,r16,92
  120a0c:	000b883a 	mov	r5,zero
  120a10:	80000015 	stw	zero,0(r16)
  120a14:	80000115 	stw	zero,4(r16)
  120a18:	80000215 	stw	zero,8(r16)
  120a1c:	8080030d 	sth	r2,12(r16)
  120a20:	80001915 	stw	zero,100(r16)
  120a24:	8000038d 	sth	zero,14(r16)
  120a28:	80000415 	stw	zero,16(r16)
  120a2c:	80000515 	stw	zero,20(r16)
  120a30:	80000615 	stw	zero,24(r16)
  120a34:	01221e40 	call	1221e4 <memset>
  120a38:	058004b4 	movhi	r22,18
  120a3c:	94400217 	ldw	r17,8(r18)
  120a40:	054004b4 	movhi	r21,18
  120a44:	050004b4 	movhi	r20,18
  120a48:	04c004b4 	movhi	r19,18
  120a4c:	b5899204 	addi	r22,r22,9800
  120a50:	ad49a904 	addi	r21,r21,9892
  120a54:	a509c804 	addi	r20,r20,10016
  120a58:	9cc9df04 	addi	r19,r19,10108
  120a5c:	85800815 	stw	r22,32(r16)
  120a60:	85400915 	stw	r21,36(r16)
  120a64:	85000a15 	stw	r20,40(r16)
  120a68:	84c00b15 	stw	r19,44(r16)
  120a6c:	84000715 	stw	r16,28(r16)
  120a70:	00800284 	movi	r2,10
  120a74:	89001704 	addi	r4,r17,92
  120a78:	b80d883a 	mov	r6,r23
  120a7c:	000b883a 	mov	r5,zero
  120a80:	88000015 	stw	zero,0(r17)
  120a84:	88000115 	stw	zero,4(r17)
  120a88:	88000215 	stw	zero,8(r17)
  120a8c:	8880030d 	sth	r2,12(r17)
  120a90:	88001915 	stw	zero,100(r17)
  120a94:	8f00038d 	sth	fp,14(r17)
  120a98:	88000415 	stw	zero,16(r17)
  120a9c:	88000515 	stw	zero,20(r17)
  120aa0:	88000615 	stw	zero,24(r17)
  120aa4:	01221e40 	call	1221e4 <memset>
  120aa8:	94000317 	ldw	r16,12(r18)
  120aac:	00800484 	movi	r2,18
  120ab0:	8c400715 	stw	r17,28(r17)
  120ab4:	8d800815 	stw	r22,32(r17)
  120ab8:	8d400915 	stw	r21,36(r17)
  120abc:	8d000a15 	stw	r20,40(r17)
  120ac0:	8cc00b15 	stw	r19,44(r17)
  120ac4:	8080030d 	sth	r2,12(r16)
  120ac8:	00800084 	movi	r2,2
  120acc:	80000015 	stw	zero,0(r16)
  120ad0:	80000115 	stw	zero,4(r16)
  120ad4:	80000215 	stw	zero,8(r16)
  120ad8:	80001915 	stw	zero,100(r16)
  120adc:	8080038d 	sth	r2,14(r16)
  120ae0:	80000415 	stw	zero,16(r16)
  120ae4:	80000515 	stw	zero,20(r16)
  120ae8:	80000615 	stw	zero,24(r16)
  120aec:	81001704 	addi	r4,r16,92
  120af0:	000b883a 	mov	r5,zero
  120af4:	b80d883a 	mov	r6,r23
  120af8:	01221e40 	call	1221e4 <memset>
  120afc:	84000715 	stw	r16,28(r16)
  120b00:	85800815 	stw	r22,32(r16)
  120b04:	85400915 	stw	r21,36(r16)
  120b08:	85000a15 	stw	r20,40(r16)
  120b0c:	84c00b15 	stw	r19,44(r16)
  120b10:	dfc00917 	ldw	ra,36(sp)
  120b14:	df000817 	ldw	fp,32(sp)
  120b18:	ddc00717 	ldw	r23,28(sp)
  120b1c:	dd800617 	ldw	r22,24(sp)
  120b20:	dd400517 	ldw	r21,20(sp)
  120b24:	dd000417 	ldw	r20,16(sp)
  120b28:	dcc00317 	ldw	r19,12(sp)
  120b2c:	dc800217 	ldw	r18,8(sp)
  120b30:	dc400117 	ldw	r17,4(sp)
  120b34:	dc000017 	ldw	r16,0(sp)
  120b38:	dec00a04 	addi	sp,sp,40
  120b3c:	f800283a 	ret

00120b40 <__sfmoreglue>:
  120b40:	defffc04 	addi	sp,sp,-16
  120b44:	dc400115 	stw	r17,4(sp)
  120b48:	2c401a24 	muli	r17,r5,104
  120b4c:	dc800215 	stw	r18,8(sp)
  120b50:	2825883a 	mov	r18,r5
  120b54:	89400304 	addi	r5,r17,12
  120b58:	dc000015 	stw	r16,0(sp)
  120b5c:	dfc00315 	stw	ra,12(sp)
  120b60:	0121a3c0 	call	121a3c <_malloc_r>
  120b64:	1021883a 	mov	r16,r2
  120b68:	10000726 	beq	r2,zero,120b88 <__sfmoreglue+0x48>
  120b6c:	11000304 	addi	r4,r2,12
  120b70:	10000015 	stw	zero,0(r2)
  120b74:	14800115 	stw	r18,4(r2)
  120b78:	11000215 	stw	r4,8(r2)
  120b7c:	000b883a 	mov	r5,zero
  120b80:	880d883a 	mov	r6,r17
  120b84:	01221e40 	call	1221e4 <memset>
  120b88:	8005883a 	mov	r2,r16
  120b8c:	dfc00317 	ldw	ra,12(sp)
  120b90:	dc800217 	ldw	r18,8(sp)
  120b94:	dc400117 	ldw	r17,4(sp)
  120b98:	dc000017 	ldw	r16,0(sp)
  120b9c:	dec00404 	addi	sp,sp,16
  120ba0:	f800283a 	ret

00120ba4 <__sfp>:
  120ba4:	008004f4 	movhi	r2,19
  120ba8:	defffb04 	addi	sp,sp,-20
  120bac:	10a4e904 	addi	r2,r2,-27740
  120bb0:	dc800215 	stw	r18,8(sp)
  120bb4:	14800017 	ldw	r18,0(r2)
  120bb8:	dcc00315 	stw	r19,12(sp)
  120bbc:	dfc00415 	stw	ra,16(sp)
  120bc0:	90800e17 	ldw	r2,56(r18)
  120bc4:	dc400115 	stw	r17,4(sp)
  120bc8:	dc000015 	stw	r16,0(sp)
  120bcc:	2027883a 	mov	r19,r4
  120bd0:	1000021e 	bne	r2,zero,120bdc <__sfp+0x38>
  120bd4:	9009883a 	mov	r4,r18
  120bd8:	01209a00 	call	1209a0 <__sinit.part.1>
  120bdc:	9480b804 	addi	r18,r18,736
  120be0:	047fffc4 	movi	r17,-1
  120be4:	91400117 	ldw	r5,4(r18)
  120be8:	94000217 	ldw	r16,8(r18)
  120bec:	297fffc4 	addi	r5,r5,-1
  120bf0:	28000a16 	blt	r5,zero,120c1c <__sfp+0x78>
  120bf4:	8080030f 	ldh	r2,12(r16)
  120bf8:	10000c26 	beq	r2,zero,120c2c <__sfp+0x88>
  120bfc:	80c01d04 	addi	r3,r16,116
  120c00:	00000206 	br	120c0c <__sfp+0x68>
  120c04:	18bfe60f 	ldh	r2,-104(r3)
  120c08:	10000826 	beq	r2,zero,120c2c <__sfp+0x88>
  120c0c:	297fffc4 	addi	r5,r5,-1
  120c10:	1c3ffd04 	addi	r16,r3,-12
  120c14:	18c01a04 	addi	r3,r3,104
  120c18:	2c7ffa1e 	bne	r5,r17,120c04 <__alt_data_end+0xfffed384>
  120c1c:	90800017 	ldw	r2,0(r18)
  120c20:	10001d26 	beq	r2,zero,120c98 <__sfp+0xf4>
  120c24:	1025883a 	mov	r18,r2
  120c28:	003fee06 	br	120be4 <__alt_data_end+0xfffed364>
  120c2c:	00bfffc4 	movi	r2,-1
  120c30:	8080038d 	sth	r2,14(r16)
  120c34:	00800044 	movi	r2,1
  120c38:	8080030d 	sth	r2,12(r16)
  120c3c:	80001915 	stw	zero,100(r16)
  120c40:	80000015 	stw	zero,0(r16)
  120c44:	80000215 	stw	zero,8(r16)
  120c48:	80000115 	stw	zero,4(r16)
  120c4c:	80000415 	stw	zero,16(r16)
  120c50:	80000515 	stw	zero,20(r16)
  120c54:	80000615 	stw	zero,24(r16)
  120c58:	81001704 	addi	r4,r16,92
  120c5c:	000b883a 	mov	r5,zero
  120c60:	01800204 	movi	r6,8
  120c64:	01221e40 	call	1221e4 <memset>
  120c68:	8005883a 	mov	r2,r16
  120c6c:	80000c15 	stw	zero,48(r16)
  120c70:	80000d15 	stw	zero,52(r16)
  120c74:	80001115 	stw	zero,68(r16)
  120c78:	80001215 	stw	zero,72(r16)
  120c7c:	dfc00417 	ldw	ra,16(sp)
  120c80:	dcc00317 	ldw	r19,12(sp)
  120c84:	dc800217 	ldw	r18,8(sp)
  120c88:	dc400117 	ldw	r17,4(sp)
  120c8c:	dc000017 	ldw	r16,0(sp)
  120c90:	dec00504 	addi	sp,sp,20
  120c94:	f800283a 	ret
  120c98:	9809883a 	mov	r4,r19
  120c9c:	01400104 	movi	r5,4
  120ca0:	0120b400 	call	120b40 <__sfmoreglue>
  120ca4:	90800015 	stw	r2,0(r18)
  120ca8:	103fde1e 	bne	r2,zero,120c24 <__alt_data_end+0xfffed3a4>
  120cac:	00800304 	movi	r2,12
  120cb0:	98800015 	stw	r2,0(r19)
  120cb4:	0005883a 	mov	r2,zero
  120cb8:	003ff006 	br	120c7c <__alt_data_end+0xfffed3fc>

00120cbc <_cleanup>:
  120cbc:	008004f4 	movhi	r2,19
  120cc0:	10a4e904 	addi	r2,r2,-27740
  120cc4:	11000017 	ldw	r4,0(r2)
  120cc8:	014004b4 	movhi	r5,18
  120ccc:	2941c604 	addi	r5,r5,1816
  120cd0:	01217141 	jmpi	121714 <_fwalk>

00120cd4 <__sinit>:
  120cd4:	20800e17 	ldw	r2,56(r4)
  120cd8:	10000126 	beq	r2,zero,120ce0 <__sinit+0xc>
  120cdc:	f800283a 	ret
  120ce0:	01209a01 	jmpi	1209a0 <__sinit.part.1>

00120ce4 <__sfp_lock_acquire>:
  120ce4:	f800283a 	ret

00120ce8 <__sfp_lock_release>:
  120ce8:	f800283a 	ret

00120cec <__sinit_lock_acquire>:
  120cec:	f800283a 	ret

00120cf0 <__sinit_lock_release>:
  120cf0:	f800283a 	ret

00120cf4 <__fp_lock_all>:
  120cf4:	008004f4 	movhi	r2,19
  120cf8:	10a4ea04 	addi	r2,r2,-27736
  120cfc:	11000017 	ldw	r4,0(r2)
  120d00:	014004b4 	movhi	r5,18
  120d04:	29426104 	addi	r5,r5,2436
  120d08:	01217141 	jmpi	121714 <_fwalk>

00120d0c <__fp_unlock_all>:
  120d0c:	008004f4 	movhi	r2,19
  120d10:	10a4ea04 	addi	r2,r2,-27736
  120d14:	11000017 	ldw	r4,0(r2)
  120d18:	014004b4 	movhi	r5,18
  120d1c:	29426304 	addi	r5,r5,2444
  120d20:	01217141 	jmpi	121714 <_fwalk>

00120d24 <_fopen_r>:
  120d24:	defffa04 	addi	sp,sp,-24
  120d28:	dcc00415 	stw	r19,16(sp)
  120d2c:	2827883a 	mov	r19,r5
  120d30:	300b883a 	mov	r5,r6
  120d34:	d80d883a 	mov	r6,sp
  120d38:	dc800315 	stw	r18,12(sp)
  120d3c:	dc400215 	stw	r17,8(sp)
  120d40:	dfc00515 	stw	ra,20(sp)
  120d44:	dc000115 	stw	r16,4(sp)
  120d48:	2025883a 	mov	r18,r4
  120d4c:	01228cc0 	call	1228cc <__sflags>
  120d50:	1023883a 	mov	r17,r2
  120d54:	10002626 	beq	r2,zero,120df0 <_fopen_r+0xcc>
  120d58:	9009883a 	mov	r4,r18
  120d5c:	0120ba40 	call	120ba4 <__sfp>
  120d60:	1021883a 	mov	r16,r2
  120d64:	10002226 	beq	r2,zero,120df0 <_fopen_r+0xcc>
  120d68:	d9800017 	ldw	r6,0(sp)
  120d6c:	9009883a 	mov	r4,r18
  120d70:	980b883a 	mov	r5,r19
  120d74:	01c06d84 	movi	r7,438
  120d78:	01223080 	call	122308 <_open_r>
  120d7c:	10001916 	blt	r2,zero,120de4 <_fopen_r+0xc0>
  120d80:	8080038d 	sth	r2,14(r16)
  120d84:	008004b4 	movhi	r2,18
  120d88:	10899204 	addi	r2,r2,9800
  120d8c:	80800815 	stw	r2,32(r16)
  120d90:	008004b4 	movhi	r2,18
  120d94:	1089a904 	addi	r2,r2,9892
  120d98:	80800915 	stw	r2,36(r16)
  120d9c:	008004b4 	movhi	r2,18
  120da0:	1089c804 	addi	r2,r2,10016
  120da4:	80800a15 	stw	r2,40(r16)
  120da8:	008004b4 	movhi	r2,18
  120dac:	1089df04 	addi	r2,r2,10108
  120db0:	8440030d 	sth	r17,12(r16)
  120db4:	84000715 	stw	r16,28(r16)
  120db8:	80800b15 	stw	r2,44(r16)
  120dbc:	8c40400c 	andi	r17,r17,256
  120dc0:	88000d1e 	bne	r17,zero,120df8 <_fopen_r+0xd4>
  120dc4:	8005883a 	mov	r2,r16
  120dc8:	dfc00517 	ldw	ra,20(sp)
  120dcc:	dcc00417 	ldw	r19,16(sp)
  120dd0:	dc800317 	ldw	r18,12(sp)
  120dd4:	dc400217 	ldw	r17,8(sp)
  120dd8:	dc000117 	ldw	r16,4(sp)
  120ddc:	dec00604 	addi	sp,sp,24
  120de0:	f800283a 	ret
  120de4:	0120ce40 	call	120ce4 <__sfp_lock_acquire>
  120de8:	8000030d 	sth	zero,12(r16)
  120dec:	0120ce80 	call	120ce8 <__sfp_lock_release>
  120df0:	0005883a 	mov	r2,zero
  120df4:	003ff406 	br	120dc8 <__alt_data_end+0xfffed548>
  120df8:	9009883a 	mov	r4,r18
  120dfc:	800b883a 	mov	r5,r16
  120e00:	000d883a 	mov	r6,zero
  120e04:	01c00084 	movi	r7,2
  120e08:	01212440 	call	121244 <_fseek_r>
  120e0c:	8005883a 	mov	r2,r16
  120e10:	003fed06 	br	120dc8 <__alt_data_end+0xfffed548>

00120e14 <fopen>:
  120e14:	00c004f4 	movhi	r3,19
  120e18:	18e4ea04 	addi	r3,r3,-27736
  120e1c:	2005883a 	mov	r2,r4
  120e20:	19000017 	ldw	r4,0(r3)
  120e24:	280d883a 	mov	r6,r5
  120e28:	100b883a 	mov	r5,r2
  120e2c:	0120d241 	jmpi	120d24 <_fopen_r>

00120e30 <_malloc_trim_r>:
  120e30:	defffb04 	addi	sp,sp,-20
  120e34:	dcc00315 	stw	r19,12(sp)
  120e38:	04c004b4 	movhi	r19,18
  120e3c:	dc800215 	stw	r18,8(sp)
  120e40:	dc400115 	stw	r17,4(sp)
  120e44:	dc000015 	stw	r16,0(sp)
  120e48:	dfc00415 	stw	ra,16(sp)
  120e4c:	2821883a 	mov	r16,r5
  120e50:	9cdf1e04 	addi	r19,r19,31864
  120e54:	2025883a 	mov	r18,r4
  120e58:	0123f200 	call	123f20 <__malloc_lock>
  120e5c:	98800217 	ldw	r2,8(r19)
  120e60:	14400117 	ldw	r17,4(r2)
  120e64:	00bfff04 	movi	r2,-4
  120e68:	88a2703a 	and	r17,r17,r2
  120e6c:	8c21c83a 	sub	r16,r17,r16
  120e70:	8403fbc4 	addi	r16,r16,4079
  120e74:	8020d33a 	srli	r16,r16,12
  120e78:	0083ffc4 	movi	r2,4095
  120e7c:	843fffc4 	addi	r16,r16,-1
  120e80:	8020933a 	slli	r16,r16,12
  120e84:	1400060e 	bge	r2,r16,120ea0 <_malloc_trim_r+0x70>
  120e88:	9009883a 	mov	r4,r18
  120e8c:	000b883a 	mov	r5,zero
  120e90:	01225f40 	call	1225f4 <_sbrk_r>
  120e94:	98c00217 	ldw	r3,8(r19)
  120e98:	1c47883a 	add	r3,r3,r17
  120e9c:	10c00a26 	beq	r2,r3,120ec8 <_malloc_trim_r+0x98>
  120ea0:	9009883a 	mov	r4,r18
  120ea4:	0123f400 	call	123f40 <__malloc_unlock>
  120ea8:	0005883a 	mov	r2,zero
  120eac:	dfc00417 	ldw	ra,16(sp)
  120eb0:	dcc00317 	ldw	r19,12(sp)
  120eb4:	dc800217 	ldw	r18,8(sp)
  120eb8:	dc400117 	ldw	r17,4(sp)
  120ebc:	dc000017 	ldw	r16,0(sp)
  120ec0:	dec00504 	addi	sp,sp,20
  120ec4:	f800283a 	ret
  120ec8:	9009883a 	mov	r4,r18
  120ecc:	040bc83a 	sub	r5,zero,r16
  120ed0:	01225f40 	call	1225f4 <_sbrk_r>
  120ed4:	00ffffc4 	movi	r3,-1
  120ed8:	10c00d26 	beq	r2,r3,120f10 <_malloc_trim_r+0xe0>
  120edc:	00c004f4 	movhi	r3,19
  120ee0:	18ebe804 	addi	r3,r3,-20576
  120ee4:	18800017 	ldw	r2,0(r3)
  120ee8:	99000217 	ldw	r4,8(r19)
  120eec:	8c23c83a 	sub	r17,r17,r16
  120ef0:	8c400054 	ori	r17,r17,1
  120ef4:	1421c83a 	sub	r16,r2,r16
  120ef8:	24400115 	stw	r17,4(r4)
  120efc:	9009883a 	mov	r4,r18
  120f00:	1c000015 	stw	r16,0(r3)
  120f04:	0123f400 	call	123f40 <__malloc_unlock>
  120f08:	00800044 	movi	r2,1
  120f0c:	003fe706 	br	120eac <__alt_data_end+0xfffed62c>
  120f10:	9009883a 	mov	r4,r18
  120f14:	000b883a 	mov	r5,zero
  120f18:	01225f40 	call	1225f4 <_sbrk_r>
  120f1c:	99000217 	ldw	r4,8(r19)
  120f20:	014003c4 	movi	r5,15
  120f24:	1107c83a 	sub	r3,r2,r4
  120f28:	28ffdd0e 	bge	r5,r3,120ea0 <__alt_data_end+0xfffed620>
  120f2c:	014004f4 	movhi	r5,19
  120f30:	2964eb04 	addi	r5,r5,-27732
  120f34:	29400017 	ldw	r5,0(r5)
  120f38:	18c00054 	ori	r3,r3,1
  120f3c:	20c00115 	stw	r3,4(r4)
  120f40:	00c004f4 	movhi	r3,19
  120f44:	1145c83a 	sub	r2,r2,r5
  120f48:	18ebe804 	addi	r3,r3,-20576
  120f4c:	18800015 	stw	r2,0(r3)
  120f50:	003fd306 	br	120ea0 <__alt_data_end+0xfffed620>

00120f54 <_free_r>:
  120f54:	28004c26 	beq	r5,zero,121088 <_free_r+0x134>
  120f58:	defffd04 	addi	sp,sp,-12
  120f5c:	dc400115 	stw	r17,4(sp)
  120f60:	dc000015 	stw	r16,0(sp)
  120f64:	2023883a 	mov	r17,r4
  120f68:	2821883a 	mov	r16,r5
  120f6c:	dfc00215 	stw	ra,8(sp)
  120f70:	0123f200 	call	123f20 <__malloc_lock>
  120f74:	813fff17 	ldw	r4,-4(r16)
  120f78:	00bfff84 	movi	r2,-2
  120f7c:	024004b4 	movhi	r9,18
  120f80:	81bffe04 	addi	r6,r16,-8
  120f84:	2084703a 	and	r2,r4,r2
  120f88:	4a5f1e04 	addi	r9,r9,31864
  120f8c:	308b883a 	add	r5,r6,r2
  120f90:	2a000117 	ldw	r8,4(r5)
  120f94:	49c00217 	ldw	r7,8(r9)
  120f98:	00ffff04 	movi	r3,-4
  120f9c:	40c6703a 	and	r3,r8,r3
  120fa0:	39405326 	beq	r7,r5,1210f0 <_free_r+0x19c>
  120fa4:	28c00115 	stw	r3,4(r5)
  120fa8:	2100004c 	andi	r4,r4,1
  120fac:	2000091e 	bne	r4,zero,120fd4 <_free_r+0x80>
  120fb0:	81fffe17 	ldw	r7,-8(r16)
  120fb4:	4a000204 	addi	r8,r9,8
  120fb8:	31cdc83a 	sub	r6,r6,r7
  120fbc:	31000217 	ldw	r4,8(r6)
  120fc0:	11c5883a 	add	r2,r2,r7
  120fc4:	22006126 	beq	r4,r8,12114c <_free_r+0x1f8>
  120fc8:	31c00317 	ldw	r7,12(r6)
  120fcc:	21c00315 	stw	r7,12(r4)
  120fd0:	39000215 	stw	r4,8(r7)
  120fd4:	28c9883a 	add	r4,r5,r3
  120fd8:	21c00117 	ldw	r7,4(r4)
  120fdc:	39c0004c 	andi	r7,r7,1
  120fe0:	38000d1e 	bne	r7,zero,121018 <_free_r+0xc4>
  120fe4:	29000217 	ldw	r4,8(r5)
  120fe8:	10c5883a 	add	r2,r2,r3
  120fec:	00c004b4 	movhi	r3,18
  120ff0:	18df2004 	addi	r3,r3,31872
  120ff4:	20c07526 	beq	r4,r3,1211cc <_free_r+0x278>
  120ff8:	29c00317 	ldw	r7,12(r5)
  120ffc:	11400054 	ori	r5,r2,1
  121000:	3087883a 	add	r3,r6,r2
  121004:	21c00315 	stw	r7,12(r4)
  121008:	39000215 	stw	r4,8(r7)
  12100c:	31400115 	stw	r5,4(r6)
  121010:	18800015 	stw	r2,0(r3)
  121014:	00000406 	br	121028 <_free_r+0xd4>
  121018:	10c00054 	ori	r3,r2,1
  12101c:	30c00115 	stw	r3,4(r6)
  121020:	3087883a 	add	r3,r6,r2
  121024:	18800015 	stw	r2,0(r3)
  121028:	00c07fc4 	movi	r3,511
  12102c:	18801736 	bltu	r3,r2,12108c <_free_r+0x138>
  121030:	1004d0fa 	srli	r2,r2,3
  121034:	01400044 	movi	r5,1
  121038:	49000117 	ldw	r4,4(r9)
  12103c:	1087883a 	add	r3,r2,r2
  121040:	18c7883a 	add	r3,r3,r3
  121044:	1005d0ba 	srai	r2,r2,2
  121048:	18c7883a 	add	r3,r3,r3
  12104c:	1a47883a 	add	r3,r3,r9
  121050:	19c00217 	ldw	r7,8(r3)
  121054:	2884983a 	sll	r2,r5,r2
  121058:	30c00315 	stw	r3,12(r6)
  12105c:	31c00215 	stw	r7,8(r6)
  121060:	1104b03a 	or	r2,r2,r4
  121064:	19800215 	stw	r6,8(r3)
  121068:	48800115 	stw	r2,4(r9)
  12106c:	39800315 	stw	r6,12(r7)
  121070:	8809883a 	mov	r4,r17
  121074:	dfc00217 	ldw	ra,8(sp)
  121078:	dc400117 	ldw	r17,4(sp)
  12107c:	dc000017 	ldw	r16,0(sp)
  121080:	dec00304 	addi	sp,sp,12
  121084:	0123f401 	jmpi	123f40 <__malloc_unlock>
  121088:	f800283a 	ret
  12108c:	1006d27a 	srli	r3,r2,9
  121090:	01000104 	movi	r4,4
  121094:	20c04036 	bltu	r4,r3,121198 <_free_r+0x244>
  121098:	1006d1ba 	srli	r3,r2,6
  12109c:	19400e04 	addi	r5,r3,56
  1210a0:	2947883a 	add	r3,r5,r5
  1210a4:	18c7883a 	add	r3,r3,r3
  1210a8:	18c7883a 	add	r3,r3,r3
  1210ac:	1a49883a 	add	r4,r3,r9
  1210b0:	20c00217 	ldw	r3,8(r4)
  1210b4:	01c004b4 	movhi	r7,18
  1210b8:	39df1e04 	addi	r7,r7,31864
  1210bc:	19003b26 	beq	r3,r4,1211ac <_free_r+0x258>
  1210c0:	01ffff04 	movi	r7,-4
  1210c4:	19400117 	ldw	r5,4(r3)
  1210c8:	29ca703a 	and	r5,r5,r7
  1210cc:	1140022e 	bgeu	r2,r5,1210d8 <_free_r+0x184>
  1210d0:	18c00217 	ldw	r3,8(r3)
  1210d4:	20fffb1e 	bne	r4,r3,1210c4 <__alt_data_end+0xfffed844>
  1210d8:	18800317 	ldw	r2,12(r3)
  1210dc:	30800315 	stw	r2,12(r6)
  1210e0:	30c00215 	stw	r3,8(r6)
  1210e4:	11800215 	stw	r6,8(r2)
  1210e8:	19800315 	stw	r6,12(r3)
  1210ec:	003fe006 	br	121070 <__alt_data_end+0xfffed7f0>
  1210f0:	2100004c 	andi	r4,r4,1
  1210f4:	1885883a 	add	r2,r3,r2
  1210f8:	2000071e 	bne	r4,zero,121118 <_free_r+0x1c4>
  1210fc:	817ffe17 	ldw	r5,-8(r16)
  121100:	314dc83a 	sub	r6,r6,r5
  121104:	30c00317 	ldw	r3,12(r6)
  121108:	31000217 	ldw	r4,8(r6)
  12110c:	1145883a 	add	r2,r2,r5
  121110:	20c00315 	stw	r3,12(r4)
  121114:	19000215 	stw	r4,8(r3)
  121118:	10c00054 	ori	r3,r2,1
  12111c:	30c00115 	stw	r3,4(r6)
  121120:	00c004f4 	movhi	r3,19
  121124:	18e4ec04 	addi	r3,r3,-27728
  121128:	18c00017 	ldw	r3,0(r3)
  12112c:	49800215 	stw	r6,8(r9)
  121130:	10ffcf36 	bltu	r2,r3,121070 <__alt_data_end+0xfffed7f0>
  121134:	008004f4 	movhi	r2,19
  121138:	10abe004 	addi	r2,r2,-20608
  12113c:	11400017 	ldw	r5,0(r2)
  121140:	8809883a 	mov	r4,r17
  121144:	0120e300 	call	120e30 <_malloc_trim_r>
  121148:	003fc906 	br	121070 <__alt_data_end+0xfffed7f0>
  12114c:	28c9883a 	add	r4,r5,r3
  121150:	21000117 	ldw	r4,4(r4)
  121154:	2100004c 	andi	r4,r4,1
  121158:	20000a1e 	bne	r4,zero,121184 <_free_r+0x230>
  12115c:	29000317 	ldw	r4,12(r5)
  121160:	29400217 	ldw	r5,8(r5)
  121164:	10c5883a 	add	r2,r2,r3
  121168:	10c00054 	ori	r3,r2,1
  12116c:	29000315 	stw	r4,12(r5)
  121170:	21400215 	stw	r5,8(r4)
  121174:	30c00115 	stw	r3,4(r6)
  121178:	308d883a 	add	r6,r6,r2
  12117c:	30800015 	stw	r2,0(r6)
  121180:	003fbb06 	br	121070 <__alt_data_end+0xfffed7f0>
  121184:	10c00054 	ori	r3,r2,1
  121188:	30c00115 	stw	r3,4(r6)
  12118c:	308d883a 	add	r6,r6,r2
  121190:	30800015 	stw	r2,0(r6)
  121194:	003fb606 	br	121070 <__alt_data_end+0xfffed7f0>
  121198:	01000504 	movi	r4,20
  12119c:	20c01436 	bltu	r4,r3,1211f0 <_free_r+0x29c>
  1211a0:	194016c4 	addi	r5,r3,91
  1211a4:	2947883a 	add	r3,r5,r5
  1211a8:	003fbe06 	br	1210a4 <__alt_data_end+0xfffed824>
  1211ac:	280bd0ba 	srai	r5,r5,2
  1211b0:	00800044 	movi	r2,1
  1211b4:	39000117 	ldw	r4,4(r7)
  1211b8:	114a983a 	sll	r5,r2,r5
  1211bc:	1805883a 	mov	r2,r3
  1211c0:	2908b03a 	or	r4,r5,r4
  1211c4:	39000115 	stw	r4,4(r7)
  1211c8:	003fc406 	br	1210dc <__alt_data_end+0xfffed85c>
  1211cc:	49800515 	stw	r6,20(r9)
  1211d0:	49800415 	stw	r6,16(r9)
  1211d4:	10c00054 	ori	r3,r2,1
  1211d8:	31000315 	stw	r4,12(r6)
  1211dc:	31000215 	stw	r4,8(r6)
  1211e0:	30c00115 	stw	r3,4(r6)
  1211e4:	308d883a 	add	r6,r6,r2
  1211e8:	30800015 	stw	r2,0(r6)
  1211ec:	003fa006 	br	121070 <__alt_data_end+0xfffed7f0>
  1211f0:	01001504 	movi	r4,84
  1211f4:	20c00436 	bltu	r4,r3,121208 <_free_r+0x2b4>
  1211f8:	1006d33a 	srli	r3,r2,12
  1211fc:	19401b84 	addi	r5,r3,110
  121200:	2947883a 	add	r3,r5,r5
  121204:	003fa706 	br	1210a4 <__alt_data_end+0xfffed824>
  121208:	01005504 	movi	r4,340
  12120c:	20c00436 	bltu	r4,r3,121220 <_free_r+0x2cc>
  121210:	1006d3fa 	srli	r3,r2,15
  121214:	19401dc4 	addi	r5,r3,119
  121218:	2947883a 	add	r3,r5,r5
  12121c:	003fa106 	br	1210a4 <__alt_data_end+0xfffed824>
  121220:	01015504 	movi	r4,1364
  121224:	20c00436 	bltu	r4,r3,121238 <_free_r+0x2e4>
  121228:	1006d4ba 	srli	r3,r2,18
  12122c:	19401f04 	addi	r5,r3,124
  121230:	2947883a 	add	r3,r5,r5
  121234:	003f9b06 	br	1210a4 <__alt_data_end+0xfffed824>
  121238:	00c03f04 	movi	r3,252
  12123c:	01401f84 	movi	r5,126
  121240:	003f9806 	br	1210a4 <__alt_data_end+0xfffed824>

00121244 <_fseek_r>:
  121244:	deffe804 	addi	sp,sp,-96
  121248:	dd401415 	stw	r21,80(sp)
  12124c:	dc801115 	stw	r18,68(sp)
  121250:	dc401015 	stw	r17,64(sp)
  121254:	dc000f15 	stw	r16,60(sp)
  121258:	dfc01715 	stw	ra,92(sp)
  12125c:	ddc01615 	stw	r23,88(sp)
  121260:	dd801515 	stw	r22,84(sp)
  121264:	dd001315 	stw	r20,76(sp)
  121268:	dcc01215 	stw	r19,72(sp)
  12126c:	2023883a 	mov	r17,r4
  121270:	2821883a 	mov	r16,r5
  121274:	302b883a 	mov	r21,r6
  121278:	3825883a 	mov	r18,r7
  12127c:	20000226 	beq	r4,zero,121288 <_fseek_r+0x44>
  121280:	20800e17 	ldw	r2,56(r4)
  121284:	10005d26 	beq	r2,zero,1213fc <_fseek_r+0x1b8>
  121288:	0120ce40 	call	120ce4 <__sfp_lock_acquire>
  12128c:	8080030b 	ldhu	r2,12(r16)
  121290:	00c04204 	movi	r3,264
  121294:	1080420c 	andi	r2,r2,264
  121298:	10c0a026 	beq	r2,r3,12151c <_fseek_r+0x2d8>
  12129c:	85000a17 	ldw	r20,40(r16)
  1212a0:	a000f826 	beq	r20,zero,121684 <_fseek_r+0x440>
  1212a4:	00800044 	movi	r2,1
  1212a8:	90804026 	beq	r18,r2,1213ac <_fseek_r+0x168>
  1212ac:	00800084 	movi	r2,2
  1212b0:	90801126 	beq	r18,r2,1212f8 <_fseek_r+0xb4>
  1212b4:	90001026 	beq	r18,zero,1212f8 <_fseek_r+0xb4>
  1212b8:	00800584 	movi	r2,22
  1212bc:	88800015 	stw	r2,0(r17)
  1212c0:	0120ce80 	call	120ce8 <__sfp_lock_release>
  1212c4:	04ffffc4 	movi	r19,-1
  1212c8:	9805883a 	mov	r2,r19
  1212cc:	dfc01717 	ldw	ra,92(sp)
  1212d0:	ddc01617 	ldw	r23,88(sp)
  1212d4:	dd801517 	ldw	r22,84(sp)
  1212d8:	dd401417 	ldw	r21,80(sp)
  1212dc:	dd001317 	ldw	r20,76(sp)
  1212e0:	dcc01217 	ldw	r19,72(sp)
  1212e4:	dc801117 	ldw	r18,68(sp)
  1212e8:	dc401017 	ldw	r17,64(sp)
  1212ec:	dc000f17 	ldw	r16,60(sp)
  1212f0:	dec01804 	addi	sp,sp,96
  1212f4:	f800283a 	ret
  1212f8:	80800417 	ldw	r2,16(r16)
  1212fc:	002f883a 	mov	r23,zero
  121300:	0027883a 	mov	r19,zero
  121304:	1000c026 	beq	r2,zero,121608 <_fseek_r+0x3c4>
  121308:	8080030b 	ldhu	r2,12(r16)
  12130c:	10c2068c 	andi	r3,r2,2074
  121310:	1800071e 	bne	r3,zero,121330 <_fseek_r+0xec>
  121314:	10c1000c 	andi	r3,r2,1024
  121318:	18003f1e 	bne	r3,zero,121418 <_fseek_r+0x1d4>
  12131c:	00c004b4 	movhi	r3,18
  121320:	18c9c804 	addi	r3,r3,10016
  121324:	a0c0bc26 	beq	r20,r3,121618 <_fseek_r+0x3d4>
  121328:	10820014 	ori	r2,r2,2048
  12132c:	8080030d 	sth	r2,12(r16)
  121330:	8809883a 	mov	r4,r17
  121334:	800b883a 	mov	r5,r16
  121338:	012072c0 	call	12072c <_fflush_r>
  12133c:	1027883a 	mov	r19,r2
  121340:	103fdf1e 	bne	r2,zero,1212c0 <__alt_data_end+0xfffeda40>
  121344:	81400717 	ldw	r5,28(r16)
  121348:	8809883a 	mov	r4,r17
  12134c:	a80d883a 	mov	r6,r21
  121350:	900f883a 	mov	r7,r18
  121354:	a03ee83a 	callr	r20
  121358:	00ffffc4 	movi	r3,-1
  12135c:	10ffd826 	beq	r2,r3,1212c0 <__alt_data_end+0xfffeda40>
  121360:	81400c17 	ldw	r5,48(r16)
  121364:	28000526 	beq	r5,zero,12137c <_fseek_r+0x138>
  121368:	80801004 	addi	r2,r16,64
  12136c:	28800226 	beq	r5,r2,121378 <_fseek_r+0x134>
  121370:	8809883a 	mov	r4,r17
  121374:	0120f540 	call	120f54 <_free_r>
  121378:	80000c15 	stw	zero,48(r16)
  12137c:	8080030b 	ldhu	r2,12(r16)
  121380:	80c00417 	ldw	r3,16(r16)
  121384:	81001704 	addi	r4,r16,92
  121388:	10bdf7cc 	andi	r2,r2,63455
  12138c:	000b883a 	mov	r5,zero
  121390:	01800204 	movi	r6,8
  121394:	80c00015 	stw	r3,0(r16)
  121398:	80000115 	stw	zero,4(r16)
  12139c:	8080030d 	sth	r2,12(r16)
  1213a0:	01221e40 	call	1221e4 <memset>
  1213a4:	0120ce80 	call	120ce8 <__sfp_lock_release>
  1213a8:	003fc706 	br	1212c8 <__alt_data_end+0xfffeda48>
  1213ac:	8809883a 	mov	r4,r17
  1213b0:	800b883a 	mov	r5,r16
  1213b4:	012072c0 	call	12072c <_fflush_r>
  1213b8:	8080030b 	ldhu	r2,12(r16)
  1213bc:	10c4000c 	andi	r3,r2,4096
  1213c0:	18008726 	beq	r3,zero,1215e0 <_fseek_r+0x39c>
  1213c4:	84c01417 	ldw	r19,80(r16)
  1213c8:	10c0010c 	andi	r3,r2,4
  1213cc:	18003e1e 	bne	r3,zero,1214c8 <_fseek_r+0x284>
  1213d0:	1080020c 	andi	r2,r2,8
  1213d4:	10008026 	beq	r2,zero,1215d8 <_fseek_r+0x394>
  1213d8:	80c00017 	ldw	r3,0(r16)
  1213dc:	80800417 	ldw	r2,16(r16)
  1213e0:	18000226 	beq	r3,zero,1213ec <_fseek_r+0x1a8>
  1213e4:	1887c83a 	sub	r3,r3,r2
  1213e8:	98e7883a 	add	r19,r19,r3
  1213ec:	aceb883a 	add	r21,r21,r19
  1213f0:	05c00044 	movi	r23,1
  1213f4:	0025883a 	mov	r18,zero
  1213f8:	003fc206 	br	121304 <__alt_data_end+0xfffeda84>
  1213fc:	0120cd40 	call	120cd4 <__sinit>
  121400:	003fa106 	br	121288 <__alt_data_end+0xfffeda08>
  121404:	8080030b 	ldhu	r2,12(r16)
  121408:	00c10004 	movi	r3,1024
  12140c:	80c01315 	stw	r3,76(r16)
  121410:	10c4b03a 	or	r2,r2,r3
  121414:	8080030d 	sth	r2,12(r16)
  121418:	9000331e 	bne	r18,zero,1214e8 <_fseek_r+0x2a4>
  12141c:	a82d883a 	mov	r22,r21
  121420:	b800391e 	bne	r23,zero,121508 <_fseek_r+0x2c4>
  121424:	8080030b 	ldhu	r2,12(r16)
  121428:	1084000c 	andi	r2,r2,4096
  12142c:	10008626 	beq	r2,zero,121648 <_fseek_r+0x404>
  121430:	80801417 	ldw	r2,80(r16)
  121434:	81800117 	ldw	r6,4(r16)
  121438:	81400c17 	ldw	r5,48(r16)
  12143c:	11a7c83a 	sub	r19,r2,r6
  121440:	28008926 	beq	r5,zero,121668 <_fseek_r+0x424>
  121444:	80800f17 	ldw	r2,60(r16)
  121448:	98a7c83a 	sub	r19,r19,r2
  12144c:	81000e17 	ldw	r4,56(r16)
  121450:	80c00417 	ldw	r3,16(r16)
  121454:	99a7883a 	add	r19,r19,r6
  121458:	20c7c83a 	sub	r3,r4,r3
  12145c:	98e7c83a 	sub	r19,r19,r3
  121460:	10c7883a 	add	r3,r2,r3
  121464:	b4c03116 	blt	r22,r19,12152c <_fseek_r+0x2e8>
  121468:	98c5883a 	add	r2,r19,r3
  12146c:	b0802f2e 	bgeu	r22,r2,12152c <_fseek_r+0x2e8>
  121470:	80800417 	ldw	r2,16(r16)
  121474:	b4e7c83a 	sub	r19,r22,r19
  121478:	1cc7c83a 	sub	r3,r3,r19
  12147c:	14e7883a 	add	r19,r2,r19
  121480:	84c00015 	stw	r19,0(r16)
  121484:	80c00115 	stw	r3,4(r16)
  121488:	28000526 	beq	r5,zero,1214a0 <_fseek_r+0x25c>
  12148c:	80801004 	addi	r2,r16,64
  121490:	28800226 	beq	r5,r2,12149c <_fseek_r+0x258>
  121494:	8809883a 	mov	r4,r17
  121498:	0120f540 	call	120f54 <_free_r>
  12149c:	80000c15 	stw	zero,48(r16)
  1214a0:	8080030b 	ldhu	r2,12(r16)
  1214a4:	81001704 	addi	r4,r16,92
  1214a8:	000b883a 	mov	r5,zero
  1214ac:	10bff7cc 	andi	r2,r2,65503
  1214b0:	01800204 	movi	r6,8
  1214b4:	8080030d 	sth	r2,12(r16)
  1214b8:	01221e40 	call	1221e4 <memset>
  1214bc:	0120ce80 	call	120ce8 <__sfp_lock_release>
  1214c0:	0027883a 	mov	r19,zero
  1214c4:	003f8006 	br	1212c8 <__alt_data_end+0xfffeda48>
  1214c8:	80c00117 	ldw	r3,4(r16)
  1214cc:	80800c17 	ldw	r2,48(r16)
  1214d0:	98e7c83a 	sub	r19,r19,r3
  1214d4:	10004026 	beq	r2,zero,1215d8 <_fseek_r+0x394>
  1214d8:	80c00f17 	ldw	r3,60(r16)
  1214dc:	80800417 	ldw	r2,16(r16)
  1214e0:	98e7c83a 	sub	r19,r19,r3
  1214e4:	003fc106 	br	1213ec <__alt_data_end+0xfffedb6c>
  1214e8:	8140038f 	ldh	r5,14(r16)
  1214ec:	8809883a 	mov	r4,r17
  1214f0:	d80d883a 	mov	r6,sp
  1214f4:	01216bc0 	call	1216bc <_fstat_r>
  1214f8:	103f8d1e 	bne	r2,zero,121330 <__alt_data_end+0xfffedab0>
  1214fc:	dd800417 	ldw	r22,16(sp)
  121500:	adad883a 	add	r22,r21,r22
  121504:	b83fc726 	beq	r23,zero,121424 <__alt_data_end+0xfffedba4>
  121508:	81400c17 	ldw	r5,48(r16)
  12150c:	81800117 	ldw	r6,4(r16)
  121510:	28005526 	beq	r5,zero,121668 <_fseek_r+0x424>
  121514:	80800f17 	ldw	r2,60(r16)
  121518:	003fcc06 	br	12144c <__alt_data_end+0xfffedbcc>
  12151c:	8809883a 	mov	r4,r17
  121520:	800b883a 	mov	r5,r16
  121524:	012072c0 	call	12072c <_fflush_r>
  121528:	003f5c06 	br	12129c <__alt_data_end+0xfffeda1c>
  12152c:	84c01317 	ldw	r19,76(r16)
  121530:	81400717 	ldw	r5,28(r16)
  121534:	8809883a 	mov	r4,r17
  121538:	04e7c83a 	sub	r19,zero,r19
  12153c:	b4e6703a 	and	r19,r22,r19
  121540:	980d883a 	mov	r6,r19
  121544:	000f883a 	mov	r7,zero
  121548:	a03ee83a 	callr	r20
  12154c:	00ffffc4 	movi	r3,-1
  121550:	10ff7726 	beq	r2,r3,121330 <__alt_data_end+0xfffedab0>
  121554:	80800417 	ldw	r2,16(r16)
  121558:	81400c17 	ldw	r5,48(r16)
  12155c:	80000115 	stw	zero,4(r16)
  121560:	80800015 	stw	r2,0(r16)
  121564:	28000526 	beq	r5,zero,12157c <_fseek_r+0x338>
  121568:	80801004 	addi	r2,r16,64
  12156c:	28800226 	beq	r5,r2,121578 <_fseek_r+0x334>
  121570:	8809883a 	mov	r4,r17
  121574:	0120f540 	call	120f54 <_free_r>
  121578:	80000c15 	stw	zero,48(r16)
  12157c:	8080030b 	ldhu	r2,12(r16)
  121580:	b4e7c83a 	sub	r19,r22,r19
  121584:	10bff7cc 	andi	r2,r2,65503
  121588:	8080030d 	sth	r2,12(r16)
  12158c:	98000b26 	beq	r19,zero,1215bc <_fseek_r+0x378>
  121590:	8809883a 	mov	r4,r17
  121594:	800b883a 	mov	r5,r16
  121598:	012244c0 	call	12244c <__srefill_r>
  12159c:	103f641e 	bne	r2,zero,121330 <__alt_data_end+0xfffedab0>
  1215a0:	80800117 	ldw	r2,4(r16)
  1215a4:	14ff6236 	bltu	r2,r19,121330 <__alt_data_end+0xfffedab0>
  1215a8:	80c00017 	ldw	r3,0(r16)
  1215ac:	14c5c83a 	sub	r2,r2,r19
  1215b0:	80800115 	stw	r2,4(r16)
  1215b4:	1ce7883a 	add	r19,r3,r19
  1215b8:	84c00015 	stw	r19,0(r16)
  1215bc:	81001704 	addi	r4,r16,92
  1215c0:	000b883a 	mov	r5,zero
  1215c4:	01800204 	movi	r6,8
  1215c8:	01221e40 	call	1221e4 <memset>
  1215cc:	0120ce80 	call	120ce8 <__sfp_lock_release>
  1215d0:	0027883a 	mov	r19,zero
  1215d4:	003f3c06 	br	1212c8 <__alt_data_end+0xfffeda48>
  1215d8:	80800417 	ldw	r2,16(r16)
  1215dc:	003f8306 	br	1213ec <__alt_data_end+0xfffedb6c>
  1215e0:	81400717 	ldw	r5,28(r16)
  1215e4:	8809883a 	mov	r4,r17
  1215e8:	000d883a 	mov	r6,zero
  1215ec:	900f883a 	mov	r7,r18
  1215f0:	a03ee83a 	callr	r20
  1215f4:	1027883a 	mov	r19,r2
  1215f8:	00bfffc4 	movi	r2,-1
  1215fc:	98bf3026 	beq	r19,r2,1212c0 <__alt_data_end+0xfffeda40>
  121600:	8080030b 	ldhu	r2,12(r16)
  121604:	003f7006 	br	1213c8 <__alt_data_end+0xfffedb48>
  121608:	8809883a 	mov	r4,r17
  12160c:	800b883a 	mov	r5,r16
  121610:	01218840 	call	121884 <__smakebuf_r>
  121614:	003f3c06 	br	121308 <__alt_data_end+0xfffeda88>
  121618:	8140038f 	ldh	r5,14(r16)
  12161c:	283f4216 	blt	r5,zero,121328 <__alt_data_end+0xfffedaa8>
  121620:	8809883a 	mov	r4,r17
  121624:	d80d883a 	mov	r6,sp
  121628:	01216bc0 	call	1216bc <_fstat_r>
  12162c:	1000041e 	bne	r2,zero,121640 <_fseek_r+0x3fc>
  121630:	d8800117 	ldw	r2,4(sp)
  121634:	00e00014 	movui	r3,32768
  121638:	10bc000c 	andi	r2,r2,61440
  12163c:	10ff7126 	beq	r2,r3,121404 <__alt_data_end+0xfffedb84>
  121640:	8080030b 	ldhu	r2,12(r16)
  121644:	003f3806 	br	121328 <__alt_data_end+0xfffedaa8>
  121648:	81400717 	ldw	r5,28(r16)
  12164c:	8809883a 	mov	r4,r17
  121650:	000d883a 	mov	r6,zero
  121654:	01c00044 	movi	r7,1
  121658:	a03ee83a 	callr	r20
  12165c:	00ffffc4 	movi	r3,-1
  121660:	10ff741e 	bne	r2,r3,121434 <__alt_data_end+0xfffedbb4>
  121664:	003f3206 	br	121330 <__alt_data_end+0xfffedab0>
  121668:	81000017 	ldw	r4,0(r16)
  12166c:	80c00417 	ldw	r3,16(r16)
  121670:	000b883a 	mov	r5,zero
  121674:	20c7c83a 	sub	r3,r4,r3
  121678:	98e7c83a 	sub	r19,r19,r3
  12167c:	30c7883a 	add	r3,r6,r3
  121680:	003f7806 	br	121464 <__alt_data_end+0xfffedbe4>
  121684:	00800744 	movi	r2,29
  121688:	88800015 	stw	r2,0(r17)
  12168c:	0120ce80 	call	120ce8 <__sfp_lock_release>
  121690:	04ffffc4 	movi	r19,-1
  121694:	003f0c06 	br	1212c8 <__alt_data_end+0xfffeda48>

00121698 <fseek>:
  121698:	2007883a 	mov	r3,r4
  12169c:	010004f4 	movhi	r4,19
  1216a0:	2124ea04 	addi	r4,r4,-27736
  1216a4:	21000017 	ldw	r4,0(r4)
  1216a8:	2805883a 	mov	r2,r5
  1216ac:	300f883a 	mov	r7,r6
  1216b0:	180b883a 	mov	r5,r3
  1216b4:	100d883a 	mov	r6,r2
  1216b8:	01212441 	jmpi	121244 <_fseek_r>

001216bc <_fstat_r>:
  1216bc:	defffd04 	addi	sp,sp,-12
  1216c0:	dc000015 	stw	r16,0(sp)
  1216c4:	040004f4 	movhi	r16,19
  1216c8:	dc400115 	stw	r17,4(sp)
  1216cc:	842bdd04 	addi	r16,r16,-20620
  1216d0:	2023883a 	mov	r17,r4
  1216d4:	2809883a 	mov	r4,r5
  1216d8:	300b883a 	mov	r5,r6
  1216dc:	dfc00215 	stw	ra,8(sp)
  1216e0:	80000015 	stw	zero,0(r16)
  1216e4:	0123afc0 	call	123afc <fstat>
  1216e8:	00ffffc4 	movi	r3,-1
  1216ec:	10c00526 	beq	r2,r3,121704 <_fstat_r+0x48>
  1216f0:	dfc00217 	ldw	ra,8(sp)
  1216f4:	dc400117 	ldw	r17,4(sp)
  1216f8:	dc000017 	ldw	r16,0(sp)
  1216fc:	dec00304 	addi	sp,sp,12
  121700:	f800283a 	ret
  121704:	80c00017 	ldw	r3,0(r16)
  121708:	183ff926 	beq	r3,zero,1216f0 <__alt_data_end+0xfffede70>
  12170c:	88c00015 	stw	r3,0(r17)
  121710:	003ff706 	br	1216f0 <__alt_data_end+0xfffede70>

00121714 <_fwalk>:
  121714:	defff804 	addi	sp,sp,-32
  121718:	dd400515 	stw	r21,20(sp)
  12171c:	2540b804 	addi	r21,r4,736
  121720:	dd800615 	stw	r22,24(sp)
  121724:	dd000415 	stw	r20,16(sp)
  121728:	dfc00715 	stw	ra,28(sp)
  12172c:	dcc00315 	stw	r19,12(sp)
  121730:	dc800215 	stw	r18,8(sp)
  121734:	dc400115 	stw	r17,4(sp)
  121738:	dc000015 	stw	r16,0(sp)
  12173c:	2829883a 	mov	r20,r5
  121740:	002d883a 	mov	r22,zero
  121744:	0120ce40 	call	120ce4 <__sfp_lock_acquire>
  121748:	a8001426 	beq	r21,zero,12179c <_fwalk+0x88>
  12174c:	04ffffc4 	movi	r19,-1
  121750:	ac400117 	ldw	r17,4(r21)
  121754:	ac800217 	ldw	r18,8(r21)
  121758:	8c7fffc4 	addi	r17,r17,-1
  12175c:	88000d16 	blt	r17,zero,121794 <_fwalk+0x80>
  121760:	94000304 	addi	r16,r18,12
  121764:	94800384 	addi	r18,r18,14
  121768:	80c0000f 	ldh	r3,0(r16)
  12176c:	8c7fffc4 	addi	r17,r17,-1
  121770:	813ffd04 	addi	r4,r16,-12
  121774:	18000426 	beq	r3,zero,121788 <_fwalk+0x74>
  121778:	90c0000f 	ldh	r3,0(r18)
  12177c:	1cc00226 	beq	r3,r19,121788 <_fwalk+0x74>
  121780:	a03ee83a 	callr	r20
  121784:	b0acb03a 	or	r22,r22,r2
  121788:	84001a04 	addi	r16,r16,104
  12178c:	94801a04 	addi	r18,r18,104
  121790:	8cfff51e 	bne	r17,r19,121768 <__alt_data_end+0xfffedee8>
  121794:	ad400017 	ldw	r21,0(r21)
  121798:	a83fed1e 	bne	r21,zero,121750 <__alt_data_end+0xfffeded0>
  12179c:	0120ce80 	call	120ce8 <__sfp_lock_release>
  1217a0:	b005883a 	mov	r2,r22
  1217a4:	dfc00717 	ldw	ra,28(sp)
  1217a8:	dd800617 	ldw	r22,24(sp)
  1217ac:	dd400517 	ldw	r21,20(sp)
  1217b0:	dd000417 	ldw	r20,16(sp)
  1217b4:	dcc00317 	ldw	r19,12(sp)
  1217b8:	dc800217 	ldw	r18,8(sp)
  1217bc:	dc400117 	ldw	r17,4(sp)
  1217c0:	dc000017 	ldw	r16,0(sp)
  1217c4:	dec00804 	addi	sp,sp,32
  1217c8:	f800283a 	ret

001217cc <_fwalk_reent>:
  1217cc:	defff804 	addi	sp,sp,-32
  1217d0:	dd400515 	stw	r21,20(sp)
  1217d4:	2540b804 	addi	r21,r4,736
  1217d8:	dd800615 	stw	r22,24(sp)
  1217dc:	dd000415 	stw	r20,16(sp)
  1217e0:	dcc00315 	stw	r19,12(sp)
  1217e4:	dfc00715 	stw	ra,28(sp)
  1217e8:	dc800215 	stw	r18,8(sp)
  1217ec:	dc400115 	stw	r17,4(sp)
  1217f0:	dc000015 	stw	r16,0(sp)
  1217f4:	2027883a 	mov	r19,r4
  1217f8:	2829883a 	mov	r20,r5
  1217fc:	002d883a 	mov	r22,zero
  121800:	0120ce40 	call	120ce4 <__sfp_lock_acquire>
  121804:	a8001326 	beq	r21,zero,121854 <_fwalk_reent+0x88>
  121808:	04bfffc4 	movi	r18,-1
  12180c:	ac400117 	ldw	r17,4(r21)
  121810:	ac000217 	ldw	r16,8(r21)
  121814:	8c7fffc4 	addi	r17,r17,-1
  121818:	88000c16 	blt	r17,zero,12184c <_fwalk_reent+0x80>
  12181c:	84000304 	addi	r16,r16,12
  121820:	80c0000f 	ldh	r3,0(r16)
  121824:	8c7fffc4 	addi	r17,r17,-1
  121828:	817ffd04 	addi	r5,r16,-12
  12182c:	18000526 	beq	r3,zero,121844 <_fwalk_reent+0x78>
  121830:	80c0008f 	ldh	r3,2(r16)
  121834:	9809883a 	mov	r4,r19
  121838:	1c800226 	beq	r3,r18,121844 <_fwalk_reent+0x78>
  12183c:	a03ee83a 	callr	r20
  121840:	b0acb03a 	or	r22,r22,r2
  121844:	84001a04 	addi	r16,r16,104
  121848:	8cbff51e 	bne	r17,r18,121820 <__alt_data_end+0xfffedfa0>
  12184c:	ad400017 	ldw	r21,0(r21)
  121850:	a83fee1e 	bne	r21,zero,12180c <__alt_data_end+0xfffedf8c>
  121854:	0120ce80 	call	120ce8 <__sfp_lock_release>
  121858:	b005883a 	mov	r2,r22
  12185c:	dfc00717 	ldw	ra,28(sp)
  121860:	dd800617 	ldw	r22,24(sp)
  121864:	dd400517 	ldw	r21,20(sp)
  121868:	dd000417 	ldw	r20,16(sp)
  12186c:	dcc00317 	ldw	r19,12(sp)
  121870:	dc800217 	ldw	r18,8(sp)
  121874:	dc400117 	ldw	r17,4(sp)
  121878:	dc000017 	ldw	r16,0(sp)
  12187c:	dec00804 	addi	sp,sp,32
  121880:	f800283a 	ret

00121884 <__smakebuf_r>:
  121884:	2880030b 	ldhu	r2,12(r5)
  121888:	10c0008c 	andi	r3,r2,2
  12188c:	1800401e 	bne	r3,zero,121990 <__smakebuf_r+0x10c>
  121890:	deffec04 	addi	sp,sp,-80
  121894:	dc000f15 	stw	r16,60(sp)
  121898:	2821883a 	mov	r16,r5
  12189c:	2940038f 	ldh	r5,14(r5)
  1218a0:	dc401015 	stw	r17,64(sp)
  1218a4:	dfc01315 	stw	ra,76(sp)
  1218a8:	dcc01215 	stw	r19,72(sp)
  1218ac:	dc801115 	stw	r18,68(sp)
  1218b0:	2023883a 	mov	r17,r4
  1218b4:	28001b16 	blt	r5,zero,121924 <__smakebuf_r+0xa0>
  1218b8:	d80d883a 	mov	r6,sp
  1218bc:	01216bc0 	call	1216bc <_fstat_r>
  1218c0:	10001716 	blt	r2,zero,121920 <__smakebuf_r+0x9c>
  1218c4:	d8800117 	ldw	r2,4(sp)
  1218c8:	00e00014 	movui	r3,32768
  1218cc:	10bc000c 	andi	r2,r2,61440
  1218d0:	10c03726 	beq	r2,r3,1219b0 <__smakebuf_r+0x12c>
  1218d4:	80c0030b 	ldhu	r3,12(r16)
  1218d8:	18c20014 	ori	r3,r3,2048
  1218dc:	80c0030d 	sth	r3,12(r16)
  1218e0:	00c80004 	movi	r3,8192
  1218e4:	10c03c1e 	bne	r2,r3,1219d8 <__smakebuf_r+0x154>
  1218e8:	8140038f 	ldh	r5,14(r16)
  1218ec:	8809883a 	mov	r4,r17
  1218f0:	0122e080 	call	122e08 <_isatty_r>
  1218f4:	10004e26 	beq	r2,zero,121a30 <__smakebuf_r+0x1ac>
  1218f8:	8080030b 	ldhu	r2,12(r16)
  1218fc:	04c00044 	movi	r19,1
  121900:	80c010c4 	addi	r3,r16,67
  121904:	14c4b03a 	or	r2,r2,r19
  121908:	8080030d 	sth	r2,12(r16)
  12190c:	80c00015 	stw	r3,0(r16)
  121910:	80c00415 	stw	r3,16(r16)
  121914:	84c00515 	stw	r19,20(r16)
  121918:	04810004 	movi	r18,1024
  12191c:	00000706 	br	12193c <__smakebuf_r+0xb8>
  121920:	8080030b 	ldhu	r2,12(r16)
  121924:	10c0200c 	andi	r3,r2,128
  121928:	18001f1e 	bne	r3,zero,1219a8 <__smakebuf_r+0x124>
  12192c:	04810004 	movi	r18,1024
  121930:	10820014 	ori	r2,r2,2048
  121934:	8080030d 	sth	r2,12(r16)
  121938:	0027883a 	mov	r19,zero
  12193c:	8809883a 	mov	r4,r17
  121940:	900b883a 	mov	r5,r18
  121944:	0121a3c0 	call	121a3c <_malloc_r>
  121948:	10002e26 	beq	r2,zero,121a04 <__smakebuf_r+0x180>
  12194c:	80c0030b 	ldhu	r3,12(r16)
  121950:	010004b4 	movhi	r4,18
  121954:	21026504 	addi	r4,r4,2452
  121958:	89000f15 	stw	r4,60(r17)
  12195c:	18c02014 	ori	r3,r3,128
  121960:	80c0030d 	sth	r3,12(r16)
  121964:	80800015 	stw	r2,0(r16)
  121968:	80800415 	stw	r2,16(r16)
  12196c:	84800515 	stw	r18,20(r16)
  121970:	98001c1e 	bne	r19,zero,1219e4 <__smakebuf_r+0x160>
  121974:	dfc01317 	ldw	ra,76(sp)
  121978:	dcc01217 	ldw	r19,72(sp)
  12197c:	dc801117 	ldw	r18,68(sp)
  121980:	dc401017 	ldw	r17,64(sp)
  121984:	dc000f17 	ldw	r16,60(sp)
  121988:	dec01404 	addi	sp,sp,80
  12198c:	f800283a 	ret
  121990:	288010c4 	addi	r2,r5,67
  121994:	28800015 	stw	r2,0(r5)
  121998:	28800415 	stw	r2,16(r5)
  12199c:	00800044 	movi	r2,1
  1219a0:	28800515 	stw	r2,20(r5)
  1219a4:	f800283a 	ret
  1219a8:	04801004 	movi	r18,64
  1219ac:	003fe006 	br	121930 <__alt_data_end+0xfffee0b0>
  1219b0:	81000a17 	ldw	r4,40(r16)
  1219b4:	00c004b4 	movhi	r3,18
  1219b8:	18c9c804 	addi	r3,r3,10016
  1219bc:	20ffc51e 	bne	r4,r3,1218d4 <__alt_data_end+0xfffee054>
  1219c0:	80c0030b 	ldhu	r3,12(r16)
  1219c4:	01010004 	movi	r4,1024
  1219c8:	81001315 	stw	r4,76(r16)
  1219cc:	1906b03a 	or	r3,r3,r4
  1219d0:	80c0030d 	sth	r3,12(r16)
  1219d4:	003fc206 	br	1218e0 <__alt_data_end+0xfffee060>
  1219d8:	0027883a 	mov	r19,zero
  1219dc:	04810004 	movi	r18,1024
  1219e0:	003fd606 	br	12193c <__alt_data_end+0xfffee0bc>
  1219e4:	8140038f 	ldh	r5,14(r16)
  1219e8:	8809883a 	mov	r4,r17
  1219ec:	0122e080 	call	122e08 <_isatty_r>
  1219f0:	103fe026 	beq	r2,zero,121974 <__alt_data_end+0xfffee0f4>
  1219f4:	8080030b 	ldhu	r2,12(r16)
  1219f8:	10800054 	ori	r2,r2,1
  1219fc:	8080030d 	sth	r2,12(r16)
  121a00:	003fdc06 	br	121974 <__alt_data_end+0xfffee0f4>
  121a04:	8080030b 	ldhu	r2,12(r16)
  121a08:	10c0800c 	andi	r3,r2,512
  121a0c:	183fd91e 	bne	r3,zero,121974 <__alt_data_end+0xfffee0f4>
  121a10:	10800094 	ori	r2,r2,2
  121a14:	80c010c4 	addi	r3,r16,67
  121a18:	8080030d 	sth	r2,12(r16)
  121a1c:	00800044 	movi	r2,1
  121a20:	80c00015 	stw	r3,0(r16)
  121a24:	80c00415 	stw	r3,16(r16)
  121a28:	80800515 	stw	r2,20(r16)
  121a2c:	003fd106 	br	121974 <__alt_data_end+0xfffee0f4>
  121a30:	04c00044 	movi	r19,1
  121a34:	04810004 	movi	r18,1024
  121a38:	003fc006 	br	12193c <__alt_data_end+0xfffee0bc>

00121a3c <_malloc_r>:
  121a3c:	defff504 	addi	sp,sp,-44
  121a40:	dc800315 	stw	r18,12(sp)
  121a44:	dfc00a15 	stw	ra,40(sp)
  121a48:	df000915 	stw	fp,36(sp)
  121a4c:	ddc00815 	stw	r23,32(sp)
  121a50:	dd800715 	stw	r22,28(sp)
  121a54:	dd400615 	stw	r21,24(sp)
  121a58:	dd000515 	stw	r20,20(sp)
  121a5c:	dcc00415 	stw	r19,16(sp)
  121a60:	dc400215 	stw	r17,8(sp)
  121a64:	dc000115 	stw	r16,4(sp)
  121a68:	288002c4 	addi	r2,r5,11
  121a6c:	00c00584 	movi	r3,22
  121a70:	2025883a 	mov	r18,r4
  121a74:	18802a2e 	bgeu	r3,r2,121b20 <_malloc_r+0xe4>
  121a78:	047ffe04 	movi	r17,-8
  121a7c:	1462703a 	and	r17,r2,r17
  121a80:	88009e16 	blt	r17,zero,121cfc <_malloc_r+0x2c0>
  121a84:	89409d36 	bltu	r17,r5,121cfc <_malloc_r+0x2c0>
  121a88:	0123f200 	call	123f20 <__malloc_lock>
  121a8c:	00807dc4 	movi	r2,503
  121a90:	14402736 	bltu	r2,r17,121b30 <_malloc_r+0xf4>
  121a94:	8806d0fa 	srli	r3,r17,3
  121a98:	04c004b4 	movhi	r19,18
  121a9c:	9cdf1e04 	addi	r19,r19,31864
  121aa0:	18c5883a 	add	r2,r3,r3
  121aa4:	1085883a 	add	r2,r2,r2
  121aa8:	1085883a 	add	r2,r2,r2
  121aac:	9885883a 	add	r2,r19,r2
  121ab0:	14000317 	ldw	r16,12(r2)
  121ab4:	80814a26 	beq	r16,r2,121fe0 <_malloc_r+0x5a4>
  121ab8:	80c00117 	ldw	r3,4(r16)
  121abc:	81000317 	ldw	r4,12(r16)
  121ac0:	00bfff04 	movi	r2,-4
  121ac4:	1884703a 	and	r2,r3,r2
  121ac8:	81400217 	ldw	r5,8(r16)
  121acc:	8085883a 	add	r2,r16,r2
  121ad0:	10c00117 	ldw	r3,4(r2)
  121ad4:	29000315 	stw	r4,12(r5)
  121ad8:	21400215 	stw	r5,8(r4)
  121adc:	18c00054 	ori	r3,r3,1
  121ae0:	10c00115 	stw	r3,4(r2)
  121ae4:	9009883a 	mov	r4,r18
  121ae8:	0123f400 	call	123f40 <__malloc_unlock>
  121aec:	80800204 	addi	r2,r16,8
  121af0:	dfc00a17 	ldw	ra,40(sp)
  121af4:	df000917 	ldw	fp,36(sp)
  121af8:	ddc00817 	ldw	r23,32(sp)
  121afc:	dd800717 	ldw	r22,28(sp)
  121b00:	dd400617 	ldw	r21,24(sp)
  121b04:	dd000517 	ldw	r20,20(sp)
  121b08:	dcc00417 	ldw	r19,16(sp)
  121b0c:	dc800317 	ldw	r18,12(sp)
  121b10:	dc400217 	ldw	r17,8(sp)
  121b14:	dc000117 	ldw	r16,4(sp)
  121b18:	dec00b04 	addi	sp,sp,44
  121b1c:	f800283a 	ret
  121b20:	04400404 	movi	r17,16
  121b24:	89407536 	bltu	r17,r5,121cfc <_malloc_r+0x2c0>
  121b28:	0123f200 	call	123f20 <__malloc_lock>
  121b2c:	003fd906 	br	121a94 <__alt_data_end+0xfffee214>
  121b30:	8806d27a 	srli	r3,r17,9
  121b34:	18007526 	beq	r3,zero,121d0c <_malloc_r+0x2d0>
  121b38:	00800104 	movi	r2,4
  121b3c:	10c0ef36 	bltu	r2,r3,121efc <_malloc_r+0x4c0>
  121b40:	8806d1ba 	srli	r3,r17,6
  121b44:	19c00e04 	addi	r7,r3,56
  121b48:	39cb883a 	add	r5,r7,r7
  121b4c:	04c004b4 	movhi	r19,18
  121b50:	294b883a 	add	r5,r5,r5
  121b54:	9cdf1e04 	addi	r19,r19,31864
  121b58:	294b883a 	add	r5,r5,r5
  121b5c:	994b883a 	add	r5,r19,r5
  121b60:	2c000317 	ldw	r16,12(r5)
  121b64:	2c000e26 	beq	r5,r16,121ba0 <_malloc_r+0x164>
  121b68:	80800117 	ldw	r2,4(r16)
  121b6c:	01bfff04 	movi	r6,-4
  121b70:	010003c4 	movi	r4,15
  121b74:	1184703a 	and	r2,r2,r6
  121b78:	1447c83a 	sub	r3,r2,r17
  121b7c:	20c00716 	blt	r4,r3,121b9c <_malloc_r+0x160>
  121b80:	1800650e 	bge	r3,zero,121d18 <_malloc_r+0x2dc>
  121b84:	84000317 	ldw	r16,12(r16)
  121b88:	2c000526 	beq	r5,r16,121ba0 <_malloc_r+0x164>
  121b8c:	80800117 	ldw	r2,4(r16)
  121b90:	1184703a 	and	r2,r2,r6
  121b94:	1447c83a 	sub	r3,r2,r17
  121b98:	20fff90e 	bge	r4,r3,121b80 <__alt_data_end+0xfffee300>
  121b9c:	39ffffc4 	addi	r7,r7,-1
  121ba0:	38c00044 	addi	r3,r7,1
  121ba4:	018004b4 	movhi	r6,18
  121ba8:	9c000417 	ldw	r16,16(r19)
  121bac:	319f1e04 	addi	r6,r6,31864
  121bb0:	32400204 	addi	r9,r6,8
  121bb4:	82410326 	beq	r16,r9,121fc4 <_malloc_r+0x588>
  121bb8:	81000117 	ldw	r4,4(r16)
  121bbc:	00bfff04 	movi	r2,-4
  121bc0:	208e703a 	and	r7,r4,r2
  121bc4:	3c45c83a 	sub	r2,r7,r17
  121bc8:	010003c4 	movi	r4,15
  121bcc:	2080ee16 	blt	r4,r2,121f88 <_malloc_r+0x54c>
  121bd0:	32400515 	stw	r9,20(r6)
  121bd4:	32400415 	stw	r9,16(r6)
  121bd8:	1000510e 	bge	r2,zero,121d20 <_malloc_r+0x2e4>
  121bdc:	00807fc4 	movi	r2,511
  121be0:	11c0ce36 	bltu	r2,r7,121f1c <_malloc_r+0x4e0>
  121be4:	3808d0fa 	srli	r4,r7,3
  121be8:	01c00044 	movi	r7,1
  121bec:	30800117 	ldw	r2,4(r6)
  121bf0:	210b883a 	add	r5,r4,r4
  121bf4:	294b883a 	add	r5,r5,r5
  121bf8:	2009d0ba 	srai	r4,r4,2
  121bfc:	294b883a 	add	r5,r5,r5
  121c00:	298b883a 	add	r5,r5,r6
  121c04:	2a000217 	ldw	r8,8(r5)
  121c08:	3908983a 	sll	r4,r7,r4
  121c0c:	81400315 	stw	r5,12(r16)
  121c10:	82000215 	stw	r8,8(r16)
  121c14:	2088b03a 	or	r4,r4,r2
  121c18:	2c000215 	stw	r16,8(r5)
  121c1c:	31000115 	stw	r4,4(r6)
  121c20:	44000315 	stw	r16,12(r8)
  121c24:	1805d0ba 	srai	r2,r3,2
  121c28:	01400044 	movi	r5,1
  121c2c:	288a983a 	sll	r5,r5,r2
  121c30:	21404336 	bltu	r4,r5,121d40 <_malloc_r+0x304>
  121c34:	2144703a 	and	r2,r4,r5
  121c38:	10000a1e 	bne	r2,zero,121c64 <_malloc_r+0x228>
  121c3c:	00bfff04 	movi	r2,-4
  121c40:	294b883a 	add	r5,r5,r5
  121c44:	1886703a 	and	r3,r3,r2
  121c48:	2144703a 	and	r2,r4,r5
  121c4c:	18c00104 	addi	r3,r3,4
  121c50:	1000041e 	bne	r2,zero,121c64 <_malloc_r+0x228>
  121c54:	294b883a 	add	r5,r5,r5
  121c58:	2144703a 	and	r2,r4,r5
  121c5c:	18c00104 	addi	r3,r3,4
  121c60:	103ffc26 	beq	r2,zero,121c54 <__alt_data_end+0xfffee3d4>
  121c64:	023fff04 	movi	r8,-4
  121c68:	01c003c4 	movi	r7,15
  121c6c:	18c5883a 	add	r2,r3,r3
  121c70:	1085883a 	add	r2,r2,r2
  121c74:	1085883a 	add	r2,r2,r2
  121c78:	9895883a 	add	r10,r19,r2
  121c7c:	52c00304 	addi	r11,r10,12
  121c80:	1819883a 	mov	r12,r3
  121c84:	5c000017 	ldw	r16,0(r11)
  121c88:	59bffd04 	addi	r6,r11,-12
  121c8c:	8180041e 	bne	r16,r6,121ca0 <_malloc_r+0x264>
  121c90:	0000ce06 	br	121fcc <_malloc_r+0x590>
  121c94:	2000d70e 	bge	r4,zero,121ff4 <_malloc_r+0x5b8>
  121c98:	84000317 	ldw	r16,12(r16)
  121c9c:	8180cb26 	beq	r16,r6,121fcc <_malloc_r+0x590>
  121ca0:	80800117 	ldw	r2,4(r16)
  121ca4:	1204703a 	and	r2,r2,r8
  121ca8:	1449c83a 	sub	r4,r2,r17
  121cac:	393ff90e 	bge	r7,r4,121c94 <__alt_data_end+0xfffee414>
  121cb0:	80800317 	ldw	r2,12(r16)
  121cb4:	80c00217 	ldw	r3,8(r16)
  121cb8:	89400054 	ori	r5,r17,1
  121cbc:	81400115 	stw	r5,4(r16)
  121cc0:	18800315 	stw	r2,12(r3)
  121cc4:	10c00215 	stw	r3,8(r2)
  121cc8:	8463883a 	add	r17,r16,r17
  121ccc:	9c400515 	stw	r17,20(r19)
  121cd0:	9c400415 	stw	r17,16(r19)
  121cd4:	20800054 	ori	r2,r4,1
  121cd8:	88800115 	stw	r2,4(r17)
  121cdc:	8a400315 	stw	r9,12(r17)
  121ce0:	8a400215 	stw	r9,8(r17)
  121ce4:	8923883a 	add	r17,r17,r4
  121ce8:	89000015 	stw	r4,0(r17)
  121cec:	9009883a 	mov	r4,r18
  121cf0:	0123f400 	call	123f40 <__malloc_unlock>
  121cf4:	80800204 	addi	r2,r16,8
  121cf8:	003f7d06 	br	121af0 <__alt_data_end+0xfffee270>
  121cfc:	00800304 	movi	r2,12
  121d00:	90800015 	stw	r2,0(r18)
  121d04:	0005883a 	mov	r2,zero
  121d08:	003f7906 	br	121af0 <__alt_data_end+0xfffee270>
  121d0c:	01401f84 	movi	r5,126
  121d10:	01c00fc4 	movi	r7,63
  121d14:	003f8d06 	br	121b4c <__alt_data_end+0xfffee2cc>
  121d18:	81000317 	ldw	r4,12(r16)
  121d1c:	003f6a06 	br	121ac8 <__alt_data_end+0xfffee248>
  121d20:	81c5883a 	add	r2,r16,r7
  121d24:	10c00117 	ldw	r3,4(r2)
  121d28:	9009883a 	mov	r4,r18
  121d2c:	18c00054 	ori	r3,r3,1
  121d30:	10c00115 	stw	r3,4(r2)
  121d34:	0123f400 	call	123f40 <__malloc_unlock>
  121d38:	80800204 	addi	r2,r16,8
  121d3c:	003f6c06 	br	121af0 <__alt_data_end+0xfffee270>
  121d40:	9c000217 	ldw	r16,8(r19)
  121d44:	00bfff04 	movi	r2,-4
  121d48:	85800117 	ldw	r22,4(r16)
  121d4c:	b0ac703a 	and	r22,r22,r2
  121d50:	b4400336 	bltu	r22,r17,121d60 <_malloc_r+0x324>
  121d54:	b445c83a 	sub	r2,r22,r17
  121d58:	00c003c4 	movi	r3,15
  121d5c:	18805d16 	blt	r3,r2,121ed4 <_malloc_r+0x498>
  121d60:	05c004f4 	movhi	r23,19
  121d64:	008004f4 	movhi	r2,19
  121d68:	bde4eb04 	addi	r23,r23,-27732
  121d6c:	10abe004 	addi	r2,r2,-20608
  121d70:	15400017 	ldw	r21,0(r2)
  121d74:	b9000017 	ldw	r4,0(r23)
  121d78:	00ffffc4 	movi	r3,-1
  121d7c:	858d883a 	add	r6,r16,r22
  121d80:	8d6b883a 	add	r21,r17,r21
  121d84:	20c0e426 	beq	r4,r3,122118 <_malloc_r+0x6dc>
  121d88:	ad4403c4 	addi	r21,r21,4111
  121d8c:	00fc0004 	movi	r3,-4096
  121d90:	a8ea703a 	and	r21,r21,r3
  121d94:	9009883a 	mov	r4,r18
  121d98:	a80b883a 	mov	r5,r21
  121d9c:	d9800015 	stw	r6,0(sp)
  121da0:	01225f40 	call	1225f4 <_sbrk_r>
  121da4:	00ffffc4 	movi	r3,-1
  121da8:	1029883a 	mov	r20,r2
  121dac:	d9800017 	ldw	r6,0(sp)
  121db0:	10c0a426 	beq	r2,r3,122044 <_malloc_r+0x608>
  121db4:	1180a236 	bltu	r2,r6,122040 <_malloc_r+0x604>
  121db8:	070004f4 	movhi	fp,19
  121dbc:	e72be804 	addi	fp,fp,-20576
  121dc0:	e0c00017 	ldw	r3,0(fp)
  121dc4:	a8c7883a 	add	r3,r21,r3
  121dc8:	e0c00015 	stw	r3,0(fp)
  121dcc:	3500da26 	beq	r6,r20,122138 <_malloc_r+0x6fc>
  121dd0:	b9000017 	ldw	r4,0(r23)
  121dd4:	00bfffc4 	movi	r2,-1
  121dd8:	2080e426 	beq	r4,r2,12216c <_malloc_r+0x730>
  121ddc:	a185c83a 	sub	r2,r20,r6
  121de0:	1885883a 	add	r2,r3,r2
  121de4:	e0800015 	stw	r2,0(fp)
  121de8:	a0c001cc 	andi	r3,r20,7
  121dec:	1800b526 	beq	r3,zero,1220c4 <_malloc_r+0x688>
  121df0:	a0e9c83a 	sub	r20,r20,r3
  121df4:	00840204 	movi	r2,4104
  121df8:	a5000204 	addi	r20,r20,8
  121dfc:	10c7c83a 	sub	r3,r2,r3
  121e00:	a545883a 	add	r2,r20,r21
  121e04:	1083ffcc 	andi	r2,r2,4095
  121e08:	18abc83a 	sub	r21,r3,r2
  121e0c:	9009883a 	mov	r4,r18
  121e10:	a80b883a 	mov	r5,r21
  121e14:	01225f40 	call	1225f4 <_sbrk_r>
  121e18:	00ffffc4 	movi	r3,-1
  121e1c:	10c0d026 	beq	r2,r3,122160 <_malloc_r+0x724>
  121e20:	1507c83a 	sub	r3,r2,r20
  121e24:	a8c7883a 	add	r3,r21,r3
  121e28:	18c00054 	ori	r3,r3,1
  121e2c:	e0800017 	ldw	r2,0(fp)
  121e30:	9d000215 	stw	r20,8(r19)
  121e34:	a0c00115 	stw	r3,4(r20)
  121e38:	a887883a 	add	r3,r21,r2
  121e3c:	e0c00015 	stw	r3,0(fp)
  121e40:	84c00e26 	beq	r16,r19,121e7c <_malloc_r+0x440>
  121e44:	018003c4 	movi	r6,15
  121e48:	3580a02e 	bgeu	r6,r22,1220cc <_malloc_r+0x690>
  121e4c:	81400117 	ldw	r5,4(r16)
  121e50:	013ffe04 	movi	r4,-8
  121e54:	b0bffd04 	addi	r2,r22,-12
  121e58:	1104703a 	and	r2,r2,r4
  121e5c:	2900004c 	andi	r4,r5,1
  121e60:	1108b03a 	or	r4,r2,r4
  121e64:	81000115 	stw	r4,4(r16)
  121e68:	01400144 	movi	r5,5
  121e6c:	8089883a 	add	r4,r16,r2
  121e70:	21400115 	stw	r5,4(r4)
  121e74:	21400215 	stw	r5,8(r4)
  121e78:	3080c036 	bltu	r6,r2,12217c <_malloc_r+0x740>
  121e7c:	008004f4 	movhi	r2,19
  121e80:	10abdf04 	addi	r2,r2,-20612
  121e84:	11000017 	ldw	r4,0(r2)
  121e88:	20c0012e 	bgeu	r4,r3,121e90 <_malloc_r+0x454>
  121e8c:	10c00015 	stw	r3,0(r2)
  121e90:	008004f4 	movhi	r2,19
  121e94:	10abde04 	addi	r2,r2,-20616
  121e98:	11000017 	ldw	r4,0(r2)
  121e9c:	9c000217 	ldw	r16,8(r19)
  121ea0:	20c0012e 	bgeu	r4,r3,121ea8 <_malloc_r+0x46c>
  121ea4:	10c00015 	stw	r3,0(r2)
  121ea8:	80c00117 	ldw	r3,4(r16)
  121eac:	00bfff04 	movi	r2,-4
  121eb0:	1886703a 	and	r3,r3,r2
  121eb4:	1c45c83a 	sub	r2,r3,r17
  121eb8:	1c400236 	bltu	r3,r17,121ec4 <_malloc_r+0x488>
  121ebc:	00c003c4 	movi	r3,15
  121ec0:	18800416 	blt	r3,r2,121ed4 <_malloc_r+0x498>
  121ec4:	9009883a 	mov	r4,r18
  121ec8:	0123f400 	call	123f40 <__malloc_unlock>
  121ecc:	0005883a 	mov	r2,zero
  121ed0:	003f0706 	br	121af0 <__alt_data_end+0xfffee270>
  121ed4:	88c00054 	ori	r3,r17,1
  121ed8:	80c00115 	stw	r3,4(r16)
  121edc:	8463883a 	add	r17,r16,r17
  121ee0:	10800054 	ori	r2,r2,1
  121ee4:	9c400215 	stw	r17,8(r19)
  121ee8:	88800115 	stw	r2,4(r17)
  121eec:	9009883a 	mov	r4,r18
  121ef0:	0123f400 	call	123f40 <__malloc_unlock>
  121ef4:	80800204 	addi	r2,r16,8
  121ef8:	003efd06 	br	121af0 <__alt_data_end+0xfffee270>
  121efc:	00800504 	movi	r2,20
  121f00:	10c0482e 	bgeu	r2,r3,122024 <_malloc_r+0x5e8>
  121f04:	00801504 	movi	r2,84
  121f08:	10c06836 	bltu	r2,r3,1220ac <_malloc_r+0x670>
  121f0c:	8806d33a 	srli	r3,r17,12
  121f10:	19c01b84 	addi	r7,r3,110
  121f14:	39cb883a 	add	r5,r7,r7
  121f18:	003f0c06 	br	121b4c <__alt_data_end+0xfffee2cc>
  121f1c:	3804d27a 	srli	r2,r7,9
  121f20:	01000104 	movi	r4,4
  121f24:	2080422e 	bgeu	r4,r2,122030 <_malloc_r+0x5f4>
  121f28:	01000504 	movi	r4,20
  121f2c:	20807c36 	bltu	r4,r2,122120 <_malloc_r+0x6e4>
  121f30:	110016c4 	addi	r4,r2,91
  121f34:	210b883a 	add	r5,r4,r4
  121f38:	294b883a 	add	r5,r5,r5
  121f3c:	294b883a 	add	r5,r5,r5
  121f40:	994b883a 	add	r5,r19,r5
  121f44:	28800217 	ldw	r2,8(r5)
  121f48:	020004b4 	movhi	r8,18
  121f4c:	421f1e04 	addi	r8,r8,31864
  121f50:	11406326 	beq	r2,r5,1220e0 <_malloc_r+0x6a4>
  121f54:	01bfff04 	movi	r6,-4
  121f58:	11000117 	ldw	r4,4(r2)
  121f5c:	2188703a 	and	r4,r4,r6
  121f60:	3900022e 	bgeu	r7,r4,121f6c <_malloc_r+0x530>
  121f64:	10800217 	ldw	r2,8(r2)
  121f68:	28bffb1e 	bne	r5,r2,121f58 <__alt_data_end+0xfffee6d8>
  121f6c:	11800317 	ldw	r6,12(r2)
  121f70:	99000117 	ldw	r4,4(r19)
  121f74:	81800315 	stw	r6,12(r16)
  121f78:	80800215 	stw	r2,8(r16)
  121f7c:	34000215 	stw	r16,8(r6)
  121f80:	14000315 	stw	r16,12(r2)
  121f84:	003f2706 	br	121c24 <__alt_data_end+0xfffee3a4>
  121f88:	88c00054 	ori	r3,r17,1
  121f8c:	80c00115 	stw	r3,4(r16)
  121f90:	8463883a 	add	r17,r16,r17
  121f94:	34400515 	stw	r17,20(r6)
  121f98:	34400415 	stw	r17,16(r6)
  121f9c:	10c00054 	ori	r3,r2,1
  121fa0:	8a400315 	stw	r9,12(r17)
  121fa4:	8a400215 	stw	r9,8(r17)
  121fa8:	88c00115 	stw	r3,4(r17)
  121fac:	88a3883a 	add	r17,r17,r2
  121fb0:	88800015 	stw	r2,0(r17)
  121fb4:	9009883a 	mov	r4,r18
  121fb8:	0123f400 	call	123f40 <__malloc_unlock>
  121fbc:	80800204 	addi	r2,r16,8
  121fc0:	003ecb06 	br	121af0 <__alt_data_end+0xfffee270>
  121fc4:	31000117 	ldw	r4,4(r6)
  121fc8:	003f1606 	br	121c24 <__alt_data_end+0xfffee3a4>
  121fcc:	63000044 	addi	r12,r12,1
  121fd0:	608000cc 	andi	r2,r12,3
  121fd4:	5ac00204 	addi	r11,r11,8
  121fd8:	103f2a1e 	bne	r2,zero,121c84 <__alt_data_end+0xfffee404>
  121fdc:	00002106 	br	122064 <_malloc_r+0x628>
  121fe0:	80800204 	addi	r2,r16,8
  121fe4:	84000517 	ldw	r16,20(r16)
  121fe8:	143eb31e 	bne	r2,r16,121ab8 <__alt_data_end+0xfffee238>
  121fec:	18c00084 	addi	r3,r3,2
  121ff0:	003eec06 	br	121ba4 <__alt_data_end+0xfffee324>
  121ff4:	8085883a 	add	r2,r16,r2
  121ff8:	10c00117 	ldw	r3,4(r2)
  121ffc:	81000317 	ldw	r4,12(r16)
  122000:	81400217 	ldw	r5,8(r16)
  122004:	18c00054 	ori	r3,r3,1
  122008:	10c00115 	stw	r3,4(r2)
  12200c:	29000315 	stw	r4,12(r5)
  122010:	21400215 	stw	r5,8(r4)
  122014:	9009883a 	mov	r4,r18
  122018:	0123f400 	call	123f40 <__malloc_unlock>
  12201c:	80800204 	addi	r2,r16,8
  122020:	003eb306 	br	121af0 <__alt_data_end+0xfffee270>
  122024:	19c016c4 	addi	r7,r3,91
  122028:	39cb883a 	add	r5,r7,r7
  12202c:	003ec706 	br	121b4c <__alt_data_end+0xfffee2cc>
  122030:	3804d1ba 	srli	r2,r7,6
  122034:	11000e04 	addi	r4,r2,56
  122038:	210b883a 	add	r5,r4,r4
  12203c:	003fbe06 	br	121f38 <__alt_data_end+0xfffee6b8>
  122040:	84ff5d26 	beq	r16,r19,121db8 <__alt_data_end+0xfffee538>
  122044:	9c000217 	ldw	r16,8(r19)
  122048:	00bfff04 	movi	r2,-4
  12204c:	80c00117 	ldw	r3,4(r16)
  122050:	1886703a 	and	r3,r3,r2
  122054:	003f9706 	br	121eb4 <__alt_data_end+0xfffee634>
  122058:	52800017 	ldw	r10,0(r10)
  12205c:	18ffffc4 	addi	r3,r3,-1
  122060:	50805c1e 	bne	r10,r2,1221d4 <_malloc_r+0x798>
  122064:	190000cc 	andi	r4,r3,3
  122068:	50bffe04 	addi	r2,r10,-8
  12206c:	203ffa1e 	bne	r4,zero,122058 <__alt_data_end+0xfffee7d8>
  122070:	98800117 	ldw	r2,4(r19)
  122074:	0146303a 	nor	r3,zero,r5
  122078:	1884703a 	and	r2,r3,r2
  12207c:	98800115 	stw	r2,4(r19)
  122080:	294b883a 	add	r5,r5,r5
  122084:	117f2e36 	bltu	r2,r5,121d40 <__alt_data_end+0xfffee4c0>
  122088:	283f2d26 	beq	r5,zero,121d40 <__alt_data_end+0xfffee4c0>
  12208c:	1146703a 	and	r3,r2,r5
  122090:	1800521e 	bne	r3,zero,1221dc <_malloc_r+0x7a0>
  122094:	6007883a 	mov	r3,r12
  122098:	294b883a 	add	r5,r5,r5
  12209c:	1148703a 	and	r4,r2,r5
  1220a0:	18c00104 	addi	r3,r3,4
  1220a4:	203ffc26 	beq	r4,zero,122098 <__alt_data_end+0xfffee818>
  1220a8:	003ef006 	br	121c6c <__alt_data_end+0xfffee3ec>
  1220ac:	00805504 	movi	r2,340
  1220b0:	10c01336 	bltu	r2,r3,122100 <_malloc_r+0x6c4>
  1220b4:	8806d3fa 	srli	r3,r17,15
  1220b8:	19c01dc4 	addi	r7,r3,119
  1220bc:	39cb883a 	add	r5,r7,r7
  1220c0:	003ea206 	br	121b4c <__alt_data_end+0xfffee2cc>
  1220c4:	00c40004 	movi	r3,4096
  1220c8:	003f4d06 	br	121e00 <__alt_data_end+0xfffee580>
  1220cc:	00800044 	movi	r2,1
  1220d0:	a0800115 	stw	r2,4(r20)
  1220d4:	a021883a 	mov	r16,r20
  1220d8:	0007883a 	mov	r3,zero
  1220dc:	003f7506 	br	121eb4 <__alt_data_end+0xfffee634>
  1220e0:	200bd0ba 	srai	r5,r4,2
  1220e4:	01800044 	movi	r6,1
  1220e8:	41000117 	ldw	r4,4(r8)
  1220ec:	314a983a 	sll	r5,r6,r5
  1220f0:	100d883a 	mov	r6,r2
  1220f4:	2908b03a 	or	r4,r5,r4
  1220f8:	41000115 	stw	r4,4(r8)
  1220fc:	003f9d06 	br	121f74 <__alt_data_end+0xfffee6f4>
  122100:	00815504 	movi	r2,1364
  122104:	10c01336 	bltu	r2,r3,122154 <_malloc_r+0x718>
  122108:	8806d4ba 	srli	r3,r17,18
  12210c:	19c01f04 	addi	r7,r3,124
  122110:	39cb883a 	add	r5,r7,r7
  122114:	003e8d06 	br	121b4c <__alt_data_end+0xfffee2cc>
  122118:	ad400404 	addi	r21,r21,16
  12211c:	003f1d06 	br	121d94 <__alt_data_end+0xfffee514>
  122120:	01001504 	movi	r4,84
  122124:	20801c36 	bltu	r4,r2,122198 <_malloc_r+0x75c>
  122128:	3804d33a 	srli	r2,r7,12
  12212c:	11001b84 	addi	r4,r2,110
  122130:	210b883a 	add	r5,r4,r4
  122134:	003f8006 	br	121f38 <__alt_data_end+0xfffee6b8>
  122138:	3083ffcc 	andi	r2,r6,4095
  12213c:	103f241e 	bne	r2,zero,121dd0 <__alt_data_end+0xfffee550>
  122140:	99000217 	ldw	r4,8(r19)
  122144:	ad85883a 	add	r2,r21,r22
  122148:	10800054 	ori	r2,r2,1
  12214c:	20800115 	stw	r2,4(r4)
  122150:	003f4a06 	br	121e7c <__alt_data_end+0xfffee5fc>
  122154:	01403f04 	movi	r5,252
  122158:	01c01f84 	movi	r7,126
  12215c:	003e7b06 	br	121b4c <__alt_data_end+0xfffee2cc>
  122160:	00c00044 	movi	r3,1
  122164:	002b883a 	mov	r21,zero
  122168:	003f3006 	br	121e2c <__alt_data_end+0xfffee5ac>
  12216c:	008004f4 	movhi	r2,19
  122170:	10a4eb04 	addi	r2,r2,-27732
  122174:	15000015 	stw	r20,0(r2)
  122178:	003f1b06 	br	121de8 <__alt_data_end+0xfffee568>
  12217c:	9009883a 	mov	r4,r18
  122180:	81400204 	addi	r5,r16,8
  122184:	0120f540 	call	120f54 <_free_r>
  122188:	008004f4 	movhi	r2,19
  12218c:	10abe804 	addi	r2,r2,-20576
  122190:	10c00017 	ldw	r3,0(r2)
  122194:	003f3906 	br	121e7c <__alt_data_end+0xfffee5fc>
  122198:	01005504 	movi	r4,340
  12219c:	20800436 	bltu	r4,r2,1221b0 <_malloc_r+0x774>
  1221a0:	3804d3fa 	srli	r2,r7,15
  1221a4:	11001dc4 	addi	r4,r2,119
  1221a8:	210b883a 	add	r5,r4,r4
  1221ac:	003f6206 	br	121f38 <__alt_data_end+0xfffee6b8>
  1221b0:	01015504 	movi	r4,1364
  1221b4:	20800436 	bltu	r4,r2,1221c8 <_malloc_r+0x78c>
  1221b8:	3804d4ba 	srli	r2,r7,18
  1221bc:	11001f04 	addi	r4,r2,124
  1221c0:	210b883a 	add	r5,r4,r4
  1221c4:	003f5c06 	br	121f38 <__alt_data_end+0xfffee6b8>
  1221c8:	01403f04 	movi	r5,252
  1221cc:	01001f84 	movi	r4,126
  1221d0:	003f5906 	br	121f38 <__alt_data_end+0xfffee6b8>
  1221d4:	98800117 	ldw	r2,4(r19)
  1221d8:	003fa906 	br	122080 <__alt_data_end+0xfffee800>
  1221dc:	6007883a 	mov	r3,r12
  1221e0:	003ea206 	br	121c6c <__alt_data_end+0xfffee3ec>

001221e4 <memset>:
  1221e4:	20c000cc 	andi	r3,r4,3
  1221e8:	2005883a 	mov	r2,r4
  1221ec:	18004326 	beq	r3,zero,1222fc <memset+0x118>
  1221f0:	31ffffc4 	addi	r7,r6,-1
  1221f4:	30004026 	beq	r6,zero,1222f8 <memset+0x114>
  1221f8:	2813883a 	mov	r9,r5
  1221fc:	200d883a 	mov	r6,r4
  122200:	2007883a 	mov	r3,r4
  122204:	00000406 	br	122218 <memset+0x34>
  122208:	3a3fffc4 	addi	r8,r7,-1
  12220c:	31800044 	addi	r6,r6,1
  122210:	38003926 	beq	r7,zero,1222f8 <memset+0x114>
  122214:	400f883a 	mov	r7,r8
  122218:	18c00044 	addi	r3,r3,1
  12221c:	32400005 	stb	r9,0(r6)
  122220:	1a0000cc 	andi	r8,r3,3
  122224:	403ff81e 	bne	r8,zero,122208 <__alt_data_end+0xfffee988>
  122228:	010000c4 	movi	r4,3
  12222c:	21c02d2e 	bgeu	r4,r7,1222e4 <memset+0x100>
  122230:	29803fcc 	andi	r6,r5,255
  122234:	3008923a 	slli	r4,r6,8
  122238:	218cb03a 	or	r6,r4,r6
  12223c:	3008943a 	slli	r4,r6,16
  122240:	218cb03a 	or	r6,r4,r6
  122244:	010003c4 	movi	r4,15
  122248:	21c0182e 	bgeu	r4,r7,1222ac <memset+0xc8>
  12224c:	3b3ffc04 	addi	r12,r7,-16
  122250:	6018d13a 	srli	r12,r12,4
  122254:	1a000104 	addi	r8,r3,4
  122258:	1ac00204 	addi	r11,r3,8
  12225c:	6008913a 	slli	r4,r12,4
  122260:	1a800304 	addi	r10,r3,12
  122264:	1813883a 	mov	r9,r3
  122268:	21000504 	addi	r4,r4,20
  12226c:	1909883a 	add	r4,r3,r4
  122270:	49800015 	stw	r6,0(r9)
  122274:	41800015 	stw	r6,0(r8)
  122278:	59800015 	stw	r6,0(r11)
  12227c:	51800015 	stw	r6,0(r10)
  122280:	42000404 	addi	r8,r8,16
  122284:	4a400404 	addi	r9,r9,16
  122288:	5ac00404 	addi	r11,r11,16
  12228c:	52800404 	addi	r10,r10,16
  122290:	413ff71e 	bne	r8,r4,122270 <__alt_data_end+0xfffee9f0>
  122294:	63000044 	addi	r12,r12,1
  122298:	6018913a 	slli	r12,r12,4
  12229c:	39c003cc 	andi	r7,r7,15
  1222a0:	010000c4 	movi	r4,3
  1222a4:	1b07883a 	add	r3,r3,r12
  1222a8:	21c00e2e 	bgeu	r4,r7,1222e4 <memset+0x100>
  1222ac:	1813883a 	mov	r9,r3
  1222b0:	3811883a 	mov	r8,r7
  1222b4:	010000c4 	movi	r4,3
  1222b8:	49800015 	stw	r6,0(r9)
  1222bc:	423fff04 	addi	r8,r8,-4
  1222c0:	4a400104 	addi	r9,r9,4
  1222c4:	223ffc36 	bltu	r4,r8,1222b8 <__alt_data_end+0xfffeea38>
  1222c8:	393fff04 	addi	r4,r7,-4
  1222cc:	2008d0ba 	srli	r4,r4,2
  1222d0:	39c000cc 	andi	r7,r7,3
  1222d4:	21000044 	addi	r4,r4,1
  1222d8:	2109883a 	add	r4,r4,r4
  1222dc:	2109883a 	add	r4,r4,r4
  1222e0:	1907883a 	add	r3,r3,r4
  1222e4:	38000426 	beq	r7,zero,1222f8 <memset+0x114>
  1222e8:	19cf883a 	add	r7,r3,r7
  1222ec:	19400005 	stb	r5,0(r3)
  1222f0:	18c00044 	addi	r3,r3,1
  1222f4:	19fffd1e 	bne	r3,r7,1222ec <__alt_data_end+0xfffeea6c>
  1222f8:	f800283a 	ret
  1222fc:	2007883a 	mov	r3,r4
  122300:	300f883a 	mov	r7,r6
  122304:	003fc806 	br	122228 <__alt_data_end+0xfffee9a8>

00122308 <_open_r>:
  122308:	defffd04 	addi	sp,sp,-12
  12230c:	dc000015 	stw	r16,0(sp)
  122310:	040004f4 	movhi	r16,19
  122314:	dc400115 	stw	r17,4(sp)
  122318:	842bdd04 	addi	r16,r16,-20620
  12231c:	2023883a 	mov	r17,r4
  122320:	2809883a 	mov	r4,r5
  122324:	300b883a 	mov	r5,r6
  122328:	380d883a 	mov	r6,r7
  12232c:	dfc00215 	stw	ra,8(sp)
  122330:	80000015 	stw	zero,0(r16)
  122334:	012407c0 	call	12407c <open>
  122338:	00ffffc4 	movi	r3,-1
  12233c:	10c00526 	beq	r2,r3,122354 <_open_r+0x4c>
  122340:	dfc00217 	ldw	ra,8(sp)
  122344:	dc400117 	ldw	r17,4(sp)
  122348:	dc000017 	ldw	r16,0(sp)
  12234c:	dec00304 	addi	sp,sp,12
  122350:	f800283a 	ret
  122354:	80c00017 	ldw	r3,0(r16)
  122358:	183ff926 	beq	r3,zero,122340 <__alt_data_end+0xfffeeac0>
  12235c:	88c00015 	stw	r3,0(r17)
  122360:	003ff706 	br	122340 <__alt_data_end+0xfffeeac0>

00122364 <_puts_r>:
  122364:	defff604 	addi	sp,sp,-40
  122368:	dc000715 	stw	r16,28(sp)
  12236c:	2021883a 	mov	r16,r4
  122370:	2809883a 	mov	r4,r5
  122374:	dc400815 	stw	r17,32(sp)
  122378:	dfc00915 	stw	ra,36(sp)
  12237c:	2823883a 	mov	r17,r5
  122380:	01227840 	call	122784 <strlen>
  122384:	00c004f4 	movhi	r3,19
  122388:	18e4ea04 	addi	r3,r3,-27736
  12238c:	18c00017 	ldw	r3,0(r3)
  122390:	11000044 	addi	r4,r2,1
  122394:	d8800115 	stw	r2,4(sp)
  122398:	18c00217 	ldw	r3,8(r3)
  12239c:	014004b4 	movhi	r5,18
  1223a0:	295deb04 	addi	r5,r5,30636
  1223a4:	1880030b 	ldhu	r2,12(r3)
  1223a8:	d9400215 	stw	r5,8(sp)
  1223ac:	d9000615 	stw	r4,24(sp)
  1223b0:	01400044 	movi	r5,1
  1223b4:	01000084 	movi	r4,2
  1223b8:	d9000515 	stw	r4,20(sp)
  1223bc:	dc400015 	stw	r17,0(sp)
  1223c0:	d9400315 	stw	r5,12(sp)
  1223c4:	dec00415 	stw	sp,16(sp)
  1223c8:	1108000c 	andi	r4,r2,8192
  1223cc:	2000061e 	bne	r4,zero,1223e8 <_puts_r+0x84>
  1223d0:	19401917 	ldw	r5,100(r3)
  1223d4:	0137ffc4 	movi	r4,-8193
  1223d8:	10880014 	ori	r2,r2,8192
  1223dc:	2908703a 	and	r4,r5,r4
  1223e0:	1880030d 	sth	r2,12(r3)
  1223e4:	19001915 	stw	r4,100(r3)
  1223e8:	81400217 	ldw	r5,8(r16)
  1223ec:	8009883a 	mov	r4,r16
  1223f0:	d9800404 	addi	r6,sp,16
  1223f4:	01229640 	call	122964 <__sfvwrite_r>
  1223f8:	1000061e 	bne	r2,zero,122414 <_puts_r+0xb0>
  1223fc:	00800284 	movi	r2,10
  122400:	dfc00917 	ldw	ra,36(sp)
  122404:	dc400817 	ldw	r17,32(sp)
  122408:	dc000717 	ldw	r16,28(sp)
  12240c:	dec00a04 	addi	sp,sp,40
  122410:	f800283a 	ret
  122414:	00bfffc4 	movi	r2,-1
  122418:	003ff906 	br	122400 <__alt_data_end+0xfffeeb80>

0012241c <puts>:
  12241c:	008004f4 	movhi	r2,19
  122420:	10a4ea04 	addi	r2,r2,-27736
  122424:	200b883a 	mov	r5,r4
  122428:	11000017 	ldw	r4,0(r2)
  12242c:	01223641 	jmpi	122364 <_puts_r>

00122430 <lflush>:
  122430:	2080030b 	ldhu	r2,12(r4)
  122434:	00c00244 	movi	r3,9
  122438:	1080024c 	andi	r2,r2,9
  12243c:	10c00226 	beq	r2,r3,122448 <lflush+0x18>
  122440:	0005883a 	mov	r2,zero
  122444:	f800283a 	ret
  122448:	01209541 	jmpi	120954 <fflush>

0012244c <__srefill_r>:
  12244c:	defffd04 	addi	sp,sp,-12
  122450:	dc400115 	stw	r17,4(sp)
  122454:	dc000015 	stw	r16,0(sp)
  122458:	dfc00215 	stw	ra,8(sp)
  12245c:	2023883a 	mov	r17,r4
  122460:	2821883a 	mov	r16,r5
  122464:	20000226 	beq	r4,zero,122470 <__srefill_r+0x24>
  122468:	20800e17 	ldw	r2,56(r4)
  12246c:	10003b26 	beq	r2,zero,12255c <__srefill_r+0x110>
  122470:	80c0030b 	ldhu	r3,12(r16)
  122474:	1908000c 	andi	r4,r3,8192
  122478:	1805883a 	mov	r2,r3
  12247c:	2000071e 	bne	r4,zero,12249c <__srefill_r+0x50>
  122480:	81001917 	ldw	r4,100(r16)
  122484:	18880014 	ori	r2,r3,8192
  122488:	00f7ffc4 	movi	r3,-8193
  12248c:	20c8703a 	and	r4,r4,r3
  122490:	8080030d 	sth	r2,12(r16)
  122494:	1007883a 	mov	r3,r2
  122498:	81001915 	stw	r4,100(r16)
  12249c:	80000115 	stw	zero,4(r16)
  1224a0:	1100080c 	andi	r4,r2,32
  1224a4:	20004d1e 	bne	r4,zero,1225dc <__srefill_r+0x190>
  1224a8:	1100010c 	andi	r4,r2,4
  1224ac:	20001e26 	beq	r4,zero,122528 <__srefill_r+0xdc>
  1224b0:	81400c17 	ldw	r5,48(r16)
  1224b4:	28000826 	beq	r5,zero,1224d8 <__srefill_r+0x8c>
  1224b8:	80801004 	addi	r2,r16,64
  1224bc:	28800226 	beq	r5,r2,1224c8 <__srefill_r+0x7c>
  1224c0:	8809883a 	mov	r4,r17
  1224c4:	0120f540 	call	120f54 <_free_r>
  1224c8:	80800f17 	ldw	r2,60(r16)
  1224cc:	80000c15 	stw	zero,48(r16)
  1224d0:	80800115 	stw	r2,4(r16)
  1224d4:	10002f1e 	bne	r2,zero,122594 <__srefill_r+0x148>
  1224d8:	80800417 	ldw	r2,16(r16)
  1224dc:	10004126 	beq	r2,zero,1225e4 <__srefill_r+0x198>
  1224e0:	8080030b 	ldhu	r2,12(r16)
  1224e4:	108000cc 	andi	r2,r2,3
  1224e8:	10001e1e 	bne	r2,zero,122564 <__srefill_r+0x118>
  1224ec:	81800417 	ldw	r6,16(r16)
  1224f0:	80800817 	ldw	r2,32(r16)
  1224f4:	81400717 	ldw	r5,28(r16)
  1224f8:	81c00517 	ldw	r7,20(r16)
  1224fc:	81800015 	stw	r6,0(r16)
  122500:	8809883a 	mov	r4,r17
  122504:	103ee83a 	callr	r2
  122508:	80800115 	stw	r2,4(r16)
  12250c:	00800d0e 	bge	zero,r2,122544 <__srefill_r+0xf8>
  122510:	0005883a 	mov	r2,zero
  122514:	dfc00217 	ldw	ra,8(sp)
  122518:	dc400117 	ldw	r17,4(sp)
  12251c:	dc000017 	ldw	r16,0(sp)
  122520:	dec00304 	addi	sp,sp,12
  122524:	f800283a 	ret
  122528:	1100040c 	andi	r4,r2,16
  12252c:	20002726 	beq	r4,zero,1225cc <__srefill_r+0x180>
  122530:	1080020c 	andi	r2,r2,8
  122534:	10001b1e 	bne	r2,zero,1225a4 <__srefill_r+0x158>
  122538:	18c00114 	ori	r3,r3,4
  12253c:	80c0030d 	sth	r3,12(r16)
  122540:	003fe506 	br	1224d8 <__alt_data_end+0xfffeec58>
  122544:	80c0030b 	ldhu	r3,12(r16)
  122548:	10000d1e 	bne	r2,zero,122580 <__srefill_r+0x134>
  12254c:	18c00814 	ori	r3,r3,32
  122550:	00bfffc4 	movi	r2,-1
  122554:	80c0030d 	sth	r3,12(r16)
  122558:	003fee06 	br	122514 <__alt_data_end+0xfffeec94>
  12255c:	0120cd40 	call	120cd4 <__sinit>
  122560:	003fc306 	br	122470 <__alt_data_end+0xfffeebf0>
  122564:	008004f4 	movhi	r2,19
  122568:	10a4e904 	addi	r2,r2,-27740
  12256c:	11000017 	ldw	r4,0(r2)
  122570:	014004b4 	movhi	r5,18
  122574:	29490c04 	addi	r5,r5,9264
  122578:	01217140 	call	121714 <_fwalk>
  12257c:	003fdb06 	br	1224ec <__alt_data_end+0xfffeec6c>
  122580:	18c01014 	ori	r3,r3,64
  122584:	80000115 	stw	zero,4(r16)
  122588:	00bfffc4 	movi	r2,-1
  12258c:	80c0030d 	sth	r3,12(r16)
  122590:	003fe006 	br	122514 <__alt_data_end+0xfffeec94>
  122594:	80c00e17 	ldw	r3,56(r16)
  122598:	0005883a 	mov	r2,zero
  12259c:	80c00015 	stw	r3,0(r16)
  1225a0:	003fdc06 	br	122514 <__alt_data_end+0xfffeec94>
  1225a4:	8809883a 	mov	r4,r17
  1225a8:	800b883a 	mov	r5,r16
  1225ac:	012072c0 	call	12072c <_fflush_r>
  1225b0:	10000a1e 	bne	r2,zero,1225dc <__srefill_r+0x190>
  1225b4:	8080030b 	ldhu	r2,12(r16)
  1225b8:	00fffdc4 	movi	r3,-9
  1225bc:	80000215 	stw	zero,8(r16)
  1225c0:	1886703a 	and	r3,r3,r2
  1225c4:	80000615 	stw	zero,24(r16)
  1225c8:	003fdb06 	br	122538 <__alt_data_end+0xfffeecb8>
  1225cc:	00800244 	movi	r2,9
  1225d0:	88800015 	stw	r2,0(r17)
  1225d4:	18c01014 	ori	r3,r3,64
  1225d8:	80c0030d 	sth	r3,12(r16)
  1225dc:	00bfffc4 	movi	r2,-1
  1225e0:	003fcc06 	br	122514 <__alt_data_end+0xfffeec94>
  1225e4:	8809883a 	mov	r4,r17
  1225e8:	800b883a 	mov	r5,r16
  1225ec:	01218840 	call	121884 <__smakebuf_r>
  1225f0:	003fbb06 	br	1224e0 <__alt_data_end+0xfffeec60>

001225f4 <_sbrk_r>:
  1225f4:	defffd04 	addi	sp,sp,-12
  1225f8:	dc000015 	stw	r16,0(sp)
  1225fc:	040004f4 	movhi	r16,19
  122600:	dc400115 	stw	r17,4(sp)
  122604:	842bdd04 	addi	r16,r16,-20620
  122608:	2023883a 	mov	r17,r4
  12260c:	2809883a 	mov	r4,r5
  122610:	dfc00215 	stw	ra,8(sp)
  122614:	80000015 	stw	zero,0(r16)
  122618:	01245ec0 	call	1245ec <sbrk>
  12261c:	00ffffc4 	movi	r3,-1
  122620:	10c00526 	beq	r2,r3,122638 <_sbrk_r+0x44>
  122624:	dfc00217 	ldw	ra,8(sp)
  122628:	dc400117 	ldw	r17,4(sp)
  12262c:	dc000017 	ldw	r16,0(sp)
  122630:	dec00304 	addi	sp,sp,12
  122634:	f800283a 	ret
  122638:	80c00017 	ldw	r3,0(r16)
  12263c:	183ff926 	beq	r3,zero,122624 <__alt_data_end+0xfffeeda4>
  122640:	88c00015 	stw	r3,0(r17)
  122644:	003ff706 	br	122624 <__alt_data_end+0xfffeeda4>

00122648 <__sread>:
  122648:	defffe04 	addi	sp,sp,-8
  12264c:	dc000015 	stw	r16,0(sp)
  122650:	2821883a 	mov	r16,r5
  122654:	2940038f 	ldh	r5,14(r5)
  122658:	dfc00115 	stw	ra,4(sp)
  12265c:	01232340 	call	123234 <_read_r>
  122660:	10000716 	blt	r2,zero,122680 <__sread+0x38>
  122664:	80c01417 	ldw	r3,80(r16)
  122668:	1887883a 	add	r3,r3,r2
  12266c:	80c01415 	stw	r3,80(r16)
  122670:	dfc00117 	ldw	ra,4(sp)
  122674:	dc000017 	ldw	r16,0(sp)
  122678:	dec00204 	addi	sp,sp,8
  12267c:	f800283a 	ret
  122680:	80c0030b 	ldhu	r3,12(r16)
  122684:	18fbffcc 	andi	r3,r3,61439
  122688:	80c0030d 	sth	r3,12(r16)
  12268c:	dfc00117 	ldw	ra,4(sp)
  122690:	dc000017 	ldw	r16,0(sp)
  122694:	dec00204 	addi	sp,sp,8
  122698:	f800283a 	ret

0012269c <__seofread>:
  12269c:	0005883a 	mov	r2,zero
  1226a0:	f800283a 	ret

001226a4 <__swrite>:
  1226a4:	2880030b 	ldhu	r2,12(r5)
  1226a8:	defffb04 	addi	sp,sp,-20
  1226ac:	dcc00315 	stw	r19,12(sp)
  1226b0:	dc800215 	stw	r18,8(sp)
  1226b4:	dc400115 	stw	r17,4(sp)
  1226b8:	dc000015 	stw	r16,0(sp)
  1226bc:	dfc00415 	stw	ra,16(sp)
  1226c0:	10c0400c 	andi	r3,r2,256
  1226c4:	2821883a 	mov	r16,r5
  1226c8:	2027883a 	mov	r19,r4
  1226cc:	3025883a 	mov	r18,r6
  1226d0:	3823883a 	mov	r17,r7
  1226d4:	18000526 	beq	r3,zero,1226ec <__swrite+0x48>
  1226d8:	2940038f 	ldh	r5,14(r5)
  1226dc:	000d883a 	mov	r6,zero
  1226e0:	01c00084 	movi	r7,2
  1226e4:	0122e5c0 	call	122e5c <_lseek_r>
  1226e8:	8080030b 	ldhu	r2,12(r16)
  1226ec:	8140038f 	ldh	r5,14(r16)
  1226f0:	10bbffcc 	andi	r2,r2,61439
  1226f4:	9809883a 	mov	r4,r19
  1226f8:	900d883a 	mov	r6,r18
  1226fc:	880f883a 	mov	r7,r17
  122700:	8080030d 	sth	r2,12(r16)
  122704:	dfc00417 	ldw	ra,16(sp)
  122708:	dcc00317 	ldw	r19,12(sp)
  12270c:	dc800217 	ldw	r18,8(sp)
  122710:	dc400117 	ldw	r17,4(sp)
  122714:	dc000017 	ldw	r16,0(sp)
  122718:	dec00504 	addi	sp,sp,20
  12271c:	012281c1 	jmpi	12281c <_write_r>

00122720 <__sseek>:
  122720:	defffe04 	addi	sp,sp,-8
  122724:	dc000015 	stw	r16,0(sp)
  122728:	2821883a 	mov	r16,r5
  12272c:	2940038f 	ldh	r5,14(r5)
  122730:	dfc00115 	stw	ra,4(sp)
  122734:	0122e5c0 	call	122e5c <_lseek_r>
  122738:	00ffffc4 	movi	r3,-1
  12273c:	10c00826 	beq	r2,r3,122760 <__sseek+0x40>
  122740:	80c0030b 	ldhu	r3,12(r16)
  122744:	80801415 	stw	r2,80(r16)
  122748:	18c40014 	ori	r3,r3,4096
  12274c:	80c0030d 	sth	r3,12(r16)
  122750:	dfc00117 	ldw	ra,4(sp)
  122754:	dc000017 	ldw	r16,0(sp)
  122758:	dec00204 	addi	sp,sp,8
  12275c:	f800283a 	ret
  122760:	80c0030b 	ldhu	r3,12(r16)
  122764:	18fbffcc 	andi	r3,r3,61439
  122768:	80c0030d 	sth	r3,12(r16)
  12276c:	dfc00117 	ldw	ra,4(sp)
  122770:	dc000017 	ldw	r16,0(sp)
  122774:	dec00204 	addi	sp,sp,8
  122778:	f800283a 	ret

0012277c <__sclose>:
  12277c:	2940038f 	ldh	r5,14(r5)
  122780:	01228781 	jmpi	122878 <_close_r>

00122784 <strlen>:
  122784:	208000cc 	andi	r2,r4,3
  122788:	10002026 	beq	r2,zero,12280c <strlen+0x88>
  12278c:	20800007 	ldb	r2,0(r4)
  122790:	10002026 	beq	r2,zero,122814 <strlen+0x90>
  122794:	2005883a 	mov	r2,r4
  122798:	00000206 	br	1227a4 <strlen+0x20>
  12279c:	10c00007 	ldb	r3,0(r2)
  1227a0:	18001826 	beq	r3,zero,122804 <strlen+0x80>
  1227a4:	10800044 	addi	r2,r2,1
  1227a8:	10c000cc 	andi	r3,r2,3
  1227ac:	183ffb1e 	bne	r3,zero,12279c <__alt_data_end+0xfffeef1c>
  1227b0:	10c00017 	ldw	r3,0(r2)
  1227b4:	01ffbff4 	movhi	r7,65279
  1227b8:	39ffbfc4 	addi	r7,r7,-257
  1227bc:	00ca303a 	nor	r5,zero,r3
  1227c0:	01a02074 	movhi	r6,32897
  1227c4:	19c7883a 	add	r3,r3,r7
  1227c8:	31a02004 	addi	r6,r6,-32640
  1227cc:	1946703a 	and	r3,r3,r5
  1227d0:	1986703a 	and	r3,r3,r6
  1227d4:	1800091e 	bne	r3,zero,1227fc <strlen+0x78>
  1227d8:	10800104 	addi	r2,r2,4
  1227dc:	10c00017 	ldw	r3,0(r2)
  1227e0:	19cb883a 	add	r5,r3,r7
  1227e4:	00c6303a 	nor	r3,zero,r3
  1227e8:	28c6703a 	and	r3,r5,r3
  1227ec:	1986703a 	and	r3,r3,r6
  1227f0:	183ff926 	beq	r3,zero,1227d8 <__alt_data_end+0xfffeef58>
  1227f4:	00000106 	br	1227fc <strlen+0x78>
  1227f8:	10800044 	addi	r2,r2,1
  1227fc:	10c00007 	ldb	r3,0(r2)
  122800:	183ffd1e 	bne	r3,zero,1227f8 <__alt_data_end+0xfffeef78>
  122804:	1105c83a 	sub	r2,r2,r4
  122808:	f800283a 	ret
  12280c:	2005883a 	mov	r2,r4
  122810:	003fe706 	br	1227b0 <__alt_data_end+0xfffeef30>
  122814:	0005883a 	mov	r2,zero
  122818:	f800283a 	ret

0012281c <_write_r>:
  12281c:	defffd04 	addi	sp,sp,-12
  122820:	dc000015 	stw	r16,0(sp)
  122824:	040004f4 	movhi	r16,19
  122828:	dc400115 	stw	r17,4(sp)
  12282c:	842bdd04 	addi	r16,r16,-20620
  122830:	2023883a 	mov	r17,r4
  122834:	2809883a 	mov	r4,r5
  122838:	300b883a 	mov	r5,r6
  12283c:	380d883a 	mov	r6,r7
  122840:	dfc00215 	stw	ra,8(sp)
  122844:	80000015 	stw	zero,0(r16)
  122848:	01246ec0 	call	1246ec <write>
  12284c:	00ffffc4 	movi	r3,-1
  122850:	10c00526 	beq	r2,r3,122868 <_write_r+0x4c>
  122854:	dfc00217 	ldw	ra,8(sp)
  122858:	dc400117 	ldw	r17,4(sp)
  12285c:	dc000017 	ldw	r16,0(sp)
  122860:	dec00304 	addi	sp,sp,12
  122864:	f800283a 	ret
  122868:	80c00017 	ldw	r3,0(r16)
  12286c:	183ff926 	beq	r3,zero,122854 <__alt_data_end+0xfffeefd4>
  122870:	88c00015 	stw	r3,0(r17)
  122874:	003ff706 	br	122854 <__alt_data_end+0xfffeefd4>

00122878 <_close_r>:
  122878:	defffd04 	addi	sp,sp,-12
  12287c:	dc000015 	stw	r16,0(sp)
  122880:	040004f4 	movhi	r16,19
  122884:	dc400115 	stw	r17,4(sp)
  122888:	842bdd04 	addi	r16,r16,-20620
  12288c:	2023883a 	mov	r17,r4
  122890:	2809883a 	mov	r4,r5
  122894:	dfc00215 	stw	ra,8(sp)
  122898:	80000015 	stw	zero,0(r16)
  12289c:	01239b00 	call	1239b0 <close>
  1228a0:	00ffffc4 	movi	r3,-1
  1228a4:	10c00526 	beq	r2,r3,1228bc <_close_r+0x44>
  1228a8:	dfc00217 	ldw	ra,8(sp)
  1228ac:	dc400117 	ldw	r17,4(sp)
  1228b0:	dc000017 	ldw	r16,0(sp)
  1228b4:	dec00304 	addi	sp,sp,12
  1228b8:	f800283a 	ret
  1228bc:	80c00017 	ldw	r3,0(r16)
  1228c0:	183ff926 	beq	r3,zero,1228a8 <__alt_data_end+0xfffef028>
  1228c4:	88c00015 	stw	r3,0(r17)
  1228c8:	003ff706 	br	1228a8 <__alt_data_end+0xfffef028>

001228cc <__sflags>:
  1228cc:	28800007 	ldb	r2,0(r5)
  1228d0:	00c01c84 	movi	r3,114
  1228d4:	10c01826 	beq	r2,r3,122938 <__sflags+0x6c>
  1228d8:	00c01dc4 	movi	r3,119
  1228dc:	10c01226 	beq	r2,r3,122928 <__sflags+0x5c>
  1228e0:	00c01844 	movi	r3,97
  1228e4:	10c00426 	beq	r2,r3,1228f8 <__sflags+0x2c>
  1228e8:	00800584 	movi	r2,22
  1228ec:	20800015 	stw	r2,0(r4)
  1228f0:	0005883a 	mov	r2,zero
  1228f4:	f800283a 	ret
  1228f8:	00c08204 	movi	r3,520
  1228fc:	01c00044 	movi	r7,1
  122900:	00804204 	movi	r2,264
  122904:	29000047 	ldb	r4,1(r5)
  122908:	20000426 	beq	r4,zero,12291c <__sflags+0x50>
  12290c:	02000ac4 	movi	r8,43
  122910:	22000d26 	beq	r4,r8,122948 <__sflags+0x7c>
  122914:	29000087 	ldb	r4,2(r5)
  122918:	22000b26 	beq	r4,r8,122948 <__sflags+0x7c>
  12291c:	38c6b03a 	or	r3,r7,r3
  122920:	30c00015 	stw	r3,0(r6)
  122924:	f800283a 	ret
  122928:	00c18004 	movi	r3,1536
  12292c:	01c00044 	movi	r7,1
  122930:	00800204 	movi	r2,8
  122934:	003ff306 	br	122904 <__alt_data_end+0xfffef084>
  122938:	0007883a 	mov	r3,zero
  12293c:	000f883a 	mov	r7,zero
  122940:	00800104 	movi	r2,4
  122944:	003fef06 	br	122904 <__alt_data_end+0xfffef084>
  122948:	013ff8c4 	movi	r4,-29
  12294c:	01c00084 	movi	r7,2
  122950:	1104703a 	and	r2,r2,r4
  122954:	38c6b03a 	or	r3,r7,r3
  122958:	10800414 	ori	r2,r2,16
  12295c:	30c00015 	stw	r3,0(r6)
  122960:	f800283a 	ret

00122964 <__sfvwrite_r>:
  122964:	30800217 	ldw	r2,8(r6)
  122968:	10004526 	beq	r2,zero,122a80 <__sfvwrite_r+0x11c>
  12296c:	28c0030b 	ldhu	r3,12(r5)
  122970:	defff404 	addi	sp,sp,-48
  122974:	dd400715 	stw	r21,28(sp)
  122978:	dcc00515 	stw	r19,20(sp)
  12297c:	dc000215 	stw	r16,8(sp)
  122980:	dfc00b15 	stw	ra,44(sp)
  122984:	df000a15 	stw	fp,40(sp)
  122988:	ddc00915 	stw	r23,36(sp)
  12298c:	dd800815 	stw	r22,32(sp)
  122990:	dd000615 	stw	r20,24(sp)
  122994:	dc800415 	stw	r18,16(sp)
  122998:	dc400315 	stw	r17,12(sp)
  12299c:	1880020c 	andi	r2,r3,8
  1229a0:	2821883a 	mov	r16,r5
  1229a4:	202b883a 	mov	r21,r4
  1229a8:	3027883a 	mov	r19,r6
  1229ac:	10002526 	beq	r2,zero,122a44 <__sfvwrite_r+0xe0>
  1229b0:	28800417 	ldw	r2,16(r5)
  1229b4:	10002326 	beq	r2,zero,122a44 <__sfvwrite_r+0xe0>
  1229b8:	1880008c 	andi	r2,r3,2
  1229bc:	9c400017 	ldw	r17,0(r19)
  1229c0:	10003126 	beq	r2,zero,122a88 <__sfvwrite_r+0x124>
  1229c4:	0029883a 	mov	r20,zero
  1229c8:	0025883a 	mov	r18,zero
  1229cc:	05810004 	movi	r22,1024
  1229d0:	a00d883a 	mov	r6,r20
  1229d4:	a809883a 	mov	r4,r21
  1229d8:	90002526 	beq	r18,zero,122a70 <__sfvwrite_r+0x10c>
  1229dc:	900f883a 	mov	r7,r18
  1229e0:	81400717 	ldw	r5,28(r16)
  1229e4:	b480012e 	bgeu	r22,r18,1229ec <__sfvwrite_r+0x88>
  1229e8:	01c10004 	movi	r7,1024
  1229ec:	80800917 	ldw	r2,36(r16)
  1229f0:	103ee83a 	callr	r2
  1229f4:	0080510e 	bge	zero,r2,122b3c <__sfvwrite_r+0x1d8>
  1229f8:	98c00217 	ldw	r3,8(r19)
  1229fc:	a0a9883a 	add	r20,r20,r2
  122a00:	90a5c83a 	sub	r18,r18,r2
  122a04:	1885c83a 	sub	r2,r3,r2
  122a08:	98800215 	stw	r2,8(r19)
  122a0c:	103ff01e 	bne	r2,zero,1229d0 <__alt_data_end+0xfffef150>
  122a10:	0005883a 	mov	r2,zero
  122a14:	dfc00b17 	ldw	ra,44(sp)
  122a18:	df000a17 	ldw	fp,40(sp)
  122a1c:	ddc00917 	ldw	r23,36(sp)
  122a20:	dd800817 	ldw	r22,32(sp)
  122a24:	dd400717 	ldw	r21,28(sp)
  122a28:	dd000617 	ldw	r20,24(sp)
  122a2c:	dcc00517 	ldw	r19,20(sp)
  122a30:	dc800417 	ldw	r18,16(sp)
  122a34:	dc400317 	ldw	r17,12(sp)
  122a38:	dc000217 	ldw	r16,8(sp)
  122a3c:	dec00c04 	addi	sp,sp,48
  122a40:	f800283a 	ret
  122a44:	a809883a 	mov	r4,r21
  122a48:	800b883a 	mov	r5,r16
  122a4c:	01238300 	call	123830 <__swsetup_r>
  122a50:	80c0030b 	ldhu	r3,12(r16)
  122a54:	103fd826 	beq	r2,zero,1229b8 <__alt_data_end+0xfffef138>
  122a58:	18c01014 	ori	r3,r3,64
  122a5c:	80c0030d 	sth	r3,12(r16)
  122a60:	00c00244 	movi	r3,9
  122a64:	00bfffc4 	movi	r2,-1
  122a68:	a8c00015 	stw	r3,0(r21)
  122a6c:	003fe906 	br	122a14 <__alt_data_end+0xfffef194>
  122a70:	8d000017 	ldw	r20,0(r17)
  122a74:	8c800117 	ldw	r18,4(r17)
  122a78:	8c400204 	addi	r17,r17,8
  122a7c:	003fd406 	br	1229d0 <__alt_data_end+0xfffef150>
  122a80:	0005883a 	mov	r2,zero
  122a84:	f800283a 	ret
  122a88:	1880004c 	andi	r2,r3,1
  122a8c:	1000301e 	bne	r2,zero,122b50 <__sfvwrite_r+0x1ec>
  122a90:	002f883a 	mov	r23,zero
  122a94:	0025883a 	mov	r18,zero
  122a98:	90001c26 	beq	r18,zero,122b0c <__sfvwrite_r+0x1a8>
  122a9c:	1880800c 	andi	r2,r3,512
  122aa0:	85000217 	ldw	r20,8(r16)
  122aa4:	10006c26 	beq	r2,zero,122c58 <__sfvwrite_r+0x2f4>
  122aa8:	a02d883a 	mov	r22,r20
  122aac:	95008536 	bltu	r18,r20,122cc4 <__sfvwrite_r+0x360>
  122ab0:	1881200c 	andi	r2,r3,1152
  122ab4:	10009d1e 	bne	r2,zero,122d2c <__sfvwrite_r+0x3c8>
  122ab8:	81000017 	ldw	r4,0(r16)
  122abc:	a039883a 	mov	fp,r20
  122ac0:	9029883a 	mov	r20,r18
  122ac4:	b80b883a 	mov	r5,r23
  122ac8:	b00d883a 	mov	r6,r22
  122acc:	01230d80 	call	1230d8 <memmove>
  122ad0:	80c00217 	ldw	r3,8(r16)
  122ad4:	81000017 	ldw	r4,0(r16)
  122ad8:	9005883a 	mov	r2,r18
  122adc:	1f39c83a 	sub	fp,r3,fp
  122ae0:	258f883a 	add	r7,r4,r22
  122ae4:	87000215 	stw	fp,8(r16)
  122ae8:	81c00015 	stw	r7,0(r16)
  122aec:	98c00217 	ldw	r3,8(r19)
  122af0:	b8af883a 	add	r23,r23,r2
  122af4:	90a5c83a 	sub	r18,r18,r2
  122af8:	1d05c83a 	sub	r2,r3,r20
  122afc:	98800215 	stw	r2,8(r19)
  122b00:	103fc326 	beq	r2,zero,122a10 <__alt_data_end+0xfffef190>
  122b04:	80c0030b 	ldhu	r3,12(r16)
  122b08:	903fe41e 	bne	r18,zero,122a9c <__alt_data_end+0xfffef21c>
  122b0c:	8dc00017 	ldw	r23,0(r17)
  122b10:	8c800117 	ldw	r18,4(r17)
  122b14:	8c400204 	addi	r17,r17,8
  122b18:	003fdf06 	br	122a98 <__alt_data_end+0xfffef218>
  122b1c:	01232900 	call	123290 <_realloc_r>
  122b20:	102d883a 	mov	r22,r2
  122b24:	1000a01e 	bne	r2,zero,122da8 <__sfvwrite_r+0x444>
  122b28:	81400417 	ldw	r5,16(r16)
  122b2c:	a809883a 	mov	r4,r21
  122b30:	0120f540 	call	120f54 <_free_r>
  122b34:	00800304 	movi	r2,12
  122b38:	a8800015 	stw	r2,0(r21)
  122b3c:	80c0030b 	ldhu	r3,12(r16)
  122b40:	00bfffc4 	movi	r2,-1
  122b44:	18c01014 	ori	r3,r3,64
  122b48:	80c0030d 	sth	r3,12(r16)
  122b4c:	003fb106 	br	122a14 <__alt_data_end+0xfffef194>
  122b50:	0029883a 	mov	r20,zero
  122b54:	0011883a 	mov	r8,zero
  122b58:	0039883a 	mov	fp,zero
  122b5c:	0025883a 	mov	r18,zero
  122b60:	90001f26 	beq	r18,zero,122be0 <__sfvwrite_r+0x27c>
  122b64:	40006826 	beq	r8,zero,122d08 <__sfvwrite_r+0x3a4>
  122b68:	a02f883a 	mov	r23,r20
  122b6c:	9500012e 	bgeu	r18,r20,122b74 <__sfvwrite_r+0x210>
  122b70:	902f883a 	mov	r23,r18
  122b74:	81000017 	ldw	r4,0(r16)
  122b78:	80800417 	ldw	r2,16(r16)
  122b7c:	b82d883a 	mov	r22,r23
  122b80:	81800217 	ldw	r6,8(r16)
  122b84:	81c00517 	ldw	r7,20(r16)
  122b88:	1100022e 	bgeu	r2,r4,122b94 <__sfvwrite_r+0x230>
  122b8c:	31c7883a 	add	r3,r6,r7
  122b90:	1dc01816 	blt	r3,r23,122bf4 <__sfvwrite_r+0x290>
  122b94:	b9c03f16 	blt	r23,r7,122c94 <__sfvwrite_r+0x330>
  122b98:	80800917 	ldw	r2,36(r16)
  122b9c:	81400717 	ldw	r5,28(r16)
  122ba0:	a809883a 	mov	r4,r21
  122ba4:	da000115 	stw	r8,4(sp)
  122ba8:	e00d883a 	mov	r6,fp
  122bac:	103ee83a 	callr	r2
  122bb0:	102d883a 	mov	r22,r2
  122bb4:	da000117 	ldw	r8,4(sp)
  122bb8:	00bfe00e 	bge	zero,r2,122b3c <__alt_data_end+0xfffef2bc>
  122bbc:	a5a9c83a 	sub	r20,r20,r22
  122bc0:	a0001f26 	beq	r20,zero,122c40 <__sfvwrite_r+0x2dc>
  122bc4:	98800217 	ldw	r2,8(r19)
  122bc8:	e5b9883a 	add	fp,fp,r22
  122bcc:	95a5c83a 	sub	r18,r18,r22
  122bd0:	15adc83a 	sub	r22,r2,r22
  122bd4:	9d800215 	stw	r22,8(r19)
  122bd8:	b03f8d26 	beq	r22,zero,122a10 <__alt_data_end+0xfffef190>
  122bdc:	903fe11e 	bne	r18,zero,122b64 <__alt_data_end+0xfffef2e4>
  122be0:	8f000017 	ldw	fp,0(r17)
  122be4:	8c800117 	ldw	r18,4(r17)
  122be8:	0011883a 	mov	r8,zero
  122bec:	8c400204 	addi	r17,r17,8
  122bf0:	003fdb06 	br	122b60 <__alt_data_end+0xfffef2e0>
  122bf4:	180d883a 	mov	r6,r3
  122bf8:	e00b883a 	mov	r5,fp
  122bfc:	da000115 	stw	r8,4(sp)
  122c00:	d8c00015 	stw	r3,0(sp)
  122c04:	01230d80 	call	1230d8 <memmove>
  122c08:	d8c00017 	ldw	r3,0(sp)
  122c0c:	80800017 	ldw	r2,0(r16)
  122c10:	a809883a 	mov	r4,r21
  122c14:	800b883a 	mov	r5,r16
  122c18:	10c5883a 	add	r2,r2,r3
  122c1c:	80800015 	stw	r2,0(r16)
  122c20:	d8c00015 	stw	r3,0(sp)
  122c24:	012072c0 	call	12072c <_fflush_r>
  122c28:	d8c00017 	ldw	r3,0(sp)
  122c2c:	da000117 	ldw	r8,4(sp)
  122c30:	103fc21e 	bne	r2,zero,122b3c <__alt_data_end+0xfffef2bc>
  122c34:	182d883a 	mov	r22,r3
  122c38:	a5a9c83a 	sub	r20,r20,r22
  122c3c:	a03fe11e 	bne	r20,zero,122bc4 <__alt_data_end+0xfffef344>
  122c40:	a809883a 	mov	r4,r21
  122c44:	800b883a 	mov	r5,r16
  122c48:	012072c0 	call	12072c <_fflush_r>
  122c4c:	103fbb1e 	bne	r2,zero,122b3c <__alt_data_end+0xfffef2bc>
  122c50:	0011883a 	mov	r8,zero
  122c54:	003fdb06 	br	122bc4 <__alt_data_end+0xfffef344>
  122c58:	81000017 	ldw	r4,0(r16)
  122c5c:	80800417 	ldw	r2,16(r16)
  122c60:	1100012e 	bgeu	r2,r4,122c68 <__sfvwrite_r+0x304>
  122c64:	a4805a36 	bltu	r20,r18,122dd0 <__sfvwrite_r+0x46c>
  122c68:	81c00517 	ldw	r7,20(r16)
  122c6c:	91c01a36 	bltu	r18,r7,122cd8 <__sfvwrite_r+0x374>
  122c70:	80800917 	ldw	r2,36(r16)
  122c74:	81400717 	ldw	r5,28(r16)
  122c78:	a809883a 	mov	r4,r21
  122c7c:	b80d883a 	mov	r6,r23
  122c80:	103ee83a 	callr	r2
  122c84:	1029883a 	mov	r20,r2
  122c88:	00bfac0e 	bge	zero,r2,122b3c <__alt_data_end+0xfffef2bc>
  122c8c:	a005883a 	mov	r2,r20
  122c90:	003f9606 	br	122aec <__alt_data_end+0xfffef26c>
  122c94:	b80d883a 	mov	r6,r23
  122c98:	e00b883a 	mov	r5,fp
  122c9c:	da000115 	stw	r8,4(sp)
  122ca0:	01230d80 	call	1230d8 <memmove>
  122ca4:	80800217 	ldw	r2,8(r16)
  122ca8:	80c00017 	ldw	r3,0(r16)
  122cac:	da000117 	ldw	r8,4(sp)
  122cb0:	15c5c83a 	sub	r2,r2,r23
  122cb4:	1def883a 	add	r23,r3,r23
  122cb8:	80800215 	stw	r2,8(r16)
  122cbc:	85c00015 	stw	r23,0(r16)
  122cc0:	003fbe06 	br	122bbc <__alt_data_end+0xfffef33c>
  122cc4:	81000017 	ldw	r4,0(r16)
  122cc8:	9039883a 	mov	fp,r18
  122ccc:	9029883a 	mov	r20,r18
  122cd0:	902d883a 	mov	r22,r18
  122cd4:	003f7b06 	br	122ac4 <__alt_data_end+0xfffef244>
  122cd8:	b80b883a 	mov	r5,r23
  122cdc:	900d883a 	mov	r6,r18
  122ce0:	01230d80 	call	1230d8 <memmove>
  122ce4:	80c00217 	ldw	r3,8(r16)
  122ce8:	80800017 	ldw	r2,0(r16)
  122cec:	9029883a 	mov	r20,r18
  122cf0:	1c87c83a 	sub	r3,r3,r18
  122cf4:	1485883a 	add	r2,r2,r18
  122cf8:	80800015 	stw	r2,0(r16)
  122cfc:	80c00215 	stw	r3,8(r16)
  122d00:	9005883a 	mov	r2,r18
  122d04:	003f7906 	br	122aec <__alt_data_end+0xfffef26c>
  122d08:	e009883a 	mov	r4,fp
  122d0c:	01400284 	movi	r5,10
  122d10:	900d883a 	mov	r6,r18
  122d14:	0122eb80 	call	122eb8 <memchr>
  122d18:	10003826 	beq	r2,zero,122dfc <__sfvwrite_r+0x498>
  122d1c:	10800044 	addi	r2,r2,1
  122d20:	1729c83a 	sub	r20,r2,fp
  122d24:	02000044 	movi	r8,1
  122d28:	003f8f06 	br	122b68 <__alt_data_end+0xfffef2e8>
  122d2c:	80800517 	ldw	r2,20(r16)
  122d30:	81400417 	ldw	r5,16(r16)
  122d34:	87000017 	ldw	fp,0(r16)
  122d38:	10a9883a 	add	r20,r2,r2
  122d3c:	a085883a 	add	r2,r20,r2
  122d40:	1028d7fa 	srli	r20,r2,31
  122d44:	e179c83a 	sub	fp,fp,r5
  122d48:	e1000044 	addi	r4,fp,1
  122d4c:	a085883a 	add	r2,r20,r2
  122d50:	1029d07a 	srai	r20,r2,1
  122d54:	2485883a 	add	r2,r4,r18
  122d58:	a00d883a 	mov	r6,r20
  122d5c:	a080022e 	bgeu	r20,r2,122d68 <__sfvwrite_r+0x404>
  122d60:	1029883a 	mov	r20,r2
  122d64:	100d883a 	mov	r6,r2
  122d68:	18c1000c 	andi	r3,r3,1024
  122d6c:	a809883a 	mov	r4,r21
  122d70:	183f6a26 	beq	r3,zero,122b1c <__alt_data_end+0xfffef29c>
  122d74:	300b883a 	mov	r5,r6
  122d78:	0121a3c0 	call	121a3c <_malloc_r>
  122d7c:	102d883a 	mov	r22,r2
  122d80:	103f6c26 	beq	r2,zero,122b34 <__alt_data_end+0xfffef2b4>
  122d84:	81400417 	ldw	r5,16(r16)
  122d88:	1009883a 	mov	r4,r2
  122d8c:	e00d883a 	mov	r6,fp
  122d90:	0122fa00 	call	122fa0 <memcpy>
  122d94:	8080030b 	ldhu	r2,12(r16)
  122d98:	00fedfc4 	movi	r3,-1153
  122d9c:	10c4703a 	and	r2,r2,r3
  122da0:	10802014 	ori	r2,r2,128
  122da4:	8080030d 	sth	r2,12(r16)
  122da8:	b709883a 	add	r4,r22,fp
  122dac:	a707c83a 	sub	r3,r20,fp
  122db0:	85800415 	stw	r22,16(r16)
  122db4:	85000515 	stw	r20,20(r16)
  122db8:	81000015 	stw	r4,0(r16)
  122dbc:	9039883a 	mov	fp,r18
  122dc0:	80c00215 	stw	r3,8(r16)
  122dc4:	9029883a 	mov	r20,r18
  122dc8:	902d883a 	mov	r22,r18
  122dcc:	003f3d06 	br	122ac4 <__alt_data_end+0xfffef244>
  122dd0:	b80b883a 	mov	r5,r23
  122dd4:	a00d883a 	mov	r6,r20
  122dd8:	01230d80 	call	1230d8 <memmove>
  122ddc:	80800017 	ldw	r2,0(r16)
  122de0:	a809883a 	mov	r4,r21
  122de4:	800b883a 	mov	r5,r16
  122de8:	1505883a 	add	r2,r2,r20
  122dec:	80800015 	stw	r2,0(r16)
  122df0:	012072c0 	call	12072c <_fflush_r>
  122df4:	103fa526 	beq	r2,zero,122c8c <__alt_data_end+0xfffef40c>
  122df8:	003f5006 	br	122b3c <__alt_data_end+0xfffef2bc>
  122dfc:	95000044 	addi	r20,r18,1
  122e00:	02000044 	movi	r8,1
  122e04:	003f5806 	br	122b68 <__alt_data_end+0xfffef2e8>

00122e08 <_isatty_r>:
  122e08:	defffd04 	addi	sp,sp,-12
  122e0c:	dc000015 	stw	r16,0(sp)
  122e10:	040004f4 	movhi	r16,19
  122e14:	dc400115 	stw	r17,4(sp)
  122e18:	842bdd04 	addi	r16,r16,-20620
  122e1c:	2023883a 	mov	r17,r4
  122e20:	2809883a 	mov	r4,r5
  122e24:	dfc00215 	stw	ra,8(sp)
  122e28:	80000015 	stw	zero,0(r16)
  122e2c:	0123bfc0 	call	123bfc <isatty>
  122e30:	00ffffc4 	movi	r3,-1
  122e34:	10c00526 	beq	r2,r3,122e4c <_isatty_r+0x44>
  122e38:	dfc00217 	ldw	ra,8(sp)
  122e3c:	dc400117 	ldw	r17,4(sp)
  122e40:	dc000017 	ldw	r16,0(sp)
  122e44:	dec00304 	addi	sp,sp,12
  122e48:	f800283a 	ret
  122e4c:	80c00017 	ldw	r3,0(r16)
  122e50:	183ff926 	beq	r3,zero,122e38 <__alt_data_end+0xfffef5b8>
  122e54:	88c00015 	stw	r3,0(r17)
  122e58:	003ff706 	br	122e38 <__alt_data_end+0xfffef5b8>

00122e5c <_lseek_r>:
  122e5c:	defffd04 	addi	sp,sp,-12
  122e60:	dc000015 	stw	r16,0(sp)
  122e64:	040004f4 	movhi	r16,19
  122e68:	dc400115 	stw	r17,4(sp)
  122e6c:	842bdd04 	addi	r16,r16,-20620
  122e70:	2023883a 	mov	r17,r4
  122e74:	2809883a 	mov	r4,r5
  122e78:	300b883a 	mov	r5,r6
  122e7c:	380d883a 	mov	r6,r7
  122e80:	dfc00215 	stw	ra,8(sp)
  122e84:	80000015 	stw	zero,0(r16)
  122e88:	0123dd40 	call	123dd4 <lseek>
  122e8c:	00ffffc4 	movi	r3,-1
  122e90:	10c00526 	beq	r2,r3,122ea8 <_lseek_r+0x4c>
  122e94:	dfc00217 	ldw	ra,8(sp)
  122e98:	dc400117 	ldw	r17,4(sp)
  122e9c:	dc000017 	ldw	r16,0(sp)
  122ea0:	dec00304 	addi	sp,sp,12
  122ea4:	f800283a 	ret
  122ea8:	80c00017 	ldw	r3,0(r16)
  122eac:	183ff926 	beq	r3,zero,122e94 <__alt_data_end+0xfffef614>
  122eb0:	88c00015 	stw	r3,0(r17)
  122eb4:	003ff706 	br	122e94 <__alt_data_end+0xfffef614>

00122eb8 <memchr>:
  122eb8:	208000cc 	andi	r2,r4,3
  122ebc:	280f883a 	mov	r7,r5
  122ec0:	10003526 	beq	r2,zero,122f98 <memchr+0xe0>
  122ec4:	30bfffc4 	addi	r2,r6,-1
  122ec8:	30001b26 	beq	r6,zero,122f38 <memchr+0x80>
  122ecc:	21800003 	ldbu	r6,0(r4)
  122ed0:	28c03fcc 	andi	r3,r5,255
  122ed4:	30c01a26 	beq	r6,r3,122f40 <memchr+0x88>
  122ed8:	180d883a 	mov	r6,r3
  122edc:	00000406 	br	122ef0 <memchr+0x38>
  122ee0:	10001526 	beq	r2,zero,122f38 <memchr+0x80>
  122ee4:	20c00003 	ldbu	r3,0(r4)
  122ee8:	10bfffc4 	addi	r2,r2,-1
  122eec:	19801426 	beq	r3,r6,122f40 <memchr+0x88>
  122ef0:	21000044 	addi	r4,r4,1
  122ef4:	20c000cc 	andi	r3,r4,3
  122ef8:	183ff91e 	bne	r3,zero,122ee0 <__alt_data_end+0xfffef660>
  122efc:	024000c4 	movi	r9,3
  122f00:	48801136 	bltu	r9,r2,122f48 <memchr+0x90>
  122f04:	10000c26 	beq	r2,zero,122f38 <memchr+0x80>
  122f08:	20c00003 	ldbu	r3,0(r4)
  122f0c:	29403fcc 	andi	r5,r5,255
  122f10:	19400b26 	beq	r3,r5,122f40 <memchr+0x88>
  122f14:	20c00044 	addi	r3,r4,1
  122f18:	2085883a 	add	r2,r4,r2
  122f1c:	39803fcc 	andi	r6,r7,255
  122f20:	00000306 	br	122f30 <memchr+0x78>
  122f24:	18c00044 	addi	r3,r3,1
  122f28:	197fffc3 	ldbu	r5,-1(r3)
  122f2c:	29800426 	beq	r5,r6,122f40 <memchr+0x88>
  122f30:	1809883a 	mov	r4,r3
  122f34:	18bffb1e 	bne	r3,r2,122f24 <__alt_data_end+0xfffef6a4>
  122f38:	0005883a 	mov	r2,zero
  122f3c:	f800283a 	ret
  122f40:	2005883a 	mov	r2,r4
  122f44:	f800283a 	ret
  122f48:	28c03fcc 	andi	r3,r5,255
  122f4c:	1810923a 	slli	r8,r3,8
  122f50:	02ffbff4 	movhi	r11,65279
  122f54:	02a02074 	movhi	r10,32897
  122f58:	40c6b03a 	or	r3,r8,r3
  122f5c:	1810943a 	slli	r8,r3,16
  122f60:	5affbfc4 	addi	r11,r11,-257
  122f64:	52a02004 	addi	r10,r10,-32640
  122f68:	40d0b03a 	or	r8,r8,r3
  122f6c:	20c00017 	ldw	r3,0(r4)
  122f70:	40c6f03a 	xor	r3,r8,r3
  122f74:	1acd883a 	add	r6,r3,r11
  122f78:	00c6303a 	nor	r3,zero,r3
  122f7c:	30c6703a 	and	r3,r6,r3
  122f80:	1a86703a 	and	r3,r3,r10
  122f84:	183fdf1e 	bne	r3,zero,122f04 <__alt_data_end+0xfffef684>
  122f88:	10bfff04 	addi	r2,r2,-4
  122f8c:	21000104 	addi	r4,r4,4
  122f90:	48bff636 	bltu	r9,r2,122f6c <__alt_data_end+0xfffef6ec>
  122f94:	003fdb06 	br	122f04 <__alt_data_end+0xfffef684>
  122f98:	3005883a 	mov	r2,r6
  122f9c:	003fd706 	br	122efc <__alt_data_end+0xfffef67c>

00122fa0 <memcpy>:
  122fa0:	deffff04 	addi	sp,sp,-4
  122fa4:	dc000015 	stw	r16,0(sp)
  122fa8:	00c003c4 	movi	r3,15
  122fac:	2005883a 	mov	r2,r4
  122fb0:	1980432e 	bgeu	r3,r6,1230c0 <memcpy+0x120>
  122fb4:	2146b03a 	or	r3,r4,r5
  122fb8:	18c000cc 	andi	r3,r3,3
  122fbc:	1800421e 	bne	r3,zero,1230c8 <memcpy+0x128>
  122fc0:	343ffc04 	addi	r16,r6,-16
  122fc4:	8020d13a 	srli	r16,r16,4
  122fc8:	28c00104 	addi	r3,r5,4
  122fcc:	23400104 	addi	r13,r4,4
  122fd0:	801e913a 	slli	r15,r16,4
  122fd4:	2b000204 	addi	r12,r5,8
  122fd8:	22c00204 	addi	r11,r4,8
  122fdc:	7bc00504 	addi	r15,r15,20
  122fe0:	2a800304 	addi	r10,r5,12
  122fe4:	22400304 	addi	r9,r4,12
  122fe8:	2bdf883a 	add	r15,r5,r15
  122fec:	2811883a 	mov	r8,r5
  122ff0:	200f883a 	mov	r7,r4
  122ff4:	41000017 	ldw	r4,0(r8)
  122ff8:	39c00404 	addi	r7,r7,16
  122ffc:	18c00404 	addi	r3,r3,16
  123000:	393ffc15 	stw	r4,-16(r7)
  123004:	1bbffc17 	ldw	r14,-16(r3)
  123008:	6b400404 	addi	r13,r13,16
  12300c:	5ac00404 	addi	r11,r11,16
  123010:	6bbffc15 	stw	r14,-16(r13)
  123014:	63800017 	ldw	r14,0(r12)
  123018:	4a400404 	addi	r9,r9,16
  12301c:	42000404 	addi	r8,r8,16
  123020:	5bbffc15 	stw	r14,-16(r11)
  123024:	53800017 	ldw	r14,0(r10)
  123028:	63000404 	addi	r12,r12,16
  12302c:	52800404 	addi	r10,r10,16
  123030:	4bbffc15 	stw	r14,-16(r9)
  123034:	1bffef1e 	bne	r3,r15,122ff4 <__alt_data_end+0xfffef774>
  123038:	81c00044 	addi	r7,r16,1
  12303c:	380e913a 	slli	r7,r7,4
  123040:	310003cc 	andi	r4,r6,15
  123044:	02c000c4 	movi	r11,3
  123048:	11c7883a 	add	r3,r2,r7
  12304c:	29cb883a 	add	r5,r5,r7
  123050:	59001f2e 	bgeu	r11,r4,1230d0 <memcpy+0x130>
  123054:	1813883a 	mov	r9,r3
  123058:	2811883a 	mov	r8,r5
  12305c:	200f883a 	mov	r7,r4
  123060:	42800017 	ldw	r10,0(r8)
  123064:	4a400104 	addi	r9,r9,4
  123068:	39ffff04 	addi	r7,r7,-4
  12306c:	4abfff15 	stw	r10,-4(r9)
  123070:	42000104 	addi	r8,r8,4
  123074:	59fffa36 	bltu	r11,r7,123060 <__alt_data_end+0xfffef7e0>
  123078:	213fff04 	addi	r4,r4,-4
  12307c:	2008d0ba 	srli	r4,r4,2
  123080:	318000cc 	andi	r6,r6,3
  123084:	21000044 	addi	r4,r4,1
  123088:	2109883a 	add	r4,r4,r4
  12308c:	2109883a 	add	r4,r4,r4
  123090:	1907883a 	add	r3,r3,r4
  123094:	290b883a 	add	r5,r5,r4
  123098:	30000626 	beq	r6,zero,1230b4 <memcpy+0x114>
  12309c:	198d883a 	add	r6,r3,r6
  1230a0:	29c00003 	ldbu	r7,0(r5)
  1230a4:	18c00044 	addi	r3,r3,1
  1230a8:	29400044 	addi	r5,r5,1
  1230ac:	19ffffc5 	stb	r7,-1(r3)
  1230b0:	19bffb1e 	bne	r3,r6,1230a0 <__alt_data_end+0xfffef820>
  1230b4:	dc000017 	ldw	r16,0(sp)
  1230b8:	dec00104 	addi	sp,sp,4
  1230bc:	f800283a 	ret
  1230c0:	2007883a 	mov	r3,r4
  1230c4:	003ff406 	br	123098 <__alt_data_end+0xfffef818>
  1230c8:	2007883a 	mov	r3,r4
  1230cc:	003ff306 	br	12309c <__alt_data_end+0xfffef81c>
  1230d0:	200d883a 	mov	r6,r4
  1230d4:	003ff006 	br	123098 <__alt_data_end+0xfffef818>

001230d8 <memmove>:
  1230d8:	2005883a 	mov	r2,r4
  1230dc:	29000b2e 	bgeu	r5,r4,12310c <memmove+0x34>
  1230e0:	298f883a 	add	r7,r5,r6
  1230e4:	21c0092e 	bgeu	r4,r7,12310c <memmove+0x34>
  1230e8:	2187883a 	add	r3,r4,r6
  1230ec:	198bc83a 	sub	r5,r3,r6
  1230f0:	30004b26 	beq	r6,zero,123220 <memmove+0x148>
  1230f4:	39ffffc4 	addi	r7,r7,-1
  1230f8:	39000003 	ldbu	r4,0(r7)
  1230fc:	18ffffc4 	addi	r3,r3,-1
  123100:	19000005 	stb	r4,0(r3)
  123104:	197ffb1e 	bne	r3,r5,1230f4 <__alt_data_end+0xfffef874>
  123108:	f800283a 	ret
  12310c:	00c003c4 	movi	r3,15
  123110:	1980412e 	bgeu	r3,r6,123218 <memmove+0x140>
  123114:	1146b03a 	or	r3,r2,r5
  123118:	18c000cc 	andi	r3,r3,3
  12311c:	1800411e 	bne	r3,zero,123224 <memmove+0x14c>
  123120:	33fffc04 	addi	r15,r6,-16
  123124:	781ed13a 	srli	r15,r15,4
  123128:	28c00104 	addi	r3,r5,4
  12312c:	13400104 	addi	r13,r2,4
  123130:	781c913a 	slli	r14,r15,4
  123134:	2b000204 	addi	r12,r5,8
  123138:	12c00204 	addi	r11,r2,8
  12313c:	73800504 	addi	r14,r14,20
  123140:	2a800304 	addi	r10,r5,12
  123144:	12400304 	addi	r9,r2,12
  123148:	2b9d883a 	add	r14,r5,r14
  12314c:	2811883a 	mov	r8,r5
  123150:	100f883a 	mov	r7,r2
  123154:	41000017 	ldw	r4,0(r8)
  123158:	39c00404 	addi	r7,r7,16
  12315c:	18c00404 	addi	r3,r3,16
  123160:	393ffc15 	stw	r4,-16(r7)
  123164:	193ffc17 	ldw	r4,-16(r3)
  123168:	6b400404 	addi	r13,r13,16
  12316c:	5ac00404 	addi	r11,r11,16
  123170:	693ffc15 	stw	r4,-16(r13)
  123174:	61000017 	ldw	r4,0(r12)
  123178:	4a400404 	addi	r9,r9,16
  12317c:	42000404 	addi	r8,r8,16
  123180:	593ffc15 	stw	r4,-16(r11)
  123184:	51000017 	ldw	r4,0(r10)
  123188:	63000404 	addi	r12,r12,16
  12318c:	52800404 	addi	r10,r10,16
  123190:	493ffc15 	stw	r4,-16(r9)
  123194:	1bbfef1e 	bne	r3,r14,123154 <__alt_data_end+0xfffef8d4>
  123198:	79000044 	addi	r4,r15,1
  12319c:	2008913a 	slli	r4,r4,4
  1231a0:	328003cc 	andi	r10,r6,15
  1231a4:	02c000c4 	movi	r11,3
  1231a8:	1107883a 	add	r3,r2,r4
  1231ac:	290b883a 	add	r5,r5,r4
  1231b0:	5a801e2e 	bgeu	r11,r10,12322c <memmove+0x154>
  1231b4:	1813883a 	mov	r9,r3
  1231b8:	2811883a 	mov	r8,r5
  1231bc:	500f883a 	mov	r7,r10
  1231c0:	41000017 	ldw	r4,0(r8)
  1231c4:	4a400104 	addi	r9,r9,4
  1231c8:	39ffff04 	addi	r7,r7,-4
  1231cc:	493fff15 	stw	r4,-4(r9)
  1231d0:	42000104 	addi	r8,r8,4
  1231d4:	59fffa36 	bltu	r11,r7,1231c0 <__alt_data_end+0xfffef940>
  1231d8:	513fff04 	addi	r4,r10,-4
  1231dc:	2008d0ba 	srli	r4,r4,2
  1231e0:	318000cc 	andi	r6,r6,3
  1231e4:	21000044 	addi	r4,r4,1
  1231e8:	2109883a 	add	r4,r4,r4
  1231ec:	2109883a 	add	r4,r4,r4
  1231f0:	1907883a 	add	r3,r3,r4
  1231f4:	290b883a 	add	r5,r5,r4
  1231f8:	30000926 	beq	r6,zero,123220 <memmove+0x148>
  1231fc:	198d883a 	add	r6,r3,r6
  123200:	29c00003 	ldbu	r7,0(r5)
  123204:	18c00044 	addi	r3,r3,1
  123208:	29400044 	addi	r5,r5,1
  12320c:	19ffffc5 	stb	r7,-1(r3)
  123210:	19bffb1e 	bne	r3,r6,123200 <__alt_data_end+0xfffef980>
  123214:	f800283a 	ret
  123218:	1007883a 	mov	r3,r2
  12321c:	003ff606 	br	1231f8 <__alt_data_end+0xfffef978>
  123220:	f800283a 	ret
  123224:	1007883a 	mov	r3,r2
  123228:	003ff406 	br	1231fc <__alt_data_end+0xfffef97c>
  12322c:	500d883a 	mov	r6,r10
  123230:	003ff106 	br	1231f8 <__alt_data_end+0xfffef978>

00123234 <_read_r>:
  123234:	defffd04 	addi	sp,sp,-12
  123238:	dc000015 	stw	r16,0(sp)
  12323c:	040004f4 	movhi	r16,19
  123240:	dc400115 	stw	r17,4(sp)
  123244:	842bdd04 	addi	r16,r16,-20620
  123248:	2023883a 	mov	r17,r4
  12324c:	2809883a 	mov	r4,r5
  123250:	300b883a 	mov	r5,r6
  123254:	380d883a 	mov	r6,r7
  123258:	dfc00215 	stw	ra,8(sp)
  12325c:	80000015 	stw	zero,0(r16)
  123260:	01244900 	call	124490 <read>
  123264:	00ffffc4 	movi	r3,-1
  123268:	10c00526 	beq	r2,r3,123280 <_read_r+0x4c>
  12326c:	dfc00217 	ldw	ra,8(sp)
  123270:	dc400117 	ldw	r17,4(sp)
  123274:	dc000017 	ldw	r16,0(sp)
  123278:	dec00304 	addi	sp,sp,12
  12327c:	f800283a 	ret
  123280:	80c00017 	ldw	r3,0(r16)
  123284:	183ff926 	beq	r3,zero,12326c <__alt_data_end+0xfffef9ec>
  123288:	88c00015 	stw	r3,0(r17)
  12328c:	003ff706 	br	12326c <__alt_data_end+0xfffef9ec>

00123290 <_realloc_r>:
  123290:	defff604 	addi	sp,sp,-40
  123294:	dcc00315 	stw	r19,12(sp)
  123298:	dc400115 	stw	r17,4(sp)
  12329c:	dfc00915 	stw	ra,36(sp)
  1232a0:	df000815 	stw	fp,32(sp)
  1232a4:	ddc00715 	stw	r23,28(sp)
  1232a8:	dd800615 	stw	r22,24(sp)
  1232ac:	dd400515 	stw	r21,20(sp)
  1232b0:	dd000415 	stw	r20,16(sp)
  1232b4:	dc800215 	stw	r18,8(sp)
  1232b8:	dc000015 	stw	r16,0(sp)
  1232bc:	2827883a 	mov	r19,r5
  1232c0:	3023883a 	mov	r17,r6
  1232c4:	2800bf26 	beq	r5,zero,1235c4 <_realloc_r+0x334>
  1232c8:	2025883a 	mov	r18,r4
  1232cc:	0123f200 	call	123f20 <__malloc_lock>
  1232d0:	98ffff17 	ldw	r3,-4(r19)
  1232d4:	01bfff04 	movi	r6,-4
  1232d8:	890002c4 	addi	r4,r17,11
  1232dc:	01c00584 	movi	r7,22
  1232e0:	9d7ffe04 	addi	r21,r19,-8
  1232e4:	19a0703a 	and	r16,r3,r6
  1232e8:	39003f2e 	bgeu	r7,r4,1233e8 <_realloc_r+0x158>
  1232ec:	053ffe04 	movi	r20,-8
  1232f0:	2528703a 	and	r20,r4,r20
  1232f4:	a00f883a 	mov	r7,r20
  1232f8:	a0008216 	blt	r20,zero,123504 <_realloc_r+0x274>
  1232fc:	a4408136 	bltu	r20,r17,123504 <_realloc_r+0x274>
  123300:	81c03c0e 	bge	r16,r7,1233f4 <_realloc_r+0x164>
  123304:	070004b4 	movhi	fp,18
  123308:	e71f1e04 	addi	fp,fp,31864
  12330c:	e1000217 	ldw	r4,8(fp)
  123310:	ac05883a 	add	r2,r21,r16
  123314:	2080bf26 	beq	r4,r2,123614 <_realloc_r+0x384>
  123318:	11000117 	ldw	r4,4(r2)
  12331c:	023fff84 	movi	r8,-2
  123320:	2210703a 	and	r8,r4,r8
  123324:	1211883a 	add	r8,r2,r8
  123328:	41400117 	ldw	r5,4(r8)
  12332c:	2940004c 	andi	r5,r5,1
  123330:	28004a1e 	bne	r5,zero,12345c <_realloc_r+0x1cc>
  123334:	017fff04 	movi	r5,-4
  123338:	2148703a 	and	r4,r4,r5
  12333c:	2409883a 	add	r4,r4,r16
  123340:	21c0ad0e 	bge	r4,r7,1235f8 <_realloc_r+0x368>
  123344:	18c0004c 	andi	r3,r3,1
  123348:	18007f1e 	bne	r3,zero,123548 <_realloc_r+0x2b8>
  12334c:	9dfffe17 	ldw	r23,-8(r19)
  123350:	adefc83a 	sub	r23,r21,r23
  123354:	bd800117 	ldw	r22,4(r23)
  123358:	b14a703a 	and	r5,r22,r5
  12335c:	216d883a 	add	r22,r4,r5
  123360:	b1c04516 	blt	r22,r7,123478 <_realloc_r+0x1e8>
  123364:	10c00317 	ldw	r3,12(r2)
  123368:	10800217 	ldw	r2,8(r2)
  12336c:	81bfff04 	addi	r6,r16,-4
  123370:	bc400204 	addi	r17,r23,8
  123374:	10c00315 	stw	r3,12(r2)
  123378:	18800215 	stw	r2,8(r3)
  12337c:	b9400217 	ldw	r5,8(r23)
  123380:	b8c00317 	ldw	r3,12(r23)
  123384:	00800904 	movi	r2,36
  123388:	28c00315 	stw	r3,12(r5)
  12338c:	19400215 	stw	r5,8(r3)
  123390:	1180ef36 	bltu	r2,r6,123750 <_realloc_r+0x4c0>
  123394:	008004c4 	movi	r2,19
  123398:	1180da2e 	bgeu	r2,r6,123704 <_realloc_r+0x474>
  12339c:	98800017 	ldw	r2,0(r19)
  1233a0:	b8800215 	stw	r2,8(r23)
  1233a4:	98800117 	ldw	r2,4(r19)
  1233a8:	b8800315 	stw	r2,12(r23)
  1233ac:	008006c4 	movi	r2,27
  1233b0:	1180fc2e 	bgeu	r2,r6,1237a4 <_realloc_r+0x514>
  1233b4:	98800217 	ldw	r2,8(r19)
  1233b8:	b8800415 	stw	r2,16(r23)
  1233bc:	98800317 	ldw	r2,12(r19)
  1233c0:	b8800515 	stw	r2,20(r23)
  1233c4:	00800904 	movi	r2,36
  1233c8:	3080421e 	bne	r6,r2,1234d4 <_realloc_r+0x244>
  1233cc:	98800417 	ldw	r2,16(r19)
  1233d0:	9cc00604 	addi	r19,r19,24
  1233d4:	b8c00804 	addi	r3,r23,32
  1233d8:	b8800615 	stw	r2,24(r23)
  1233dc:	98bfff17 	ldw	r2,-4(r19)
  1233e0:	b8800715 	stw	r2,28(r23)
  1233e4:	00003d06 	br	1234dc <_realloc_r+0x24c>
  1233e8:	01c00404 	movi	r7,16
  1233ec:	3829883a 	mov	r20,r7
  1233f0:	003fc206 	br	1232fc <__alt_data_end+0xfffefa7c>
  1233f4:	9823883a 	mov	r17,r19
  1233f8:	850fc83a 	sub	r7,r16,r20
  1233fc:	008003c4 	movi	r2,15
  123400:	18c0004c 	andi	r3,r3,1
  123404:	11c04336 	bltu	r2,r7,123514 <_realloc_r+0x284>
  123408:	1c06b03a 	or	r3,r3,r16
  12340c:	a8c00115 	stw	r3,4(r21)
  123410:	ac21883a 	add	r16,r21,r16
  123414:	80c00117 	ldw	r3,4(r16)
  123418:	18c00054 	ori	r3,r3,1
  12341c:	80c00115 	stw	r3,4(r16)
  123420:	9009883a 	mov	r4,r18
  123424:	0123f400 	call	123f40 <__malloc_unlock>
  123428:	8805883a 	mov	r2,r17
  12342c:	dfc00917 	ldw	ra,36(sp)
  123430:	df000817 	ldw	fp,32(sp)
  123434:	ddc00717 	ldw	r23,28(sp)
  123438:	dd800617 	ldw	r22,24(sp)
  12343c:	dd400517 	ldw	r21,20(sp)
  123440:	dd000417 	ldw	r20,16(sp)
  123444:	dcc00317 	ldw	r19,12(sp)
  123448:	dc800217 	ldw	r18,8(sp)
  12344c:	dc400117 	ldw	r17,4(sp)
  123450:	dc000017 	ldw	r16,0(sp)
  123454:	dec00a04 	addi	sp,sp,40
  123458:	f800283a 	ret
  12345c:	18c0004c 	andi	r3,r3,1
  123460:	1800391e 	bne	r3,zero,123548 <_realloc_r+0x2b8>
  123464:	9dfffe17 	ldw	r23,-8(r19)
  123468:	00bfff04 	movi	r2,-4
  12346c:	adefc83a 	sub	r23,r21,r23
  123470:	b9400117 	ldw	r5,4(r23)
  123474:	288a703a 	and	r5,r5,r2
  123478:	2c2d883a 	add	r22,r5,r16
  12347c:	b1c03216 	blt	r22,r7,123548 <_realloc_r+0x2b8>
  123480:	b8800317 	ldw	r2,12(r23)
  123484:	b8c00217 	ldw	r3,8(r23)
  123488:	81bfff04 	addi	r6,r16,-4
  12348c:	01000904 	movi	r4,36
  123490:	18800315 	stw	r2,12(r3)
  123494:	10c00215 	stw	r3,8(r2)
  123498:	bc400204 	addi	r17,r23,8
  12349c:	2180ac36 	bltu	r4,r6,123750 <_realloc_r+0x4c0>
  1234a0:	008004c4 	movi	r2,19
  1234a4:	1180972e 	bgeu	r2,r6,123704 <_realloc_r+0x474>
  1234a8:	98800017 	ldw	r2,0(r19)
  1234ac:	b8800215 	stw	r2,8(r23)
  1234b0:	98800117 	ldw	r2,4(r19)
  1234b4:	b8800315 	stw	r2,12(r23)
  1234b8:	008006c4 	movi	r2,27
  1234bc:	1180b92e 	bgeu	r2,r6,1237a4 <_realloc_r+0x514>
  1234c0:	98800217 	ldw	r2,8(r19)
  1234c4:	b8800415 	stw	r2,16(r23)
  1234c8:	98800317 	ldw	r2,12(r19)
  1234cc:	b8800515 	stw	r2,20(r23)
  1234d0:	313fbe26 	beq	r6,r4,1233cc <__alt_data_end+0xfffefb4c>
  1234d4:	b8c00604 	addi	r3,r23,24
  1234d8:	9cc00404 	addi	r19,r19,16
  1234dc:	98800017 	ldw	r2,0(r19)
  1234e0:	b021883a 	mov	r16,r22
  1234e4:	b82b883a 	mov	r21,r23
  1234e8:	18800015 	stw	r2,0(r3)
  1234ec:	98800117 	ldw	r2,4(r19)
  1234f0:	18800115 	stw	r2,4(r3)
  1234f4:	98800217 	ldw	r2,8(r19)
  1234f8:	18800215 	stw	r2,8(r3)
  1234fc:	b8c00117 	ldw	r3,4(r23)
  123500:	003fbd06 	br	1233f8 <__alt_data_end+0xfffefb78>
  123504:	00800304 	movi	r2,12
  123508:	90800015 	stw	r2,0(r18)
  12350c:	0005883a 	mov	r2,zero
  123510:	003fc606 	br	12342c <__alt_data_end+0xfffefbac>
  123514:	1d06b03a 	or	r3,r3,r20
  123518:	ad0b883a 	add	r5,r21,r20
  12351c:	a8c00115 	stw	r3,4(r21)
  123520:	38800054 	ori	r2,r7,1
  123524:	28800115 	stw	r2,4(r5)
  123528:	29cf883a 	add	r7,r5,r7
  12352c:	38800117 	ldw	r2,4(r7)
  123530:	9009883a 	mov	r4,r18
  123534:	29400204 	addi	r5,r5,8
  123538:	10800054 	ori	r2,r2,1
  12353c:	38800115 	stw	r2,4(r7)
  123540:	0120f540 	call	120f54 <_free_r>
  123544:	003fb606 	br	123420 <__alt_data_end+0xfffefba0>
  123548:	880b883a 	mov	r5,r17
  12354c:	9009883a 	mov	r4,r18
  123550:	0121a3c0 	call	121a3c <_malloc_r>
  123554:	1023883a 	mov	r17,r2
  123558:	1000aa26 	beq	r2,zero,123804 <_realloc_r+0x574>
  12355c:	98ffff17 	ldw	r3,-4(r19)
  123560:	113ffe04 	addi	r4,r2,-8
  123564:	00bfff84 	movi	r2,-2
  123568:	1884703a 	and	r2,r3,r2
  12356c:	a885883a 	add	r2,r21,r2
  123570:	20808626 	beq	r4,r2,12378c <_realloc_r+0x4fc>
  123574:	81bfff04 	addi	r6,r16,-4
  123578:	00800904 	movi	r2,36
  12357c:	11807036 	bltu	r2,r6,123740 <_realloc_r+0x4b0>
  123580:	00c004c4 	movi	r3,19
  123584:	19805636 	bltu	r3,r6,1236e0 <_realloc_r+0x450>
  123588:	8805883a 	mov	r2,r17
  12358c:	9807883a 	mov	r3,r19
  123590:	19000017 	ldw	r4,0(r3)
  123594:	11000015 	stw	r4,0(r2)
  123598:	19000117 	ldw	r4,4(r3)
  12359c:	11000115 	stw	r4,4(r2)
  1235a0:	18c00217 	ldw	r3,8(r3)
  1235a4:	10c00215 	stw	r3,8(r2)
  1235a8:	980b883a 	mov	r5,r19
  1235ac:	9009883a 	mov	r4,r18
  1235b0:	0120f540 	call	120f54 <_free_r>
  1235b4:	9009883a 	mov	r4,r18
  1235b8:	0123f400 	call	123f40 <__malloc_unlock>
  1235bc:	8805883a 	mov	r2,r17
  1235c0:	003f9a06 	br	12342c <__alt_data_end+0xfffefbac>
  1235c4:	300b883a 	mov	r5,r6
  1235c8:	dfc00917 	ldw	ra,36(sp)
  1235cc:	df000817 	ldw	fp,32(sp)
  1235d0:	ddc00717 	ldw	r23,28(sp)
  1235d4:	dd800617 	ldw	r22,24(sp)
  1235d8:	dd400517 	ldw	r21,20(sp)
  1235dc:	dd000417 	ldw	r20,16(sp)
  1235e0:	dcc00317 	ldw	r19,12(sp)
  1235e4:	dc800217 	ldw	r18,8(sp)
  1235e8:	dc400117 	ldw	r17,4(sp)
  1235ec:	dc000017 	ldw	r16,0(sp)
  1235f0:	dec00a04 	addi	sp,sp,40
  1235f4:	0121a3c1 	jmpi	121a3c <_malloc_r>
  1235f8:	11400317 	ldw	r5,12(r2)
  1235fc:	10800217 	ldw	r2,8(r2)
  123600:	9823883a 	mov	r17,r19
  123604:	2021883a 	mov	r16,r4
  123608:	11400315 	stw	r5,12(r2)
  12360c:	28800215 	stw	r2,8(r5)
  123610:	003f7906 	br	1233f8 <__alt_data_end+0xfffefb78>
  123614:	21000117 	ldw	r4,4(r4)
  123618:	00bfff04 	movi	r2,-4
  12361c:	a1800404 	addi	r6,r20,16
  123620:	2088703a 	and	r4,r4,r2
  123624:	2409883a 	add	r4,r4,r16
  123628:	2180380e 	bge	r4,r6,12370c <_realloc_r+0x47c>
  12362c:	18c0004c 	andi	r3,r3,1
  123630:	183fc51e 	bne	r3,zero,123548 <__alt_data_end+0xfffefcc8>
  123634:	9dfffe17 	ldw	r23,-8(r19)
  123638:	adefc83a 	sub	r23,r21,r23
  12363c:	b9400117 	ldw	r5,4(r23)
  123640:	288a703a 	and	r5,r5,r2
  123644:	216d883a 	add	r22,r4,r5
  123648:	b1bf8b16 	blt	r22,r6,123478 <__alt_data_end+0xfffefbf8>
  12364c:	b8800317 	ldw	r2,12(r23)
  123650:	b8c00217 	ldw	r3,8(r23)
  123654:	81bfff04 	addi	r6,r16,-4
  123658:	01000904 	movi	r4,36
  12365c:	18800315 	stw	r2,12(r3)
  123660:	10c00215 	stw	r3,8(r2)
  123664:	bc400204 	addi	r17,r23,8
  123668:	21805a36 	bltu	r4,r6,1237d4 <_realloc_r+0x544>
  12366c:	008004c4 	movi	r2,19
  123670:	1180562e 	bgeu	r2,r6,1237cc <_realloc_r+0x53c>
  123674:	98800017 	ldw	r2,0(r19)
  123678:	b8800215 	stw	r2,8(r23)
  12367c:	98800117 	ldw	r2,4(r19)
  123680:	b8800315 	stw	r2,12(r23)
  123684:	008006c4 	movi	r2,27
  123688:	11805636 	bltu	r2,r6,1237e4 <_realloc_r+0x554>
  12368c:	b8800404 	addi	r2,r23,16
  123690:	9cc00204 	addi	r19,r19,8
  123694:	98c00017 	ldw	r3,0(r19)
  123698:	10c00015 	stw	r3,0(r2)
  12369c:	98c00117 	ldw	r3,4(r19)
  1236a0:	10c00115 	stw	r3,4(r2)
  1236a4:	98c00217 	ldw	r3,8(r19)
  1236a8:	10c00215 	stw	r3,8(r2)
  1236ac:	bd07883a 	add	r3,r23,r20
  1236b0:	b505c83a 	sub	r2,r22,r20
  1236b4:	e0c00215 	stw	r3,8(fp)
  1236b8:	10800054 	ori	r2,r2,1
  1236bc:	18800115 	stw	r2,4(r3)
  1236c0:	b8800117 	ldw	r2,4(r23)
  1236c4:	9009883a 	mov	r4,r18
  1236c8:	1080004c 	andi	r2,r2,1
  1236cc:	a0a8b03a 	or	r20,r20,r2
  1236d0:	bd000115 	stw	r20,4(r23)
  1236d4:	0123f400 	call	123f40 <__malloc_unlock>
  1236d8:	8805883a 	mov	r2,r17
  1236dc:	003f5306 	br	12342c <__alt_data_end+0xfffefbac>
  1236e0:	98c00017 	ldw	r3,0(r19)
  1236e4:	88c00015 	stw	r3,0(r17)
  1236e8:	98c00117 	ldw	r3,4(r19)
  1236ec:	88c00115 	stw	r3,4(r17)
  1236f0:	00c006c4 	movi	r3,27
  1236f4:	19801d36 	bltu	r3,r6,12376c <_realloc_r+0x4dc>
  1236f8:	88800204 	addi	r2,r17,8
  1236fc:	98c00204 	addi	r3,r19,8
  123700:	003fa306 	br	123590 <__alt_data_end+0xfffefd10>
  123704:	8807883a 	mov	r3,r17
  123708:	003f7406 	br	1234dc <__alt_data_end+0xfffefc5c>
  12370c:	ad2b883a 	add	r21,r21,r20
  123710:	2505c83a 	sub	r2,r4,r20
  123714:	e5400215 	stw	r21,8(fp)
  123718:	10800054 	ori	r2,r2,1
  12371c:	a8800115 	stw	r2,4(r21)
  123720:	98bfff17 	ldw	r2,-4(r19)
  123724:	9009883a 	mov	r4,r18
  123728:	1080004c 	andi	r2,r2,1
  12372c:	a0a8b03a 	or	r20,r20,r2
  123730:	9d3fff15 	stw	r20,-4(r19)
  123734:	0123f400 	call	123f40 <__malloc_unlock>
  123738:	9805883a 	mov	r2,r19
  12373c:	003f3b06 	br	12342c <__alt_data_end+0xfffefbac>
  123740:	8809883a 	mov	r4,r17
  123744:	980b883a 	mov	r5,r19
  123748:	01230d80 	call	1230d8 <memmove>
  12374c:	003f9606 	br	1235a8 <__alt_data_end+0xfffefd28>
  123750:	8809883a 	mov	r4,r17
  123754:	980b883a 	mov	r5,r19
  123758:	01230d80 	call	1230d8 <memmove>
  12375c:	b8c00117 	ldw	r3,4(r23)
  123760:	b021883a 	mov	r16,r22
  123764:	b82b883a 	mov	r21,r23
  123768:	003f2306 	br	1233f8 <__alt_data_end+0xfffefb78>
  12376c:	98c00217 	ldw	r3,8(r19)
  123770:	88c00215 	stw	r3,8(r17)
  123774:	98c00317 	ldw	r3,12(r19)
  123778:	88c00315 	stw	r3,12(r17)
  12377c:	30800c26 	beq	r6,r2,1237b0 <_realloc_r+0x520>
  123780:	88800404 	addi	r2,r17,16
  123784:	98c00404 	addi	r3,r19,16
  123788:	003f8106 	br	123590 <__alt_data_end+0xfffefd10>
  12378c:	893fff17 	ldw	r4,-4(r17)
  123790:	00bfff04 	movi	r2,-4
  123794:	9823883a 	mov	r17,r19
  123798:	2084703a 	and	r2,r4,r2
  12379c:	80a1883a 	add	r16,r16,r2
  1237a0:	003f1506 	br	1233f8 <__alt_data_end+0xfffefb78>
  1237a4:	b8c00404 	addi	r3,r23,16
  1237a8:	9cc00204 	addi	r19,r19,8
  1237ac:	003f4b06 	br	1234dc <__alt_data_end+0xfffefc5c>
  1237b0:	99000417 	ldw	r4,16(r19)
  1237b4:	88800604 	addi	r2,r17,24
  1237b8:	98c00604 	addi	r3,r19,24
  1237bc:	89000415 	stw	r4,16(r17)
  1237c0:	99000517 	ldw	r4,20(r19)
  1237c4:	89000515 	stw	r4,20(r17)
  1237c8:	003f7106 	br	123590 <__alt_data_end+0xfffefd10>
  1237cc:	8805883a 	mov	r2,r17
  1237d0:	003fb006 	br	123694 <__alt_data_end+0xfffefe14>
  1237d4:	8809883a 	mov	r4,r17
  1237d8:	980b883a 	mov	r5,r19
  1237dc:	01230d80 	call	1230d8 <memmove>
  1237e0:	003fb206 	br	1236ac <__alt_data_end+0xfffefe2c>
  1237e4:	98800217 	ldw	r2,8(r19)
  1237e8:	b8800415 	stw	r2,16(r23)
  1237ec:	98800317 	ldw	r2,12(r19)
  1237f0:	b8800515 	stw	r2,20(r23)
  1237f4:	31000726 	beq	r6,r4,123814 <_realloc_r+0x584>
  1237f8:	b8800604 	addi	r2,r23,24
  1237fc:	9cc00404 	addi	r19,r19,16
  123800:	003fa406 	br	123694 <__alt_data_end+0xfffefe14>
  123804:	9009883a 	mov	r4,r18
  123808:	0123f400 	call	123f40 <__malloc_unlock>
  12380c:	0005883a 	mov	r2,zero
  123810:	003f0606 	br	12342c <__alt_data_end+0xfffefbac>
  123814:	98c00417 	ldw	r3,16(r19)
  123818:	9cc00604 	addi	r19,r19,24
  12381c:	b8800804 	addi	r2,r23,32
  123820:	b8c00615 	stw	r3,24(r23)
  123824:	98ffff17 	ldw	r3,-4(r19)
  123828:	b8c00715 	stw	r3,28(r23)
  12382c:	003f9906 	br	123694 <__alt_data_end+0xfffefe14>

00123830 <__swsetup_r>:
  123830:	008004f4 	movhi	r2,19
  123834:	defffd04 	addi	sp,sp,-12
  123838:	10a4ea04 	addi	r2,r2,-27736
  12383c:	dc400115 	stw	r17,4(sp)
  123840:	2023883a 	mov	r17,r4
  123844:	11000017 	ldw	r4,0(r2)
  123848:	dc000015 	stw	r16,0(sp)
  12384c:	dfc00215 	stw	ra,8(sp)
  123850:	2821883a 	mov	r16,r5
  123854:	20000226 	beq	r4,zero,123860 <__swsetup_r+0x30>
  123858:	20c00e17 	ldw	r3,56(r4)
  12385c:	18002e26 	beq	r3,zero,123918 <__swsetup_r+0xe8>
  123860:	8080030b 	ldhu	r2,12(r16)
  123864:	10c0020c 	andi	r3,r2,8
  123868:	100d883a 	mov	r6,r2
  12386c:	18000f26 	beq	r3,zero,1238ac <__swsetup_r+0x7c>
  123870:	80c00417 	ldw	r3,16(r16)
  123874:	18001526 	beq	r3,zero,1238cc <__swsetup_r+0x9c>
  123878:	1100004c 	andi	r4,r2,1
  12387c:	20001c1e 	bne	r4,zero,1238f0 <__swsetup_r+0xc0>
  123880:	1080008c 	andi	r2,r2,2
  123884:	1000261e 	bne	r2,zero,123920 <__swsetup_r+0xf0>
  123888:	80800517 	ldw	r2,20(r16)
  12388c:	80800215 	stw	r2,8(r16)
  123890:	18001c26 	beq	r3,zero,123904 <__swsetup_r+0xd4>
  123894:	0005883a 	mov	r2,zero
  123898:	dfc00217 	ldw	ra,8(sp)
  12389c:	dc400117 	ldw	r17,4(sp)
  1238a0:	dc000017 	ldw	r16,0(sp)
  1238a4:	dec00304 	addi	sp,sp,12
  1238a8:	f800283a 	ret
  1238ac:	3080040c 	andi	r2,r6,16
  1238b0:	10001726 	beq	r2,zero,123910 <__swsetup_r+0xe0>
  1238b4:	3080010c 	andi	r2,r6,4
  1238b8:	10001b1e 	bne	r2,zero,123928 <__swsetup_r+0xf8>
  1238bc:	80c00417 	ldw	r3,16(r16)
  1238c0:	30800214 	ori	r2,r6,8
  1238c4:	8080030d 	sth	r2,12(r16)
  1238c8:	183feb1e 	bne	r3,zero,123878 <__alt_data_end+0xfffefff8>
  1238cc:	1140a00c 	andi	r5,r2,640
  1238d0:	01008004 	movi	r4,512
  1238d4:	293fe826 	beq	r5,r4,123878 <__alt_data_end+0xfffefff8>
  1238d8:	8809883a 	mov	r4,r17
  1238dc:	800b883a 	mov	r5,r16
  1238e0:	01218840 	call	121884 <__smakebuf_r>
  1238e4:	8080030b 	ldhu	r2,12(r16)
  1238e8:	80c00417 	ldw	r3,16(r16)
  1238ec:	003fe206 	br	123878 <__alt_data_end+0xfffefff8>
  1238f0:	80800517 	ldw	r2,20(r16)
  1238f4:	80000215 	stw	zero,8(r16)
  1238f8:	0085c83a 	sub	r2,zero,r2
  1238fc:	80800615 	stw	r2,24(r16)
  123900:	183fe41e 	bne	r3,zero,123894 <__alt_data_end+0xffff0014>
  123904:	8080030b 	ldhu	r2,12(r16)
  123908:	1080200c 	andi	r2,r2,128
  12390c:	103fe226 	beq	r2,zero,123898 <__alt_data_end+0xffff0018>
  123910:	00bfffc4 	movi	r2,-1
  123914:	003fe006 	br	123898 <__alt_data_end+0xffff0018>
  123918:	0120cd40 	call	120cd4 <__sinit>
  12391c:	003fd006 	br	123860 <__alt_data_end+0xfffeffe0>
  123920:	0005883a 	mov	r2,zero
  123924:	003fd906 	br	12388c <__alt_data_end+0xffff000c>
  123928:	81400c17 	ldw	r5,48(r16)
  12392c:	28000626 	beq	r5,zero,123948 <__swsetup_r+0x118>
  123930:	80801004 	addi	r2,r16,64
  123934:	28800326 	beq	r5,r2,123944 <__swsetup_r+0x114>
  123938:	8809883a 	mov	r4,r17
  12393c:	0120f540 	call	120f54 <_free_r>
  123940:	8180030b 	ldhu	r6,12(r16)
  123944:	80000c15 	stw	zero,48(r16)
  123948:	80c00417 	ldw	r3,16(r16)
  12394c:	00bff6c4 	movi	r2,-37
  123950:	118c703a 	and	r6,r2,r6
  123954:	80000115 	stw	zero,4(r16)
  123958:	80c00015 	stw	r3,0(r16)
  12395c:	003fd806 	br	1238c0 <__alt_data_end+0xffff0040>

00123960 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  123960:	defffe04 	addi	sp,sp,-8
  123964:	dfc00115 	stw	ra,4(sp)
  123968:	df000015 	stw	fp,0(sp)
  12396c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  123970:	008004f4 	movhi	r2,19
  123974:	10a4f204 	addi	r2,r2,-27704
  123978:	10800017 	ldw	r2,0(r2)
  12397c:	10000526 	beq	r2,zero,123994 <alt_get_errno+0x34>
  123980:	008004f4 	movhi	r2,19
  123984:	10a4f204 	addi	r2,r2,-27704
  123988:	10800017 	ldw	r2,0(r2)
  12398c:	103ee83a 	callr	r2
  123990:	00000206 	br	12399c <alt_get_errno+0x3c>
  123994:	008004f4 	movhi	r2,19
  123998:	10abdd04 	addi	r2,r2,-20620
}
  12399c:	e037883a 	mov	sp,fp
  1239a0:	dfc00117 	ldw	ra,4(sp)
  1239a4:	df000017 	ldw	fp,0(sp)
  1239a8:	dec00204 	addi	sp,sp,8
  1239ac:	f800283a 	ret

001239b0 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
  1239b0:	defffb04 	addi	sp,sp,-20
  1239b4:	dfc00415 	stw	ra,16(sp)
  1239b8:	df000315 	stw	fp,12(sp)
  1239bc:	df000304 	addi	fp,sp,12
  1239c0:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
  1239c4:	e0bfff17 	ldw	r2,-4(fp)
  1239c8:	10000616 	blt	r2,zero,1239e4 <close+0x34>
  1239cc:	e0bfff17 	ldw	r2,-4(fp)
  1239d0:	10c00324 	muli	r3,r2,12
  1239d4:	008004f4 	movhi	r2,19
  1239d8:	10a02a04 	addi	r2,r2,-32600
  1239dc:	1885883a 	add	r2,r3,r2
  1239e0:	00000106 	br	1239e8 <close+0x38>
  1239e4:	0005883a 	mov	r2,zero
  1239e8:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
  1239ec:	e0bffd17 	ldw	r2,-12(fp)
  1239f0:	10001926 	beq	r2,zero,123a58 <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
  1239f4:	e0bffd17 	ldw	r2,-12(fp)
  1239f8:	10800017 	ldw	r2,0(r2)
  1239fc:	10800417 	ldw	r2,16(r2)
  123a00:	10000626 	beq	r2,zero,123a1c <close+0x6c>
  123a04:	e0bffd17 	ldw	r2,-12(fp)
  123a08:	10800017 	ldw	r2,0(r2)
  123a0c:	10800417 	ldw	r2,16(r2)
  123a10:	e13ffd17 	ldw	r4,-12(fp)
  123a14:	103ee83a 	callr	r2
  123a18:	00000106 	br	123a20 <close+0x70>
  123a1c:	0005883a 	mov	r2,zero
  123a20:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
  123a24:	e13fff17 	ldw	r4,-4(fp)
  123a28:	012458c0 	call	12458c <alt_release_fd>
    if (rval < 0)
  123a2c:	e0bffe17 	ldw	r2,-8(fp)
  123a30:	1000070e 	bge	r2,zero,123a50 <close+0xa0>
    {
      ALT_ERRNO = -rval;
  123a34:	01239600 	call	123960 <alt_get_errno>
  123a38:	1007883a 	mov	r3,r2
  123a3c:	e0bffe17 	ldw	r2,-8(fp)
  123a40:	0085c83a 	sub	r2,zero,r2
  123a44:	18800015 	stw	r2,0(r3)
      return -1;
  123a48:	00bfffc4 	movi	r2,-1
  123a4c:	00000706 	br	123a6c <close+0xbc>
    }
    return 0;
  123a50:	0005883a 	mov	r2,zero
  123a54:	00000506 	br	123a6c <close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
  123a58:	01239600 	call	123960 <alt_get_errno>
  123a5c:	1007883a 	mov	r3,r2
  123a60:	00801444 	movi	r2,81
  123a64:	18800015 	stw	r2,0(r3)
    return -1;
  123a68:	00bfffc4 	movi	r2,-1
  }
}
  123a6c:	e037883a 	mov	sp,fp
  123a70:	dfc00117 	ldw	ra,4(sp)
  123a74:	df000017 	ldw	fp,0(sp)
  123a78:	dec00204 	addi	sp,sp,8
  123a7c:	f800283a 	ret

00123a80 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  123a80:	defffc04 	addi	sp,sp,-16
  123a84:	df000315 	stw	fp,12(sp)
  123a88:	df000304 	addi	fp,sp,12
  123a8c:	e13ffd15 	stw	r4,-12(fp)
  123a90:	e17ffe15 	stw	r5,-8(fp)
  123a94:	e1bfff15 	stw	r6,-4(fp)
  return len;
  123a98:	e0bfff17 	ldw	r2,-4(fp)
}
  123a9c:	e037883a 	mov	sp,fp
  123aa0:	df000017 	ldw	fp,0(sp)
  123aa4:	dec00104 	addi	sp,sp,4
  123aa8:	f800283a 	ret

00123aac <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  123aac:	defffe04 	addi	sp,sp,-8
  123ab0:	dfc00115 	stw	ra,4(sp)
  123ab4:	df000015 	stw	fp,0(sp)
  123ab8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  123abc:	008004f4 	movhi	r2,19
  123ac0:	10a4f204 	addi	r2,r2,-27704
  123ac4:	10800017 	ldw	r2,0(r2)
  123ac8:	10000526 	beq	r2,zero,123ae0 <alt_get_errno+0x34>
  123acc:	008004f4 	movhi	r2,19
  123ad0:	10a4f204 	addi	r2,r2,-27704
  123ad4:	10800017 	ldw	r2,0(r2)
  123ad8:	103ee83a 	callr	r2
  123adc:	00000206 	br	123ae8 <alt_get_errno+0x3c>
  123ae0:	008004f4 	movhi	r2,19
  123ae4:	10abdd04 	addi	r2,r2,-20620
}
  123ae8:	e037883a 	mov	sp,fp
  123aec:	dfc00117 	ldw	ra,4(sp)
  123af0:	df000017 	ldw	fp,0(sp)
  123af4:	dec00204 	addi	sp,sp,8
  123af8:	f800283a 	ret

00123afc <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
  123afc:	defffb04 	addi	sp,sp,-20
  123b00:	dfc00415 	stw	ra,16(sp)
  123b04:	df000315 	stw	fp,12(sp)
  123b08:	df000304 	addi	fp,sp,12
  123b0c:	e13ffe15 	stw	r4,-8(fp)
  123b10:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  123b14:	e0bffe17 	ldw	r2,-8(fp)
  123b18:	10000616 	blt	r2,zero,123b34 <fstat+0x38>
  123b1c:	e0bffe17 	ldw	r2,-8(fp)
  123b20:	10c00324 	muli	r3,r2,12
  123b24:	008004f4 	movhi	r2,19
  123b28:	10a02a04 	addi	r2,r2,-32600
  123b2c:	1885883a 	add	r2,r3,r2
  123b30:	00000106 	br	123b38 <fstat+0x3c>
  123b34:	0005883a 	mov	r2,zero
  123b38:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
  123b3c:	e0bffd17 	ldw	r2,-12(fp)
  123b40:	10001026 	beq	r2,zero,123b84 <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
  123b44:	e0bffd17 	ldw	r2,-12(fp)
  123b48:	10800017 	ldw	r2,0(r2)
  123b4c:	10800817 	ldw	r2,32(r2)
  123b50:	10000726 	beq	r2,zero,123b70 <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
  123b54:	e0bffd17 	ldw	r2,-12(fp)
  123b58:	10800017 	ldw	r2,0(r2)
  123b5c:	10800817 	ldw	r2,32(r2)
  123b60:	e13ffd17 	ldw	r4,-12(fp)
  123b64:	e17fff17 	ldw	r5,-4(fp)
  123b68:	103ee83a 	callr	r2
  123b6c:	00000a06 	br	123b98 <fstat+0x9c>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
  123b70:	e0bfff17 	ldw	r2,-4(fp)
  123b74:	00c80004 	movi	r3,8192
  123b78:	10c00115 	stw	r3,4(r2)
      return 0;
  123b7c:	0005883a 	mov	r2,zero
  123b80:	00000506 	br	123b98 <fstat+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
  123b84:	0123aac0 	call	123aac <alt_get_errno>
  123b88:	1007883a 	mov	r3,r2
  123b8c:	00801444 	movi	r2,81
  123b90:	18800015 	stw	r2,0(r3)
    return -1;
  123b94:	00bfffc4 	movi	r2,-1
  }
}
  123b98:	e037883a 	mov	sp,fp
  123b9c:	dfc00117 	ldw	ra,4(sp)
  123ba0:	df000017 	ldw	fp,0(sp)
  123ba4:	dec00204 	addi	sp,sp,8
  123ba8:	f800283a 	ret

00123bac <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  123bac:	defffe04 	addi	sp,sp,-8
  123bb0:	dfc00115 	stw	ra,4(sp)
  123bb4:	df000015 	stw	fp,0(sp)
  123bb8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  123bbc:	008004f4 	movhi	r2,19
  123bc0:	10a4f204 	addi	r2,r2,-27704
  123bc4:	10800017 	ldw	r2,0(r2)
  123bc8:	10000526 	beq	r2,zero,123be0 <alt_get_errno+0x34>
  123bcc:	008004f4 	movhi	r2,19
  123bd0:	10a4f204 	addi	r2,r2,-27704
  123bd4:	10800017 	ldw	r2,0(r2)
  123bd8:	103ee83a 	callr	r2
  123bdc:	00000206 	br	123be8 <alt_get_errno+0x3c>
  123be0:	008004f4 	movhi	r2,19
  123be4:	10abdd04 	addi	r2,r2,-20620
}
  123be8:	e037883a 	mov	sp,fp
  123bec:	dfc00117 	ldw	ra,4(sp)
  123bf0:	df000017 	ldw	fp,0(sp)
  123bf4:	dec00204 	addi	sp,sp,8
  123bf8:	f800283a 	ret

00123bfc <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
  123bfc:	deffed04 	addi	sp,sp,-76
  123c00:	dfc01215 	stw	ra,72(sp)
  123c04:	df001115 	stw	fp,68(sp)
  123c08:	df001104 	addi	fp,sp,68
  123c0c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  123c10:	e0bfff17 	ldw	r2,-4(fp)
  123c14:	10000616 	blt	r2,zero,123c30 <isatty+0x34>
  123c18:	e0bfff17 	ldw	r2,-4(fp)
  123c1c:	10c00324 	muli	r3,r2,12
  123c20:	008004f4 	movhi	r2,19
  123c24:	10a02a04 	addi	r2,r2,-32600
  123c28:	1885883a 	add	r2,r3,r2
  123c2c:	00000106 	br	123c34 <isatty+0x38>
  123c30:	0005883a 	mov	r2,zero
  123c34:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
  123c38:	e0bfef17 	ldw	r2,-68(fp)
  123c3c:	10000e26 	beq	r2,zero,123c78 <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
  123c40:	e0bfef17 	ldw	r2,-68(fp)
  123c44:	10800017 	ldw	r2,0(r2)
  123c48:	10800817 	ldw	r2,32(r2)
  123c4c:	1000021e 	bne	r2,zero,123c58 <isatty+0x5c>
    {
      return 1;
  123c50:	00800044 	movi	r2,1
  123c54:	00000d06 	br	123c8c <isatty+0x90>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
  123c58:	e0bff004 	addi	r2,fp,-64
  123c5c:	e13fff17 	ldw	r4,-4(fp)
  123c60:	100b883a 	mov	r5,r2
  123c64:	0123afc0 	call	123afc <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
  123c68:	e0bff117 	ldw	r2,-60(fp)
  123c6c:	10880020 	cmpeqi	r2,r2,8192
  123c70:	10803fcc 	andi	r2,r2,255
  123c74:	00000506 	br	123c8c <isatty+0x90>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
  123c78:	0123bac0 	call	123bac <alt_get_errno>
  123c7c:	1007883a 	mov	r3,r2
  123c80:	00801444 	movi	r2,81
  123c84:	18800015 	stw	r2,0(r3)
    return 0;
  123c88:	0005883a 	mov	r2,zero
  }
}
  123c8c:	e037883a 	mov	sp,fp
  123c90:	dfc00117 	ldw	ra,4(sp)
  123c94:	df000017 	ldw	fp,0(sp)
  123c98:	dec00204 	addi	sp,sp,8
  123c9c:	f800283a 	ret

00123ca0 <alt_load_section>:
  123ca0:	defffc04 	addi	sp,sp,-16
  123ca4:	df000315 	stw	fp,12(sp)
  123ca8:	df000304 	addi	fp,sp,12
  123cac:	e13ffd15 	stw	r4,-12(fp)
  123cb0:	e17ffe15 	stw	r5,-8(fp)
  123cb4:	e1bfff15 	stw	r6,-4(fp)
  123cb8:	e0fffe17 	ldw	r3,-8(fp)
  123cbc:	e0bffd17 	ldw	r2,-12(fp)
  123cc0:	18800c26 	beq	r3,r2,123cf4 <alt_load_section+0x54>
  123cc4:	00000806 	br	123ce8 <alt_load_section+0x48>
  123cc8:	e0bffe17 	ldw	r2,-8(fp)
  123ccc:	10c00104 	addi	r3,r2,4
  123cd0:	e0fffe15 	stw	r3,-8(fp)
  123cd4:	e0fffd17 	ldw	r3,-12(fp)
  123cd8:	19000104 	addi	r4,r3,4
  123cdc:	e13ffd15 	stw	r4,-12(fp)
  123ce0:	18c00017 	ldw	r3,0(r3)
  123ce4:	10c00015 	stw	r3,0(r2)
  123ce8:	e0fffe17 	ldw	r3,-8(fp)
  123cec:	e0bfff17 	ldw	r2,-4(fp)
  123cf0:	18bff51e 	bne	r3,r2,123cc8 <__alt_data_end+0xffff0448>
  123cf4:	e037883a 	mov	sp,fp
  123cf8:	df000017 	ldw	fp,0(sp)
  123cfc:	dec00104 	addi	sp,sp,4
  123d00:	f800283a 	ret

00123d04 <alt_load>:
  123d04:	defffe04 	addi	sp,sp,-8
  123d08:	dfc00115 	stw	ra,4(sp)
  123d0c:	df000015 	stw	fp,0(sp)
  123d10:	d839883a 	mov	fp,sp
  123d14:	010004f4 	movhi	r4,19
  123d18:	2124f904 	addi	r4,r4,-27676
  123d1c:	014004b4 	movhi	r5,18
  123d20:	295e1504 	addi	r5,r5,30804
  123d24:	018004f4 	movhi	r6,19
  123d28:	31a4f904 	addi	r6,r6,-27676
  123d2c:	0123ca00 	call	123ca0 <alt_load_section>
  123d30:	010004b4 	movhi	r4,18
  123d34:	21000804 	addi	r4,r4,32
  123d38:	014004b4 	movhi	r5,18
  123d3c:	29400804 	addi	r5,r5,32
  123d40:	018004b4 	movhi	r6,18
  123d44:	31809004 	addi	r6,r6,576
  123d48:	0123ca00 	call	123ca0 <alt_load_section>
  123d4c:	010004b4 	movhi	r4,18
  123d50:	211dbd04 	addi	r4,r4,30452
  123d54:	014004b4 	movhi	r5,18
  123d58:	295dbd04 	addi	r5,r5,30452
  123d5c:	018004b4 	movhi	r6,18
  123d60:	319e1504 	addi	r6,r6,30804
  123d64:	0123ca00 	call	123ca0 <alt_load_section>
  123d68:	01264700 	call	126470 <alt_dcache_flush_all>
  123d6c:	01268b80 	call	1268b8 <alt_icache_flush_all>
  123d70:	e037883a 	mov	sp,fp
  123d74:	dfc00117 	ldw	ra,4(sp)
  123d78:	df000017 	ldw	fp,0(sp)
  123d7c:	dec00204 	addi	sp,sp,8
  123d80:	f800283a 	ret

00123d84 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  123d84:	defffe04 	addi	sp,sp,-8
  123d88:	dfc00115 	stw	ra,4(sp)
  123d8c:	df000015 	stw	fp,0(sp)
  123d90:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  123d94:	008004f4 	movhi	r2,19
  123d98:	10a4f204 	addi	r2,r2,-27704
  123d9c:	10800017 	ldw	r2,0(r2)
  123da0:	10000526 	beq	r2,zero,123db8 <alt_get_errno+0x34>
  123da4:	008004f4 	movhi	r2,19
  123da8:	10a4f204 	addi	r2,r2,-27704
  123dac:	10800017 	ldw	r2,0(r2)
  123db0:	103ee83a 	callr	r2
  123db4:	00000206 	br	123dc0 <alt_get_errno+0x3c>
  123db8:	008004f4 	movhi	r2,19
  123dbc:	10abdd04 	addi	r2,r2,-20620
}
  123dc0:	e037883a 	mov	sp,fp
  123dc4:	dfc00117 	ldw	ra,4(sp)
  123dc8:	df000017 	ldw	fp,0(sp)
  123dcc:	dec00204 	addi	sp,sp,8
  123dd0:	f800283a 	ret

00123dd4 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
  123dd4:	defff904 	addi	sp,sp,-28
  123dd8:	dfc00615 	stw	ra,24(sp)
  123ddc:	df000515 	stw	fp,20(sp)
  123de0:	df000504 	addi	fp,sp,20
  123de4:	e13ffd15 	stw	r4,-12(fp)
  123de8:	e17ffe15 	stw	r5,-8(fp)
  123dec:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
  123df0:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  123df4:	e0bffd17 	ldw	r2,-12(fp)
  123df8:	10000616 	blt	r2,zero,123e14 <lseek+0x40>
  123dfc:	e0bffd17 	ldw	r2,-12(fp)
  123e00:	10c00324 	muli	r3,r2,12
  123e04:	008004f4 	movhi	r2,19
  123e08:	10a02a04 	addi	r2,r2,-32600
  123e0c:	1885883a 	add	r2,r3,r2
  123e10:	00000106 	br	123e18 <lseek+0x44>
  123e14:	0005883a 	mov	r2,zero
  123e18:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
  123e1c:	e0bffc17 	ldw	r2,-16(fp)
  123e20:	10001026 	beq	r2,zero,123e64 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
  123e24:	e0bffc17 	ldw	r2,-16(fp)
  123e28:	10800017 	ldw	r2,0(r2)
  123e2c:	10800717 	ldw	r2,28(r2)
  123e30:	10000926 	beq	r2,zero,123e58 <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
  123e34:	e0bffc17 	ldw	r2,-16(fp)
  123e38:	10800017 	ldw	r2,0(r2)
  123e3c:	10800717 	ldw	r2,28(r2)
  123e40:	e13ffc17 	ldw	r4,-16(fp)
  123e44:	e17ffe17 	ldw	r5,-8(fp)
  123e48:	e1bfff17 	ldw	r6,-4(fp)
  123e4c:	103ee83a 	callr	r2
  123e50:	e0bffb15 	stw	r2,-20(fp)
  123e54:	00000506 	br	123e6c <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
  123e58:	00bfde84 	movi	r2,-134
  123e5c:	e0bffb15 	stw	r2,-20(fp)
  123e60:	00000206 	br	123e6c <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
  123e64:	00bfebc4 	movi	r2,-81
  123e68:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
  123e6c:	e0bffb17 	ldw	r2,-20(fp)
  123e70:	1000070e 	bge	r2,zero,123e90 <lseek+0xbc>
  {
    ALT_ERRNO = -rc;
  123e74:	0123d840 	call	123d84 <alt_get_errno>
  123e78:	1007883a 	mov	r3,r2
  123e7c:	e0bffb17 	ldw	r2,-20(fp)
  123e80:	0085c83a 	sub	r2,zero,r2
  123e84:	18800015 	stw	r2,0(r3)
    rc = -1;
  123e88:	00bfffc4 	movi	r2,-1
  123e8c:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
  123e90:	e0bffb17 	ldw	r2,-20(fp)
}
  123e94:	e037883a 	mov	sp,fp
  123e98:	dfc00117 	ldw	ra,4(sp)
  123e9c:	df000017 	ldw	fp,0(sp)
  123ea0:	dec00204 	addi	sp,sp,8
  123ea4:	f800283a 	ret

00123ea8 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  123ea8:	defffd04 	addi	sp,sp,-12
  123eac:	dfc00215 	stw	ra,8(sp)
  123eb0:	df000115 	stw	fp,4(sp)
  123eb4:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  123eb8:	0009883a 	mov	r4,zero
  123ebc:	01248d80 	call	1248d8 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
  123ec0:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  123ec4:	012490c0 	call	12490c <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
  123ec8:	010004b4 	movhi	r4,18
  123ecc:	211def04 	addi	r4,r4,30652
  123ed0:	014004b4 	movhi	r5,18
  123ed4:	295def04 	addi	r5,r5,30652
  123ed8:	018004b4 	movhi	r6,18
  123edc:	319def04 	addi	r6,r6,30652
  123ee0:	0126c780 	call	126c78 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
  123ee4:	01265a80 	call	1265a8 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
  123ee8:	010004b4 	movhi	r4,18
  123eec:	21198104 	addi	r4,r4,26116
  123ef0:	0126fd40 	call	126fd4 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
  123ef4:	d126f817 	ldw	r4,-25632(gp)
  123ef8:	d0e6f917 	ldw	r3,-25628(gp)
  123efc:	d0a6fa17 	ldw	r2,-25624(gp)
  123f00:	180b883a 	mov	r5,r3
  123f04:	100d883a 	mov	r6,r2
  123f08:	012028c0 	call	12028c <main>
  123f0c:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
  123f10:	01000044 	movi	r4,1
  123f14:	01239b00 	call	1239b0 <close>
  exit (result);
  123f18:	e13fff17 	ldw	r4,-4(fp)
  123f1c:	0126fe80 	call	126fe8 <exit>

00123f20 <__malloc_lock>:
  123f20:	defffe04 	addi	sp,sp,-8
  123f24:	df000115 	stw	fp,4(sp)
  123f28:	df000104 	addi	fp,sp,4
  123f2c:	e13fff15 	stw	r4,-4(fp)
  123f30:	e037883a 	mov	sp,fp
  123f34:	df000017 	ldw	fp,0(sp)
  123f38:	dec00104 	addi	sp,sp,4
  123f3c:	f800283a 	ret

00123f40 <__malloc_unlock>:
  123f40:	defffe04 	addi	sp,sp,-8
  123f44:	df000115 	stw	fp,4(sp)
  123f48:	df000104 	addi	fp,sp,4
  123f4c:	e13fff15 	stw	r4,-4(fp)
  123f50:	e037883a 	mov	sp,fp
  123f54:	df000017 	ldw	fp,0(sp)
  123f58:	dec00104 	addi	sp,sp,4
  123f5c:	f800283a 	ret

00123f60 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  123f60:	defffe04 	addi	sp,sp,-8
  123f64:	dfc00115 	stw	ra,4(sp)
  123f68:	df000015 	stw	fp,0(sp)
  123f6c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  123f70:	008004f4 	movhi	r2,19
  123f74:	10a4f204 	addi	r2,r2,-27704
  123f78:	10800017 	ldw	r2,0(r2)
  123f7c:	10000526 	beq	r2,zero,123f94 <alt_get_errno+0x34>
  123f80:	008004f4 	movhi	r2,19
  123f84:	10a4f204 	addi	r2,r2,-27704
  123f88:	10800017 	ldw	r2,0(r2)
  123f8c:	103ee83a 	callr	r2
  123f90:	00000206 	br	123f9c <alt_get_errno+0x3c>
  123f94:	008004f4 	movhi	r2,19
  123f98:	10abdd04 	addi	r2,r2,-20620
}
  123f9c:	e037883a 	mov	sp,fp
  123fa0:	dfc00117 	ldw	ra,4(sp)
  123fa4:	df000017 	ldw	fp,0(sp)
  123fa8:	dec00204 	addi	sp,sp,8
  123fac:	f800283a 	ret

00123fb0 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
  123fb0:	defffd04 	addi	sp,sp,-12
  123fb4:	df000215 	stw	fp,8(sp)
  123fb8:	df000204 	addi	fp,sp,8
  123fbc:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
  123fc0:	e0bfff17 	ldw	r2,-4(fp)
  123fc4:	10800217 	ldw	r2,8(r2)
  123fc8:	10d00034 	orhi	r3,r2,16384
  123fcc:	e0bfff17 	ldw	r2,-4(fp)
  123fd0:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  123fd4:	e03ffe15 	stw	zero,-8(fp)
  123fd8:	00001d06 	br	124050 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  123fdc:	008004f4 	movhi	r2,19
  123fe0:	10a02a04 	addi	r2,r2,-32600
  123fe4:	e0fffe17 	ldw	r3,-8(fp)
  123fe8:	18c00324 	muli	r3,r3,12
  123fec:	10c5883a 	add	r2,r2,r3
  123ff0:	10c00017 	ldw	r3,0(r2)
  123ff4:	e0bfff17 	ldw	r2,-4(fp)
  123ff8:	10800017 	ldw	r2,0(r2)
  123ffc:	1880111e 	bne	r3,r2,124044 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  124000:	008004f4 	movhi	r2,19
  124004:	10a02a04 	addi	r2,r2,-32600
  124008:	e0fffe17 	ldw	r3,-8(fp)
  12400c:	18c00324 	muli	r3,r3,12
  124010:	10c5883a 	add	r2,r2,r3
  124014:	10800204 	addi	r2,r2,8
  124018:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  12401c:	1000090e 	bge	r2,zero,124044 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
  124020:	e0bffe17 	ldw	r2,-8(fp)
  124024:	10c00324 	muli	r3,r2,12
  124028:	008004f4 	movhi	r2,19
  12402c:	10a02a04 	addi	r2,r2,-32600
  124030:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  124034:	e0bfff17 	ldw	r2,-4(fp)
  124038:	18800226 	beq	r3,r2,124044 <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
  12403c:	00bffcc4 	movi	r2,-13
  124040:	00000a06 	br	12406c <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  124044:	e0bffe17 	ldw	r2,-8(fp)
  124048:	10800044 	addi	r2,r2,1
  12404c:	e0bffe15 	stw	r2,-8(fp)
  124050:	008004f4 	movhi	r2,19
  124054:	10a4f104 	addi	r2,r2,-27708
  124058:	10800017 	ldw	r2,0(r2)
  12405c:	1007883a 	mov	r3,r2
  124060:	e0bffe17 	ldw	r2,-8(fp)
  124064:	18bfdd2e 	bgeu	r3,r2,123fdc <__alt_data_end+0xffff075c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
  124068:	0005883a 	mov	r2,zero
}
  12406c:	e037883a 	mov	sp,fp
  124070:	df000017 	ldw	fp,0(sp)
  124074:	dec00104 	addi	sp,sp,4
  124078:	f800283a 	ret

0012407c <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
  12407c:	defff604 	addi	sp,sp,-40
  124080:	dfc00915 	stw	ra,36(sp)
  124084:	df000815 	stw	fp,32(sp)
  124088:	df000804 	addi	fp,sp,32
  12408c:	e13ffd15 	stw	r4,-12(fp)
  124090:	e17ffe15 	stw	r5,-8(fp)
  124094:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
  124098:	00bfffc4 	movi	r2,-1
  12409c:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
  1240a0:	00bffb44 	movi	r2,-19
  1240a4:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
  1240a8:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
  1240ac:	e13ffd17 	ldw	r4,-12(fp)
  1240b0:	014004f4 	movhi	r5,19
  1240b4:	2964ef04 	addi	r5,r5,-27716
  1240b8:	01266600 	call	126660 <alt_find_dev>
  1240bc:	e0bff815 	stw	r2,-32(fp)
  1240c0:	e0bff817 	ldw	r2,-32(fp)
  1240c4:	1000051e 	bne	r2,zero,1240dc <open+0x60>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
  1240c8:	e13ffd17 	ldw	r4,-12(fp)
  1240cc:	01266f00 	call	1266f0 <alt_find_file>
  1240d0:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
  1240d4:	00800044 	movi	r2,1
  1240d8:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
  1240dc:	e0bff817 	ldw	r2,-32(fp)
  1240e0:	10002926 	beq	r2,zero,124188 <open+0x10c>
  {
    if ((index = alt_get_fd (dev)) < 0)
  1240e4:	e13ff817 	ldw	r4,-32(fp)
  1240e8:	01268040 	call	126804 <alt_get_fd>
  1240ec:	e0bff915 	stw	r2,-28(fp)
  1240f0:	e0bff917 	ldw	r2,-28(fp)
  1240f4:	1000030e 	bge	r2,zero,124104 <open+0x88>
    {
      status = index;
  1240f8:	e0bff917 	ldw	r2,-28(fp)
  1240fc:	e0bffa15 	stw	r2,-24(fp)
  124100:	00002306 	br	124190 <open+0x114>
    }
    else
    {
      fd = &alt_fd_list[index];
  124104:	e0bff917 	ldw	r2,-28(fp)
  124108:	10c00324 	muli	r3,r2,12
  12410c:	008004f4 	movhi	r2,19
  124110:	10a02a04 	addi	r2,r2,-32600
  124114:	1885883a 	add	r2,r3,r2
  124118:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
  12411c:	e0fffe17 	ldw	r3,-8(fp)
  124120:	00900034 	movhi	r2,16384
  124124:	10bfffc4 	addi	r2,r2,-1
  124128:	1886703a 	and	r3,r3,r2
  12412c:	e0bffc17 	ldw	r2,-16(fp)
  124130:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
  124134:	e0bffb17 	ldw	r2,-20(fp)
  124138:	1000051e 	bne	r2,zero,124150 <open+0xd4>
  12413c:	e13ffc17 	ldw	r4,-16(fp)
  124140:	0123fb00 	call	123fb0 <alt_file_locked>
  124144:	e0bffa15 	stw	r2,-24(fp)
  124148:	e0bffa17 	ldw	r2,-24(fp)
  12414c:	10001016 	blt	r2,zero,124190 <open+0x114>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
  124150:	e0bff817 	ldw	r2,-32(fp)
  124154:	10800317 	ldw	r2,12(r2)
  124158:	10000826 	beq	r2,zero,12417c <open+0x100>
  12415c:	e0bff817 	ldw	r2,-32(fp)
  124160:	10800317 	ldw	r2,12(r2)
  124164:	e13ffc17 	ldw	r4,-16(fp)
  124168:	e17ffd17 	ldw	r5,-12(fp)
  12416c:	e1bffe17 	ldw	r6,-8(fp)
  124170:	e1ffff17 	ldw	r7,-4(fp)
  124174:	103ee83a 	callr	r2
  124178:	00000106 	br	124180 <open+0x104>
  12417c:	0005883a 	mov	r2,zero
  124180:	e0bffa15 	stw	r2,-24(fp)
  124184:	00000206 	br	124190 <open+0x114>
      }
    }
  }
  else
  {
    status = -ENODEV;
  124188:	00bffb44 	movi	r2,-19
  12418c:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
  124190:	e0bffa17 	ldw	r2,-24(fp)
  124194:	1000090e 	bge	r2,zero,1241bc <open+0x140>
  {
    alt_release_fd (index);  
  124198:	e13ff917 	ldw	r4,-28(fp)
  12419c:	012458c0 	call	12458c <alt_release_fd>
    ALT_ERRNO = -status;
  1241a0:	0123f600 	call	123f60 <alt_get_errno>
  1241a4:	1007883a 	mov	r3,r2
  1241a8:	e0bffa17 	ldw	r2,-24(fp)
  1241ac:	0085c83a 	sub	r2,zero,r2
  1241b0:	18800015 	stw	r2,0(r3)
    return -1;
  1241b4:	00bfffc4 	movi	r2,-1
  1241b8:	00000106 	br	1241c0 <open+0x144>
  }
  
  /* return the reference upon success */

  return index;
  1241bc:	e0bff917 	ldw	r2,-28(fp)
}
  1241c0:	e037883a 	mov	sp,fp
  1241c4:	dfc00117 	ldw	ra,4(sp)
  1241c8:	df000017 	ldw	fp,0(sp)
  1241cc:	dec00204 	addi	sp,sp,8
  1241d0:	f800283a 	ret

001241d4 <alt_printf>:
  1241d4:	defff204 	addi	sp,sp,-56
  1241d8:	dfc00a15 	stw	ra,40(sp)
  1241dc:	df000915 	stw	fp,36(sp)
  1241e0:	df000904 	addi	fp,sp,36
  1241e4:	e1400215 	stw	r5,8(fp)
  1241e8:	e1800315 	stw	r6,12(fp)
  1241ec:	e1c00415 	stw	r7,16(fp)
  1241f0:	e13fff15 	stw	r4,-4(fp)
  1241f4:	e0800204 	addi	r2,fp,8
  1241f8:	e0bffe15 	stw	r2,-8(fp)
  1241fc:	e0bfff17 	ldw	r2,-4(fp)
  124200:	e0bff715 	stw	r2,-36(fp)
  124204:	00007106 	br	1243cc <alt_printf+0x1f8>
  124208:	e0bff807 	ldb	r2,-32(fp)
  12420c:	10800960 	cmpeqi	r2,r2,37
  124210:	1000041e 	bne	r2,zero,124224 <alt_printf+0x50>
  124214:	e0bff807 	ldb	r2,-32(fp)
  124218:	1009883a 	mov	r4,r2
  12421c:	01243fc0 	call	1243fc <alt_putchar>
  124220:	00006a06 	br	1243cc <alt_printf+0x1f8>
  124224:	e0bff717 	ldw	r2,-36(fp)
  124228:	10c00044 	addi	r3,r2,1
  12422c:	e0fff715 	stw	r3,-36(fp)
  124230:	10800003 	ldbu	r2,0(r2)
  124234:	e0bff805 	stb	r2,-32(fp)
  124238:	e0bff807 	ldb	r2,-32(fp)
  12423c:	10006226 	beq	r2,zero,1243c8 <alt_printf+0x1f4>
  124240:	e0bff807 	ldb	r2,-32(fp)
  124244:	10800958 	cmpnei	r2,r2,37
  124248:	1000041e 	bne	r2,zero,12425c <alt_printf+0x88>
  12424c:	e0bff807 	ldb	r2,-32(fp)
  124250:	1009883a 	mov	r4,r2
  124254:	01243fc0 	call	1243fc <alt_putchar>
  124258:	00005c06 	br	1243cc <alt_printf+0x1f8>
  12425c:	e0bff807 	ldb	r2,-32(fp)
  124260:	108018d8 	cmpnei	r2,r2,99
  124264:	1000081e 	bne	r2,zero,124288 <alt_printf+0xb4>
  124268:	e0bffe17 	ldw	r2,-8(fp)
  12426c:	10c00104 	addi	r3,r2,4
  124270:	e0fffe15 	stw	r3,-8(fp)
  124274:	10800017 	ldw	r2,0(r2)
  124278:	e0bffd15 	stw	r2,-12(fp)
  12427c:	e13ffd17 	ldw	r4,-12(fp)
  124280:	01243fc0 	call	1243fc <alt_putchar>
  124284:	00005106 	br	1243cc <alt_printf+0x1f8>
  124288:	e0bff807 	ldb	r2,-32(fp)
  12428c:	10801e18 	cmpnei	r2,r2,120
  124290:	1000341e 	bne	r2,zero,124364 <alt_printf+0x190>
  124294:	e0bffe17 	ldw	r2,-8(fp)
  124298:	10c00104 	addi	r3,r2,4
  12429c:	e0fffe15 	stw	r3,-8(fp)
  1242a0:	10800017 	ldw	r2,0(r2)
  1242a4:	e0bffb15 	stw	r2,-20(fp)
  1242a8:	e0bffb17 	ldw	r2,-20(fp)
  1242ac:	1000031e 	bne	r2,zero,1242bc <alt_printf+0xe8>
  1242b0:	01000c04 	movi	r4,48
  1242b4:	01243fc0 	call	1243fc <alt_putchar>
  1242b8:	00004406 	br	1243cc <alt_printf+0x1f8>
  1242bc:	00800704 	movi	r2,28
  1242c0:	e0bff915 	stw	r2,-28(fp)
  1242c4:	00000306 	br	1242d4 <alt_printf+0x100>
  1242c8:	e0bff917 	ldw	r2,-28(fp)
  1242cc:	10bfff04 	addi	r2,r2,-4
  1242d0:	e0bff915 	stw	r2,-28(fp)
  1242d4:	00c003c4 	movi	r3,15
  1242d8:	e0bff917 	ldw	r2,-28(fp)
  1242dc:	1884983a 	sll	r2,r3,r2
  1242e0:	1007883a 	mov	r3,r2
  1242e4:	e0bffb17 	ldw	r2,-20(fp)
  1242e8:	1884703a 	and	r2,r3,r2
  1242ec:	103ff626 	beq	r2,zero,1242c8 <__alt_data_end+0xffff0a48>
  1242f0:	00001906 	br	124358 <alt_printf+0x184>
  1242f4:	00c003c4 	movi	r3,15
  1242f8:	e0bff917 	ldw	r2,-28(fp)
  1242fc:	1884983a 	sll	r2,r3,r2
  124300:	1007883a 	mov	r3,r2
  124304:	e0bffb17 	ldw	r2,-20(fp)
  124308:	1886703a 	and	r3,r3,r2
  12430c:	e0bff917 	ldw	r2,-28(fp)
  124310:	1884d83a 	srl	r2,r3,r2
  124314:	e0bffc15 	stw	r2,-16(fp)
  124318:	e0bffc17 	ldw	r2,-16(fp)
  12431c:	108002a8 	cmpgeui	r2,r2,10
  124320:	1000041e 	bne	r2,zero,124334 <alt_printf+0x160>
  124324:	e0bffc17 	ldw	r2,-16(fp)
  124328:	10800c04 	addi	r2,r2,48
  12432c:	e0bff805 	stb	r2,-32(fp)
  124330:	00000306 	br	124340 <alt_printf+0x16c>
  124334:	e0bffc17 	ldw	r2,-16(fp)
  124338:	108015c4 	addi	r2,r2,87
  12433c:	e0bff805 	stb	r2,-32(fp)
  124340:	e0bff807 	ldb	r2,-32(fp)
  124344:	1009883a 	mov	r4,r2
  124348:	01243fc0 	call	1243fc <alt_putchar>
  12434c:	e0bff917 	ldw	r2,-28(fp)
  124350:	10bfff04 	addi	r2,r2,-4
  124354:	e0bff915 	stw	r2,-28(fp)
  124358:	e0bff917 	ldw	r2,-28(fp)
  12435c:	103fe50e 	bge	r2,zero,1242f4 <__alt_data_end+0xffff0a74>
  124360:	00001a06 	br	1243cc <alt_printf+0x1f8>
  124364:	e0bff807 	ldb	r2,-32(fp)
  124368:	10801cd8 	cmpnei	r2,r2,115
  12436c:	1000151e 	bne	r2,zero,1243c4 <alt_printf+0x1f0>
  124370:	e0bffe17 	ldw	r2,-8(fp)
  124374:	10c00104 	addi	r3,r2,4
  124378:	e0fffe15 	stw	r3,-8(fp)
  12437c:	10800017 	ldw	r2,0(r2)
  124380:	e0bffa15 	stw	r2,-24(fp)
  124384:	00000906 	br	1243ac <alt_printf+0x1d8>
  124388:	e0bffa17 	ldw	r2,-24(fp)
  12438c:	10c00044 	addi	r3,r2,1
  124390:	e0fffa15 	stw	r3,-24(fp)
  124394:	10800003 	ldbu	r2,0(r2)
  124398:	10803fcc 	andi	r2,r2,255
  12439c:	1080201c 	xori	r2,r2,128
  1243a0:	10bfe004 	addi	r2,r2,-128
  1243a4:	1009883a 	mov	r4,r2
  1243a8:	01243fc0 	call	1243fc <alt_putchar>
  1243ac:	e0bffa17 	ldw	r2,-24(fp)
  1243b0:	10800003 	ldbu	r2,0(r2)
  1243b4:	10803fcc 	andi	r2,r2,255
  1243b8:	1080201c 	xori	r2,r2,128
  1243bc:	10bfe004 	addi	r2,r2,-128
  1243c0:	103ff11e 	bne	r2,zero,124388 <__alt_data_end+0xffff0b08>
  1243c4:	00000106 	br	1243cc <alt_printf+0x1f8>
  1243c8:	00000706 	br	1243e8 <alt_printf+0x214>
  1243cc:	e0bff717 	ldw	r2,-36(fp)
  1243d0:	10c00044 	addi	r3,r2,1
  1243d4:	e0fff715 	stw	r3,-36(fp)
  1243d8:	10800003 	ldbu	r2,0(r2)
  1243dc:	e0bff805 	stb	r2,-32(fp)
  1243e0:	e0bff807 	ldb	r2,-32(fp)
  1243e4:	103f881e 	bne	r2,zero,124208 <__alt_data_end+0xffff0988>
  1243e8:	e037883a 	mov	sp,fp
  1243ec:	dfc00117 	ldw	ra,4(sp)
  1243f0:	df000017 	ldw	fp,0(sp)
  1243f4:	dec00504 	addi	sp,sp,20
  1243f8:	f800283a 	ret

001243fc <alt_putchar>:
  1243fc:	defffd04 	addi	sp,sp,-12
  124400:	dfc00215 	stw	ra,8(sp)
  124404:	df000115 	stw	fp,4(sp)
  124408:	df000104 	addi	fp,sp,4
  12440c:	e13fff15 	stw	r4,-4(fp)
  124410:	008004f4 	movhi	r2,19
  124414:	10a4ea04 	addi	r2,r2,-27736
  124418:	10800017 	ldw	r2,0(r2)
  12441c:	10800217 	ldw	r2,8(r2)
  124420:	e13fff17 	ldw	r4,-4(fp)
  124424:	100b883a 	mov	r5,r2
  124428:	012713c0 	call	12713c <putc>
  12442c:	e037883a 	mov	sp,fp
  124430:	dfc00117 	ldw	ra,4(sp)
  124434:	df000017 	ldw	fp,0(sp)
  124438:	dec00204 	addi	sp,sp,8
  12443c:	f800283a 	ret

00124440 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  124440:	defffe04 	addi	sp,sp,-8
  124444:	dfc00115 	stw	ra,4(sp)
  124448:	df000015 	stw	fp,0(sp)
  12444c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  124450:	008004f4 	movhi	r2,19
  124454:	10a4f204 	addi	r2,r2,-27704
  124458:	10800017 	ldw	r2,0(r2)
  12445c:	10000526 	beq	r2,zero,124474 <alt_get_errno+0x34>
  124460:	008004f4 	movhi	r2,19
  124464:	10a4f204 	addi	r2,r2,-27704
  124468:	10800017 	ldw	r2,0(r2)
  12446c:	103ee83a 	callr	r2
  124470:	00000206 	br	12447c <alt_get_errno+0x3c>
  124474:	008004f4 	movhi	r2,19
  124478:	10abdd04 	addi	r2,r2,-20620
}
  12447c:	e037883a 	mov	sp,fp
  124480:	dfc00117 	ldw	ra,4(sp)
  124484:	df000017 	ldw	fp,0(sp)
  124488:	dec00204 	addi	sp,sp,8
  12448c:	f800283a 	ret

00124490 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
  124490:	defff904 	addi	sp,sp,-28
  124494:	dfc00615 	stw	ra,24(sp)
  124498:	df000515 	stw	fp,20(sp)
  12449c:	df000504 	addi	fp,sp,20
  1244a0:	e13ffd15 	stw	r4,-12(fp)
  1244a4:	e17ffe15 	stw	r5,-8(fp)
  1244a8:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  1244ac:	e0bffd17 	ldw	r2,-12(fp)
  1244b0:	10000616 	blt	r2,zero,1244cc <read+0x3c>
  1244b4:	e0bffd17 	ldw	r2,-12(fp)
  1244b8:	10c00324 	muli	r3,r2,12
  1244bc:	008004f4 	movhi	r2,19
  1244c0:	10a02a04 	addi	r2,r2,-32600
  1244c4:	1885883a 	add	r2,r3,r2
  1244c8:	00000106 	br	1244d0 <read+0x40>
  1244cc:	0005883a 	mov	r2,zero
  1244d0:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
  1244d4:	e0bffb17 	ldw	r2,-20(fp)
  1244d8:	10002226 	beq	r2,zero,124564 <read+0xd4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
  1244dc:	e0bffb17 	ldw	r2,-20(fp)
  1244e0:	10800217 	ldw	r2,8(r2)
  1244e4:	108000cc 	andi	r2,r2,3
  1244e8:	10800060 	cmpeqi	r2,r2,1
  1244ec:	1000181e 	bne	r2,zero,124550 <read+0xc0>
        (fd->dev->read))
  1244f0:	e0bffb17 	ldw	r2,-20(fp)
  1244f4:	10800017 	ldw	r2,0(r2)
  1244f8:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
  1244fc:	10001426 	beq	r2,zero,124550 <read+0xc0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
  124500:	e0bffb17 	ldw	r2,-20(fp)
  124504:	10800017 	ldw	r2,0(r2)
  124508:	10800517 	ldw	r2,20(r2)
  12450c:	e0ffff17 	ldw	r3,-4(fp)
  124510:	e13ffb17 	ldw	r4,-20(fp)
  124514:	e17ffe17 	ldw	r5,-8(fp)
  124518:	180d883a 	mov	r6,r3
  12451c:	103ee83a 	callr	r2
  124520:	e0bffc15 	stw	r2,-16(fp)
  124524:	e0bffc17 	ldw	r2,-16(fp)
  124528:	1000070e 	bge	r2,zero,124548 <read+0xb8>
        {
          ALT_ERRNO = -rval;
  12452c:	01244400 	call	124440 <alt_get_errno>
  124530:	1007883a 	mov	r3,r2
  124534:	e0bffc17 	ldw	r2,-16(fp)
  124538:	0085c83a 	sub	r2,zero,r2
  12453c:	18800015 	stw	r2,0(r3)
          return -1;
  124540:	00bfffc4 	movi	r2,-1
  124544:	00000c06 	br	124578 <read+0xe8>
        }
        return rval;
  124548:	e0bffc17 	ldw	r2,-16(fp)
  12454c:	00000a06 	br	124578 <read+0xe8>
      }
      else
      {
        ALT_ERRNO = EACCES;
  124550:	01244400 	call	124440 <alt_get_errno>
  124554:	1007883a 	mov	r3,r2
  124558:	00800344 	movi	r2,13
  12455c:	18800015 	stw	r2,0(r3)
  124560:	00000406 	br	124574 <read+0xe4>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
  124564:	01244400 	call	124440 <alt_get_errno>
  124568:	1007883a 	mov	r3,r2
  12456c:	00801444 	movi	r2,81
  124570:	18800015 	stw	r2,0(r3)
  }
  return -1;
  124574:	00bfffc4 	movi	r2,-1
}
  124578:	e037883a 	mov	sp,fp
  12457c:	dfc00117 	ldw	ra,4(sp)
  124580:	df000017 	ldw	fp,0(sp)
  124584:	dec00204 	addi	sp,sp,8
  124588:	f800283a 	ret

0012458c <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
  12458c:	defffe04 	addi	sp,sp,-8
  124590:	df000115 	stw	fp,4(sp)
  124594:	df000104 	addi	fp,sp,4
  124598:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
  12459c:	e0bfff17 	ldw	r2,-4(fp)
  1245a0:	108000d0 	cmplti	r2,r2,3
  1245a4:	10000d1e 	bne	r2,zero,1245dc <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
  1245a8:	008004f4 	movhi	r2,19
  1245ac:	10a02a04 	addi	r2,r2,-32600
  1245b0:	e0ffff17 	ldw	r3,-4(fp)
  1245b4:	18c00324 	muli	r3,r3,12
  1245b8:	10c5883a 	add	r2,r2,r3
  1245bc:	10800204 	addi	r2,r2,8
  1245c0:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
  1245c4:	008004f4 	movhi	r2,19
  1245c8:	10a02a04 	addi	r2,r2,-32600
  1245cc:	e0ffff17 	ldw	r3,-4(fp)
  1245d0:	18c00324 	muli	r3,r3,12
  1245d4:	10c5883a 	add	r2,r2,r3
  1245d8:	10000015 	stw	zero,0(r2)
  }
}
  1245dc:	e037883a 	mov	sp,fp
  1245e0:	df000017 	ldw	fp,0(sp)
  1245e4:	dec00104 	addi	sp,sp,4
  1245e8:	f800283a 	ret

001245ec <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
  1245ec:	defff904 	addi	sp,sp,-28
  1245f0:	df000615 	stw	fp,24(sp)
  1245f4:	df000604 	addi	fp,sp,24
  1245f8:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  1245fc:	0005303a 	rdctl	r2,status
  124600:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  124604:	e0fffc17 	ldw	r3,-16(fp)
  124608:	00bfff84 	movi	r2,-2
  12460c:	1884703a 	and	r2,r3,r2
  124610:	1001703a 	wrctl	status,r2
  
  return context;
  124614:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
  124618:	e0bffa15 	stw	r2,-24(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
  12461c:	d0a00a17 	ldw	r2,-32728(gp)
  124620:	10c000c4 	addi	r3,r2,3
  124624:	00bfff04 	movi	r2,-4
  124628:	1884703a 	and	r2,r3,r2
  12462c:	d0a00a15 	stw	r2,-32728(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
  124630:	d0e00a17 	ldw	r3,-32728(gp)
  124634:	e0bfff17 	ldw	r2,-4(fp)
  124638:	1887883a 	add	r3,r3,r2
  12463c:	008004f4 	movhi	r2,19
  124640:	108e2004 	addi	r2,r2,14464
  124644:	10c0062e 	bgeu	r2,r3,124660 <sbrk+0x74>
  124648:	e0bffa17 	ldw	r2,-24(fp)
  12464c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  124650:	e0bffd17 	ldw	r2,-12(fp)
  124654:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  124658:	00bfffc4 	movi	r2,-1
  12465c:	00000b06 	br	12468c <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
  124660:	d0a00a17 	ldw	r2,-32728(gp)
  124664:	e0bffb15 	stw	r2,-20(fp)
  heap_end += incr; 
  124668:	d0e00a17 	ldw	r3,-32728(gp)
  12466c:	e0bfff17 	ldw	r2,-4(fp)
  124670:	1885883a 	add	r2,r3,r2
  124674:	d0a00a15 	stw	r2,-32728(gp)
  124678:	e0bffa17 	ldw	r2,-24(fp)
  12467c:	e0bffe15 	stw	r2,-8(fp)
  124680:	e0bffe17 	ldw	r2,-8(fp)
  124684:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
  124688:	e0bffb17 	ldw	r2,-20(fp)
} 
  12468c:	e037883a 	mov	sp,fp
  124690:	df000017 	ldw	fp,0(sp)
  124694:	dec00104 	addi	sp,sp,4
  124698:	f800283a 	ret

0012469c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  12469c:	defffe04 	addi	sp,sp,-8
  1246a0:	dfc00115 	stw	ra,4(sp)
  1246a4:	df000015 	stw	fp,0(sp)
  1246a8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  1246ac:	008004f4 	movhi	r2,19
  1246b0:	10a4f204 	addi	r2,r2,-27704
  1246b4:	10800017 	ldw	r2,0(r2)
  1246b8:	10000526 	beq	r2,zero,1246d0 <alt_get_errno+0x34>
  1246bc:	008004f4 	movhi	r2,19
  1246c0:	10a4f204 	addi	r2,r2,-27704
  1246c4:	10800017 	ldw	r2,0(r2)
  1246c8:	103ee83a 	callr	r2
  1246cc:	00000206 	br	1246d8 <alt_get_errno+0x3c>
  1246d0:	008004f4 	movhi	r2,19
  1246d4:	10abdd04 	addi	r2,r2,-20620
}
  1246d8:	e037883a 	mov	sp,fp
  1246dc:	dfc00117 	ldw	ra,4(sp)
  1246e0:	df000017 	ldw	fp,0(sp)
  1246e4:	dec00204 	addi	sp,sp,8
  1246e8:	f800283a 	ret

001246ec <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
  1246ec:	defff904 	addi	sp,sp,-28
  1246f0:	dfc00615 	stw	ra,24(sp)
  1246f4:	df000515 	stw	fp,20(sp)
  1246f8:	df000504 	addi	fp,sp,20
  1246fc:	e13ffd15 	stw	r4,-12(fp)
  124700:	e17ffe15 	stw	r5,-8(fp)
  124704:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  124708:	e0bffd17 	ldw	r2,-12(fp)
  12470c:	10000616 	blt	r2,zero,124728 <write+0x3c>
  124710:	e0bffd17 	ldw	r2,-12(fp)
  124714:	10c00324 	muli	r3,r2,12
  124718:	008004f4 	movhi	r2,19
  12471c:	10a02a04 	addi	r2,r2,-32600
  124720:	1885883a 	add	r2,r3,r2
  124724:	00000106 	br	12472c <write+0x40>
  124728:	0005883a 	mov	r2,zero
  12472c:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
  124730:	e0bffb17 	ldw	r2,-20(fp)
  124734:	10002126 	beq	r2,zero,1247bc <write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
  124738:	e0bffb17 	ldw	r2,-20(fp)
  12473c:	10800217 	ldw	r2,8(r2)
  124740:	108000cc 	andi	r2,r2,3
  124744:	10001826 	beq	r2,zero,1247a8 <write+0xbc>
  124748:	e0bffb17 	ldw	r2,-20(fp)
  12474c:	10800017 	ldw	r2,0(r2)
  124750:	10800617 	ldw	r2,24(r2)
  124754:	10001426 	beq	r2,zero,1247a8 <write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
  124758:	e0bffb17 	ldw	r2,-20(fp)
  12475c:	10800017 	ldw	r2,0(r2)
  124760:	10800617 	ldw	r2,24(r2)
  124764:	e0ffff17 	ldw	r3,-4(fp)
  124768:	e13ffb17 	ldw	r4,-20(fp)
  12476c:	e17ffe17 	ldw	r5,-8(fp)
  124770:	180d883a 	mov	r6,r3
  124774:	103ee83a 	callr	r2
  124778:	e0bffc15 	stw	r2,-16(fp)
  12477c:	e0bffc17 	ldw	r2,-16(fp)
  124780:	1000070e 	bge	r2,zero,1247a0 <write+0xb4>
      {
        ALT_ERRNO = -rval;
  124784:	012469c0 	call	12469c <alt_get_errno>
  124788:	1007883a 	mov	r3,r2
  12478c:	e0bffc17 	ldw	r2,-16(fp)
  124790:	0085c83a 	sub	r2,zero,r2
  124794:	18800015 	stw	r2,0(r3)
        return -1;
  124798:	00bfffc4 	movi	r2,-1
  12479c:	00000c06 	br	1247d0 <write+0xe4>
      }
      return rval;
  1247a0:	e0bffc17 	ldw	r2,-16(fp)
  1247a4:	00000a06 	br	1247d0 <write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
  1247a8:	012469c0 	call	12469c <alt_get_errno>
  1247ac:	1007883a 	mov	r3,r2
  1247b0:	00800344 	movi	r2,13
  1247b4:	18800015 	stw	r2,0(r3)
  1247b8:	00000406 	br	1247cc <write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
  1247bc:	012469c0 	call	12469c <alt_get_errno>
  1247c0:	1007883a 	mov	r3,r2
  1247c4:	00801444 	movi	r2,81
  1247c8:	18800015 	stw	r2,0(r3)
  }
  return -1;
  1247cc:	00bfffc4 	movi	r2,-1
}
  1247d0:	e037883a 	mov	sp,fp
  1247d4:	dfc00117 	ldw	ra,4(sp)
  1247d8:	df000017 	ldw	fp,0(sp)
  1247dc:	dec00204 	addi	sp,sp,8
  1247e0:	f800283a 	ret

001247e4 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  1247e4:	defffd04 	addi	sp,sp,-12
  1247e8:	dfc00215 	stw	ra,8(sp)
  1247ec:	df000115 	stw	fp,4(sp)
  1247f0:	df000104 	addi	fp,sp,4
  1247f4:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
  1247f8:	e13fff17 	ldw	r4,-4(fp)
  1247fc:	014004f4 	movhi	r5,19
  124800:	2964ef04 	addi	r5,r5,-27716
  124804:	01265040 	call	126504 <alt_dev_llist_insert>
}
  124808:	e037883a 	mov	sp,fp
  12480c:	dfc00117 	ldw	ra,4(sp)
  124810:	df000017 	ldw	fp,0(sp)
  124814:	dec00204 	addi	sp,sp,8
  124818:	f800283a 	ret

0012481c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  12481c:	defffe04 	addi	sp,sp,-8
  124820:	dfc00115 	stw	ra,4(sp)
  124824:	df000015 	stw	fp,0(sp)
  124828:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  12482c:	008004f4 	movhi	r2,19
  124830:	10a4f204 	addi	r2,r2,-27704
  124834:	10800017 	ldw	r2,0(r2)
  124838:	10000526 	beq	r2,zero,124850 <alt_get_errno+0x34>
  12483c:	008004f4 	movhi	r2,19
  124840:	10a4f204 	addi	r2,r2,-27704
  124844:	10800017 	ldw	r2,0(r2)
  124848:	103ee83a 	callr	r2
  12484c:	00000206 	br	124858 <alt_get_errno+0x3c>
  124850:	008004f4 	movhi	r2,19
  124854:	10abdd04 	addi	r2,r2,-20620
}
  124858:	e037883a 	mov	sp,fp
  12485c:	dfc00117 	ldw	ra,4(sp)
  124860:	df000017 	ldw	fp,0(sp)
  124864:	dec00204 	addi	sp,sp,8
  124868:	f800283a 	ret

0012486c <alt_avalon_mutex_reg>:
/*
 * Register a Mutex device
 */

static ALT_INLINE int alt_avalon_mutex_reg (alt_mutex_dev* dev)
{
  12486c:	defffc04 	addi	sp,sp,-16
  124870:	dfc00315 	stw	ra,12(sp)
  124874:	df000215 	stw	fp,8(sp)
  124878:	df000204 	addi	fp,sp,8
  12487c:	e13fff15 	stw	r4,-4(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
  124880:	0005883a 	mov	r2,zero
  int ret_code;
  extern alt_llist alt_mutex_list;
  ret_code = ALT_SEM_CREATE (&dev->lock, 1);
  124884:	e0bffe15 	stw	r2,-8(fp)
  if (!ret_code)
  124888:	e0bffe17 	ldw	r2,-8(fp)
  12488c:	1000061e 	bne	r2,zero,1248a8 <alt_avalon_mutex_reg+0x3c>
  {
    ret_code = alt_dev_llist_insert((alt_dev_llist*) dev, &alt_mutex_list);
  124890:	e13fff17 	ldw	r4,-4(fp)
  124894:	014004f4 	movhi	r5,19
  124898:	2964f404 	addi	r5,r5,-27696
  12489c:	01265040 	call	126504 <alt_dev_llist_insert>
  1248a0:	e0bffe15 	stw	r2,-8(fp)
  1248a4:	00000606 	br	1248c0 <alt_avalon_mutex_reg+0x54>
  }
  else
  {
    ALT_ERRNO = ENOMEM;
  1248a8:	012481c0 	call	12481c <alt_get_errno>
  1248ac:	1007883a 	mov	r3,r2
  1248b0:	00800304 	movi	r2,12
  1248b4:	18800015 	stw	r2,0(r3)
    ret_code = -ENOMEM;
  1248b8:	00bffd04 	movi	r2,-12
  1248bc:	e0bffe15 	stw	r2,-8(fp)
  }

  return ret_code;
  1248c0:	e0bffe17 	ldw	r2,-8(fp)
}
  1248c4:	e037883a 	mov	sp,fp
  1248c8:	dfc00117 	ldw	ra,4(sp)
  1248cc:	df000017 	ldw	fp,0(sp)
  1248d0:	dec00204 	addi	sp,sp,8
  1248d4:	f800283a 	ret

001248d8 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  1248d8:	defffd04 	addi	sp,sp,-12
  1248dc:	dfc00215 	stw	ra,8(sp)
  1248e0:	df000115 	stw	fp,4(sp)
  1248e4:	df000104 	addi	fp,sp,4
  1248e8:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( CPUSLAVE1, CPUSlave1);
  1248ec:	0126e8c0 	call	126e8c <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  1248f0:	00800044 	movi	r2,1
  1248f4:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  1248f8:	e037883a 	mov	sp,fp
  1248fc:	dfc00117 	ldw	ra,4(sp)
  124900:	df000017 	ldw	fp,0(sp)
  124904:	dec00204 	addi	sp,sp,8
  124908:	f800283a 	ret

0012490c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  12490c:	defffe04 	addi	sp,sp,-8
  124910:	dfc00115 	stw	ra,4(sp)
  124914:	df000015 	stw	fp,0(sp)
  124918:	d839883a 	mov	fp,sp
    ALTERA_AVALON_JTAG_UART_INIT ( JTAGSLAVE1, JTAGSlave1);
  12491c:	010004f4 	movhi	r4,19
  124920:	21209404 	addi	r4,r4,-32176
  124924:	000b883a 	mov	r5,zero
  124928:	01800044 	movi	r6,1
  12492c:	0124b980 	call	124b98 <altera_avalon_jtag_uart_init>
  124930:	010004f4 	movhi	r4,19
  124934:	21208a04 	addi	r4,r4,-32216
  124938:	01247e40 	call	1247e4 <alt_dev_reg>
    ALTERA_AVALON_MUTEX_INIT ( MUTEX_0, mutex_0);
  12493c:	010004f4 	movhi	r4,19
  124940:	2124a204 	addi	r4,r4,-28024
  124944:	012486c0 	call	12486c <alt_avalon_mutex_reg>
    ALTERA_AVALON_UART_INIT ( UART_0, uart_0);
  124948:	010004f4 	movhi	r4,19
  12494c:	2124b004 	addi	r4,r4,-27968
  124950:	000b883a 	mov	r5,zero
  124954:	01800104 	movi	r6,4
  124958:	01258680 	call	125868 <altera_avalon_uart_init>
  12495c:	010004f4 	movhi	r4,19
  124960:	2124a604 	addi	r4,r4,-28008
  124964:	01247e40 	call	1247e4 <alt_dev_reg>
    ALTERA_UP_AVALON_VIDEO_CHARACTER_BUFFER_WITH_DMA_INIT ( VIDEO_CHARACTER_BUFFER_WITH_DMA_0, video_character_buffer_with_dma_0);
  124968:	008004f4 	movhi	r2,19
  12496c:	10a4d704 	addi	r2,r2,-27812
  124970:	10800a17 	ldw	r2,40(r2)
  124974:	10800104 	addi	r2,r2,4
  124978:	10800017 	ldw	r2,0(r2)
  12497c:	10ffffcc 	andi	r3,r2,65535
  124980:	008004f4 	movhi	r2,19
  124984:	10a4d704 	addi	r2,r2,-27812
  124988:	10c00c15 	stw	r3,48(r2)
  12498c:	008004f4 	movhi	r2,19
  124990:	10a4d704 	addi	r2,r2,-27812
  124994:	10800a17 	ldw	r2,40(r2)
  124998:	10800104 	addi	r2,r2,4
  12499c:	10800017 	ldw	r2,0(r2)
  1249a0:	1006d43a 	srli	r3,r2,16
  1249a4:	008004f4 	movhi	r2,19
  1249a8:	10a4d704 	addi	r2,r2,-27812
  1249ac:	10c00d15 	stw	r3,52(r2)
  1249b0:	008004f4 	movhi	r2,19
  1249b4:	10a4d704 	addi	r2,r2,-27812
  1249b8:	10800c17 	ldw	r2,48(r2)
  1249bc:	10801068 	cmpgeui	r2,r2,65
  1249c0:	1000081e 	bne	r2,zero,1249e4 <alt_sys_init+0xd8>
  1249c4:	008004f4 	movhi	r2,19
  1249c8:	10a4d704 	addi	r2,r2,-27812
  1249cc:	00c00fc4 	movi	r3,63
  1249d0:	10c00f15 	stw	r3,60(r2)
  1249d4:	008004f4 	movhi	r2,19
  1249d8:	10a4d704 	addi	r2,r2,-27812
  1249dc:	00c00184 	movi	r3,6
  1249e0:	10c01015 	stw	r3,64(r2)
  1249e4:	008004f4 	movhi	r2,19
  1249e8:	10a4d704 	addi	r2,r2,-27812
  1249ec:	10800d17 	ldw	r2,52(r2)
  1249f0:	10800868 	cmpgeui	r2,r2,33
  1249f4:	1000041e 	bne	r2,zero,124a08 <alt_sys_init+0xfc>
  1249f8:	008004f4 	movhi	r2,19
  1249fc:	10a4d704 	addi	r2,r2,-27812
  124a00:	00c007c4 	movi	r3,31
  124a04:	10c01115 	stw	r3,68(r2)
  124a08:	010004f4 	movhi	r4,19
  124a0c:	2124d704 	addi	r4,r4,-27812
  124a10:	01260480 	call	126048 <alt_up_char_buffer_init>
  124a14:	010004f4 	movhi	r4,19
  124a18:	2124d704 	addi	r4,r4,-27812
  124a1c:	01247e40 	call	1247e4 <alt_dev_reg>
}
  124a20:	e037883a 	mov	sp,fp
  124a24:	dfc00117 	ldw	ra,4(sp)
  124a28:	df000017 	ldw	fp,0(sp)
  124a2c:	dec00204 	addi	sp,sp,8
  124a30:	f800283a 	ret

00124a34 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  124a34:	defffa04 	addi	sp,sp,-24
  124a38:	dfc00515 	stw	ra,20(sp)
  124a3c:	df000415 	stw	fp,16(sp)
  124a40:	df000404 	addi	fp,sp,16
  124a44:	e13ffd15 	stw	r4,-12(fp)
  124a48:	e17ffe15 	stw	r5,-8(fp)
  124a4c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  124a50:	e0bffd17 	ldw	r2,-12(fp)
  124a54:	10800017 	ldw	r2,0(r2)
  124a58:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
  124a5c:	e0bffc17 	ldw	r2,-16(fp)
  124a60:	10c00a04 	addi	r3,r2,40
  124a64:	e0bffd17 	ldw	r2,-12(fp)
  124a68:	10800217 	ldw	r2,8(r2)
  124a6c:	1809883a 	mov	r4,r3
  124a70:	e17ffe17 	ldw	r5,-8(fp)
  124a74:	e1bfff17 	ldw	r6,-4(fp)
  124a78:	100f883a 	mov	r7,r2
  124a7c:	012505c0 	call	12505c <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
  124a80:	e037883a 	mov	sp,fp
  124a84:	dfc00117 	ldw	ra,4(sp)
  124a88:	df000017 	ldw	fp,0(sp)
  124a8c:	dec00204 	addi	sp,sp,8
  124a90:	f800283a 	ret

00124a94 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  124a94:	defffa04 	addi	sp,sp,-24
  124a98:	dfc00515 	stw	ra,20(sp)
  124a9c:	df000415 	stw	fp,16(sp)
  124aa0:	df000404 	addi	fp,sp,16
  124aa4:	e13ffd15 	stw	r4,-12(fp)
  124aa8:	e17ffe15 	stw	r5,-8(fp)
  124aac:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  124ab0:	e0bffd17 	ldw	r2,-12(fp)
  124ab4:	10800017 	ldw	r2,0(r2)
  124ab8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
  124abc:	e0bffc17 	ldw	r2,-16(fp)
  124ac0:	10c00a04 	addi	r3,r2,40
  124ac4:	e0bffd17 	ldw	r2,-12(fp)
  124ac8:	10800217 	ldw	r2,8(r2)
  124acc:	1809883a 	mov	r4,r3
  124ad0:	e17ffe17 	ldw	r5,-8(fp)
  124ad4:	e1bfff17 	ldw	r6,-4(fp)
  124ad8:	100f883a 	mov	r7,r2
  124adc:	01252680 	call	125268 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
  124ae0:	e037883a 	mov	sp,fp
  124ae4:	dfc00117 	ldw	ra,4(sp)
  124ae8:	df000017 	ldw	fp,0(sp)
  124aec:	dec00204 	addi	sp,sp,8
  124af0:	f800283a 	ret

00124af4 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
  124af4:	defffc04 	addi	sp,sp,-16
  124af8:	dfc00315 	stw	ra,12(sp)
  124afc:	df000215 	stw	fp,8(sp)
  124b00:	df000204 	addi	fp,sp,8
  124b04:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  124b08:	e0bfff17 	ldw	r2,-4(fp)
  124b0c:	10800017 	ldw	r2,0(r2)
  124b10:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
  124b14:	e0bffe17 	ldw	r2,-8(fp)
  124b18:	10c00a04 	addi	r3,r2,40
  124b1c:	e0bfff17 	ldw	r2,-4(fp)
  124b20:	10800217 	ldw	r2,8(r2)
  124b24:	1809883a 	mov	r4,r3
  124b28:	100b883a 	mov	r5,r2
  124b2c:	0124f080 	call	124f08 <altera_avalon_jtag_uart_close>
}
  124b30:	e037883a 	mov	sp,fp
  124b34:	dfc00117 	ldw	ra,4(sp)
  124b38:	df000017 	ldw	fp,0(sp)
  124b3c:	dec00204 	addi	sp,sp,8
  124b40:	f800283a 	ret

00124b44 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
  124b44:	defffa04 	addi	sp,sp,-24
  124b48:	dfc00515 	stw	ra,20(sp)
  124b4c:	df000415 	stw	fp,16(sp)
  124b50:	df000404 	addi	fp,sp,16
  124b54:	e13ffd15 	stw	r4,-12(fp)
  124b58:	e17ffe15 	stw	r5,-8(fp)
  124b5c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
  124b60:	e0bffd17 	ldw	r2,-12(fp)
  124b64:	10800017 	ldw	r2,0(r2)
  124b68:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
  124b6c:	e0bffc17 	ldw	r2,-16(fp)
  124b70:	10800a04 	addi	r2,r2,40
  124b74:	1009883a 	mov	r4,r2
  124b78:	e17ffe17 	ldw	r5,-8(fp)
  124b7c:	e1bfff17 	ldw	r6,-4(fp)
  124b80:	0124f700 	call	124f70 <altera_avalon_jtag_uart_ioctl>
}
  124b84:	e037883a 	mov	sp,fp
  124b88:	dfc00117 	ldw	ra,4(sp)
  124b8c:	df000017 	ldw	fp,0(sp)
  124b90:	dec00204 	addi	sp,sp,8
  124b94:	f800283a 	ret

00124b98 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
  124b98:	defffa04 	addi	sp,sp,-24
  124b9c:	dfc00515 	stw	ra,20(sp)
  124ba0:	df000415 	stw	fp,16(sp)
  124ba4:	df000404 	addi	fp,sp,16
  124ba8:	e13ffd15 	stw	r4,-12(fp)
  124bac:	e17ffe15 	stw	r5,-8(fp)
  124bb0:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  124bb4:	e0bffd17 	ldw	r2,-12(fp)
  124bb8:	00c00044 	movi	r3,1
  124bbc:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
  124bc0:	e0bffd17 	ldw	r2,-12(fp)
  124bc4:	10800017 	ldw	r2,0(r2)
  124bc8:	10800104 	addi	r2,r2,4
  124bcc:	1007883a 	mov	r3,r2
  124bd0:	e0bffd17 	ldw	r2,-12(fp)
  124bd4:	10800817 	ldw	r2,32(r2)
  124bd8:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
  124bdc:	e0fffe17 	ldw	r3,-8(fp)
  124be0:	e0bfff17 	ldw	r2,-4(fp)
  124be4:	d8000015 	stw	zero,0(sp)
  124be8:	1809883a 	mov	r4,r3
  124bec:	100b883a 	mov	r5,r2
  124bf0:	018004b4 	movhi	r6,18
  124bf4:	31931704 	addi	r6,r6,19548
  124bf8:	e1fffd17 	ldw	r7,-12(fp)
  124bfc:	01268e80 	call	1268e8 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
  124c00:	e0bffd17 	ldw	r2,-12(fp)
  124c04:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
  124c08:	e0bffd17 	ldw	r2,-12(fp)
  124c0c:	10c00204 	addi	r3,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
  124c10:	008004f4 	movhi	r2,19
  124c14:	10abe504 	addi	r2,r2,-20588
  124c18:	10800017 	ldw	r2,0(r2)
  124c1c:	1809883a 	mov	r4,r3
  124c20:	100b883a 	mov	r5,r2
  124c24:	018004b4 	movhi	r6,18
  124c28:	31939804 	addi	r6,r6,20064
  124c2c:	e1fffd17 	ldw	r7,-12(fp)
  124c30:	01263300 	call	126330 <alt_alarm_start>
  124c34:	1000040e 	bge	r2,zero,124c48 <altera_avalon_jtag_uart_init+0xb0>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
  124c38:	e0fffd17 	ldw	r3,-12(fp)
  124c3c:	00a00034 	movhi	r2,32768
  124c40:	10bfffc4 	addi	r2,r2,-1
  124c44:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
  124c48:	e037883a 	mov	sp,fp
  124c4c:	dfc00117 	ldw	ra,4(sp)
  124c50:	df000017 	ldw	fp,0(sp)
  124c54:	dec00204 	addi	sp,sp,8
  124c58:	f800283a 	ret

00124c5c <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
  124c5c:	defff804 	addi	sp,sp,-32
  124c60:	df000715 	stw	fp,28(sp)
  124c64:	df000704 	addi	fp,sp,28
  124c68:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
  124c6c:	e0bfff17 	ldw	r2,-4(fp)
  124c70:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
  124c74:	e0bffb17 	ldw	r2,-20(fp)
  124c78:	10800017 	ldw	r2,0(r2)
  124c7c:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  124c80:	e0bffc17 	ldw	r2,-16(fp)
  124c84:	10800104 	addi	r2,r2,4
  124c88:	10800037 	ldwio	r2,0(r2)
  124c8c:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
  124c90:	e0bffd17 	ldw	r2,-12(fp)
  124c94:	1080c00c 	andi	r2,r2,768
  124c98:	1000011e 	bne	r2,zero,124ca0 <altera_avalon_jtag_uart_irq+0x44>
      break;
  124c9c:	00006c06 	br	124e50 <altera_avalon_jtag_uart_irq+0x1f4>

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
  124ca0:	e0bffd17 	ldw	r2,-12(fp)
  124ca4:	1080400c 	andi	r2,r2,256
  124ca8:	10003426 	beq	r2,zero,124d7c <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
  124cac:	00800074 	movhi	r2,1
  124cb0:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  124cb4:	e0bffb17 	ldw	r2,-20(fp)
  124cb8:	10800a17 	ldw	r2,40(r2)
  124cbc:	10800044 	addi	r2,r2,1
  124cc0:	1081ffcc 	andi	r2,r2,2047
  124cc4:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
  124cc8:	e0bffb17 	ldw	r2,-20(fp)
  124ccc:	10c00b17 	ldw	r3,44(r2)
  124cd0:	e0bffe17 	ldw	r2,-8(fp)
  124cd4:	1880011e 	bne	r3,r2,124cdc <altera_avalon_jtag_uart_irq+0x80>
          break;
  124cd8:	00001606 	br	124d34 <altera_avalon_jtag_uart_irq+0xd8>

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
  124cdc:	e0bffc17 	ldw	r2,-16(fp)
  124ce0:	10800037 	ldwio	r2,0(r2)
  124ce4:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
  124ce8:	e0bff917 	ldw	r2,-28(fp)
  124cec:	10a0000c 	andi	r2,r2,32768
  124cf0:	1000011e 	bne	r2,zero,124cf8 <altera_avalon_jtag_uart_irq+0x9c>
          break;
  124cf4:	00000f06 	br	124d34 <altera_avalon_jtag_uart_irq+0xd8>

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
  124cf8:	e0bffb17 	ldw	r2,-20(fp)
  124cfc:	10800a17 	ldw	r2,40(r2)
  124d00:	e0fff917 	ldw	r3,-28(fp)
  124d04:	1809883a 	mov	r4,r3
  124d08:	e0fffb17 	ldw	r3,-20(fp)
  124d0c:	1885883a 	add	r2,r3,r2
  124d10:	10800e04 	addi	r2,r2,56
  124d14:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  124d18:	e0bffb17 	ldw	r2,-20(fp)
  124d1c:	10800a17 	ldw	r2,40(r2)
  124d20:	10800044 	addi	r2,r2,1
  124d24:	10c1ffcc 	andi	r3,r2,2047
  124d28:	e0bffb17 	ldw	r2,-20(fp)
  124d2c:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
  124d30:	003fe006 	br	124cb4 <__alt_data_end+0xffff1434>

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
  124d34:	e0bff917 	ldw	r2,-28(fp)
  124d38:	10bfffec 	andhi	r2,r2,65535
  124d3c:	10000f26 	beq	r2,zero,124d7c <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  124d40:	e0bffb17 	ldw	r2,-20(fp)
  124d44:	10c00817 	ldw	r3,32(r2)
  124d48:	00bfff84 	movi	r2,-2
  124d4c:	1886703a 	and	r3,r3,r2
  124d50:	e0bffb17 	ldw	r2,-20(fp)
  124d54:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
  124d58:	e0bffc17 	ldw	r2,-16(fp)
  124d5c:	10800104 	addi	r2,r2,4
  124d60:	1007883a 	mov	r3,r2
  124d64:	e0bffb17 	ldw	r2,-20(fp)
  124d68:	10800817 	ldw	r2,32(r2)
  124d6c:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  124d70:	e0bffc17 	ldw	r2,-16(fp)
  124d74:	10800104 	addi	r2,r2,4
  124d78:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
  124d7c:	e0bffd17 	ldw	r2,-12(fp)
  124d80:	1080800c 	andi	r2,r2,512
  124d84:	10003126 	beq	r2,zero,124e4c <altera_avalon_jtag_uart_irq+0x1f0>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
  124d88:	e0bffd17 	ldw	r2,-12(fp)
  124d8c:	1004d43a 	srli	r2,r2,16
  124d90:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
  124d94:	00001406 	br	124de8 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
  124d98:	e0bffc17 	ldw	r2,-16(fp)
  124d9c:	e0fffb17 	ldw	r3,-20(fp)
  124da0:	18c00d17 	ldw	r3,52(r3)
  124da4:	e13ffb17 	ldw	r4,-20(fp)
  124da8:	20c7883a 	add	r3,r4,r3
  124dac:	18c20e04 	addi	r3,r3,2104
  124db0:	18c00003 	ldbu	r3,0(r3)
  124db4:	18c03fcc 	andi	r3,r3,255
  124db8:	18c0201c 	xori	r3,r3,128
  124dbc:	18ffe004 	addi	r3,r3,-128
  124dc0:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  124dc4:	e0bffb17 	ldw	r2,-20(fp)
  124dc8:	10800d17 	ldw	r2,52(r2)
  124dcc:	10800044 	addi	r2,r2,1
  124dd0:	10c1ffcc 	andi	r3,r2,2047
  124dd4:	e0bffb17 	ldw	r2,-20(fp)
  124dd8:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
  124ddc:	e0bffa17 	ldw	r2,-24(fp)
  124de0:	10bfffc4 	addi	r2,r2,-1
  124de4:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
  124de8:	e0bffa17 	ldw	r2,-24(fp)
  124dec:	10000526 	beq	r2,zero,124e04 <altera_avalon_jtag_uart_irq+0x1a8>
  124df0:	e0bffb17 	ldw	r2,-20(fp)
  124df4:	10c00d17 	ldw	r3,52(r2)
  124df8:	e0bffb17 	ldw	r2,-20(fp)
  124dfc:	10800c17 	ldw	r2,48(r2)
  124e00:	18bfe51e 	bne	r3,r2,124d98 <__alt_data_end+0xffff1518>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
  124e04:	e0bffa17 	ldw	r2,-24(fp)
  124e08:	10001026 	beq	r2,zero,124e4c <altera_avalon_jtag_uart_irq+0x1f0>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  124e0c:	e0bffb17 	ldw	r2,-20(fp)
  124e10:	10c00817 	ldw	r3,32(r2)
  124e14:	00bfff44 	movi	r2,-3
  124e18:	1886703a 	and	r3,r3,r2
  124e1c:	e0bffb17 	ldw	r2,-20(fp)
  124e20:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  124e24:	e0bffb17 	ldw	r2,-20(fp)
  124e28:	10800017 	ldw	r2,0(r2)
  124e2c:	10800104 	addi	r2,r2,4
  124e30:	1007883a 	mov	r3,r2
  124e34:	e0bffb17 	ldw	r2,-20(fp)
  124e38:	10800817 	ldw	r2,32(r2)
  124e3c:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  124e40:	e0bffc17 	ldw	r2,-16(fp)
  124e44:	10800104 	addi	r2,r2,4
  124e48:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
  124e4c:	003f8c06 	br	124c80 <__alt_data_end+0xffff1400>
}
  124e50:	e037883a 	mov	sp,fp
  124e54:	df000017 	ldw	fp,0(sp)
  124e58:	dec00104 	addi	sp,sp,4
  124e5c:	f800283a 	ret

00124e60 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
  124e60:	defff804 	addi	sp,sp,-32
  124e64:	df000715 	stw	fp,28(sp)
  124e68:	df000704 	addi	fp,sp,28
  124e6c:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
  124e70:	e0bffb17 	ldw	r2,-20(fp)
  124e74:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
  124e78:	e0bff917 	ldw	r2,-28(fp)
  124e7c:	10800017 	ldw	r2,0(r2)
  124e80:	10800104 	addi	r2,r2,4
  124e84:	10800037 	ldwio	r2,0(r2)
  124e88:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
  124e8c:	e0bffa17 	ldw	r2,-24(fp)
  124e90:	1081000c 	andi	r2,r2,1024
  124e94:	10000b26 	beq	r2,zero,124ec4 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
  124e98:	e0bff917 	ldw	r2,-28(fp)
  124e9c:	10800017 	ldw	r2,0(r2)
  124ea0:	10800104 	addi	r2,r2,4
  124ea4:	1007883a 	mov	r3,r2
  124ea8:	e0bff917 	ldw	r2,-28(fp)
  124eac:	10800817 	ldw	r2,32(r2)
  124eb0:	10810014 	ori	r2,r2,1024
  124eb4:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
  124eb8:	e0bff917 	ldw	r2,-28(fp)
  124ebc:	10000915 	stw	zero,36(r2)
  124ec0:	00000a06 	br	124eec <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
  124ec4:	e0bff917 	ldw	r2,-28(fp)
  124ec8:	10c00917 	ldw	r3,36(r2)
  124ecc:	00a00034 	movhi	r2,32768
  124ed0:	10bfff04 	addi	r2,r2,-4
  124ed4:	10c00536 	bltu	r2,r3,124eec <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
  124ed8:	e0bff917 	ldw	r2,-28(fp)
  124edc:	10800917 	ldw	r2,36(r2)
  124ee0:	10c00044 	addi	r3,r2,1
  124ee4:	e0bff917 	ldw	r2,-28(fp)
  124ee8:	10c00915 	stw	r3,36(r2)
  124eec:	008004f4 	movhi	r2,19
  124ef0:	10abe504 	addi	r2,r2,-20588
  124ef4:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
  124ef8:	e037883a 	mov	sp,fp
  124efc:	df000017 	ldw	fp,0(sp)
  124f00:	dec00104 	addi	sp,sp,4
  124f04:	f800283a 	ret

00124f08 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
  124f08:	defffd04 	addi	sp,sp,-12
  124f0c:	df000215 	stw	fp,8(sp)
  124f10:	df000204 	addi	fp,sp,8
  124f14:	e13ffe15 	stw	r4,-8(fp)
  124f18:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  124f1c:	00000506 	br	124f34 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
  124f20:	e0bfff17 	ldw	r2,-4(fp)
  124f24:	1090000c 	andi	r2,r2,16384
  124f28:	10000226 	beq	r2,zero,124f34 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
  124f2c:	00bffd44 	movi	r2,-11
  124f30:	00000b06 	br	124f60 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  124f34:	e0bffe17 	ldw	r2,-8(fp)
  124f38:	10c00d17 	ldw	r3,52(r2)
  124f3c:	e0bffe17 	ldw	r2,-8(fp)
  124f40:	10800c17 	ldw	r2,48(r2)
  124f44:	18800526 	beq	r3,r2,124f5c <altera_avalon_jtag_uart_close+0x54>
  124f48:	e0bffe17 	ldw	r2,-8(fp)
  124f4c:	10c00917 	ldw	r3,36(r2)
  124f50:	e0bffe17 	ldw	r2,-8(fp)
  124f54:	10800117 	ldw	r2,4(r2)
  124f58:	18bff136 	bltu	r3,r2,124f20 <__alt_data_end+0xffff16a0>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
  124f5c:	0005883a 	mov	r2,zero
}
  124f60:	e037883a 	mov	sp,fp
  124f64:	df000017 	ldw	fp,0(sp)
  124f68:	dec00104 	addi	sp,sp,4
  124f6c:	f800283a 	ret

00124f70 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
  124f70:	defffa04 	addi	sp,sp,-24
  124f74:	df000515 	stw	fp,20(sp)
  124f78:	df000504 	addi	fp,sp,20
  124f7c:	e13ffd15 	stw	r4,-12(fp)
  124f80:	e17ffe15 	stw	r5,-8(fp)
  124f84:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
  124f88:	00bff9c4 	movi	r2,-25
  124f8c:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
  124f90:	e0bffe17 	ldw	r2,-8(fp)
  124f94:	10da8060 	cmpeqi	r3,r2,27137
  124f98:	1800031e 	bne	r3,zero,124fa8 <altera_avalon_jtag_uart_ioctl+0x38>
  124f9c:	109a80a0 	cmpeqi	r2,r2,27138
  124fa0:	1000191e 	bne	r2,zero,125008 <altera_avalon_jtag_uart_ioctl+0x98>
      rc = 0;
    }
    break;

  default:
    break;
  124fa4:	00002806 	br	125048 <altera_avalon_jtag_uart_ioctl+0xd8>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
  124fa8:	e0bffd17 	ldw	r2,-12(fp)
  124fac:	10c00117 	ldw	r3,4(r2)
  124fb0:	00a00034 	movhi	r2,32768
  124fb4:	10bfffc4 	addi	r2,r2,-1
  124fb8:	18801226 	beq	r3,r2,125004 <altera_avalon_jtag_uart_ioctl+0x94>
    {
      int timeout = *((int *)arg);
  124fbc:	e0bfff17 	ldw	r2,-4(fp)
  124fc0:	10800017 	ldw	r2,0(r2)
  124fc4:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
  124fc8:	e0bffc17 	ldw	r2,-16(fp)
  124fcc:	10800090 	cmplti	r2,r2,2
  124fd0:	1000061e 	bne	r2,zero,124fec <altera_avalon_jtag_uart_ioctl+0x7c>
  124fd4:	e0fffc17 	ldw	r3,-16(fp)
  124fd8:	00a00034 	movhi	r2,32768
  124fdc:	10bfffc4 	addi	r2,r2,-1
  124fe0:	18800226 	beq	r3,r2,124fec <altera_avalon_jtag_uart_ioctl+0x7c>
  124fe4:	e0bffc17 	ldw	r2,-16(fp)
  124fe8:	00000206 	br	124ff4 <altera_avalon_jtag_uart_ioctl+0x84>
  124fec:	00a00034 	movhi	r2,32768
  124ff0:	10bfff84 	addi	r2,r2,-2
  124ff4:	e0fffd17 	ldw	r3,-12(fp)
  124ff8:	18800115 	stw	r2,4(r3)
      rc = 0;
  124ffc:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
  125000:	00001106 	br	125048 <altera_avalon_jtag_uart_ioctl+0xd8>
  125004:	00001006 	br	125048 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
  125008:	e0bffd17 	ldw	r2,-12(fp)
  12500c:	10c00117 	ldw	r3,4(r2)
  125010:	00a00034 	movhi	r2,32768
  125014:	10bfffc4 	addi	r2,r2,-1
  125018:	18800a26 	beq	r3,r2,125044 <altera_avalon_jtag_uart_ioctl+0xd4>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
  12501c:	e0bffd17 	ldw	r2,-12(fp)
  125020:	10c00917 	ldw	r3,36(r2)
  125024:	e0bffd17 	ldw	r2,-12(fp)
  125028:	10800117 	ldw	r2,4(r2)
  12502c:	1885803a 	cmpltu	r2,r3,r2
  125030:	10c03fcc 	andi	r3,r2,255
  125034:	e0bfff17 	ldw	r2,-4(fp)
  125038:	10c00015 	stw	r3,0(r2)
      rc = 0;
  12503c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
  125040:	00000006 	br	125044 <altera_avalon_jtag_uart_ioctl+0xd4>
  125044:	0001883a 	nop

  default:
    break;
  }

  return rc;
  125048:	e0bffb17 	ldw	r2,-20(fp)
}
  12504c:	e037883a 	mov	sp,fp
  125050:	df000017 	ldw	fp,0(sp)
  125054:	dec00104 	addi	sp,sp,4
  125058:	f800283a 	ret

0012505c <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
  12505c:	defff304 	addi	sp,sp,-52
  125060:	dfc00c15 	stw	ra,48(sp)
  125064:	df000b15 	stw	fp,44(sp)
  125068:	df000b04 	addi	fp,sp,44
  12506c:	e13ffc15 	stw	r4,-16(fp)
  125070:	e17ffd15 	stw	r5,-12(fp)
  125074:	e1bffe15 	stw	r6,-8(fp)
  125078:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
  12507c:	e0bffd17 	ldw	r2,-12(fp)
  125080:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  125084:	00004906 	br	1251ac <altera_avalon_jtag_uart_read+0x150>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
  125088:	e0bffc17 	ldw	r2,-16(fp)
  12508c:	10800a17 	ldw	r2,40(r2)
  125090:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
  125094:	e0bffc17 	ldw	r2,-16(fp)
  125098:	10800b17 	ldw	r2,44(r2)
  12509c:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
  1250a0:	e0fff717 	ldw	r3,-36(fp)
  1250a4:	e0bff817 	ldw	r2,-32(fp)
  1250a8:	18800536 	bltu	r3,r2,1250c0 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
  1250ac:	e0fff717 	ldw	r3,-36(fp)
  1250b0:	e0bff817 	ldw	r2,-32(fp)
  1250b4:	1885c83a 	sub	r2,r3,r2
  1250b8:	e0bff615 	stw	r2,-40(fp)
  1250bc:	00000406 	br	1250d0 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
  1250c0:	00c20004 	movi	r3,2048
  1250c4:	e0bff817 	ldw	r2,-32(fp)
  1250c8:	1885c83a 	sub	r2,r3,r2
  1250cc:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
  1250d0:	e0bff617 	ldw	r2,-40(fp)
  1250d4:	1000011e 	bne	r2,zero,1250dc <altera_avalon_jtag_uart_read+0x80>
        break; /* No more data available */
  1250d8:	00001d06 	br	125150 <altera_avalon_jtag_uart_read+0xf4>

      if (n > space)
  1250dc:	e0fffe17 	ldw	r3,-8(fp)
  1250e0:	e0bff617 	ldw	r2,-40(fp)
  1250e4:	1880022e 	bgeu	r3,r2,1250f0 <altera_avalon_jtag_uart_read+0x94>
        n = space;
  1250e8:	e0bffe17 	ldw	r2,-8(fp)
  1250ec:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
  1250f0:	e0bff817 	ldw	r2,-32(fp)
  1250f4:	10800e04 	addi	r2,r2,56
  1250f8:	e0fffc17 	ldw	r3,-16(fp)
  1250fc:	1885883a 	add	r2,r3,r2
  125100:	e13ff517 	ldw	r4,-44(fp)
  125104:	100b883a 	mov	r5,r2
  125108:	e1bff617 	ldw	r6,-40(fp)
  12510c:	0122fa00 	call	122fa0 <memcpy>
      ptr   += n;
  125110:	e0fff517 	ldw	r3,-44(fp)
  125114:	e0bff617 	ldw	r2,-40(fp)
  125118:	1885883a 	add	r2,r3,r2
  12511c:	e0bff515 	stw	r2,-44(fp)
      space -= n;
  125120:	e0fffe17 	ldw	r3,-8(fp)
  125124:	e0bff617 	ldw	r2,-40(fp)
  125128:	1885c83a 	sub	r2,r3,r2
  12512c:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  125130:	e0fff817 	ldw	r3,-32(fp)
  125134:	e0bff617 	ldw	r2,-40(fp)
  125138:	1885883a 	add	r2,r3,r2
  12513c:	10c1ffcc 	andi	r3,r2,2047
  125140:	e0bffc17 	ldw	r2,-16(fp)
  125144:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
  125148:	e0bffe17 	ldw	r2,-8(fp)
  12514c:	00bfce16 	blt	zero,r2,125088 <__alt_data_end+0xffff1808>

    /* If we read any data then return it */
    if (ptr != buffer)
  125150:	e0fff517 	ldw	r3,-44(fp)
  125154:	e0bffd17 	ldw	r2,-12(fp)
  125158:	18800126 	beq	r3,r2,125160 <altera_avalon_jtag_uart_read+0x104>
      break;
  12515c:	00001506 	br	1251b4 <altera_avalon_jtag_uart_read+0x158>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
  125160:	e0bfff17 	ldw	r2,-4(fp)
  125164:	1090000c 	andi	r2,r2,16384
  125168:	10000126 	beq	r2,zero,125170 <altera_avalon_jtag_uart_read+0x114>
      break;
  12516c:	00001106 	br	1251b4 <altera_avalon_jtag_uart_read+0x158>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
  125170:	0001883a 	nop
  125174:	e0bffc17 	ldw	r2,-16(fp)
  125178:	10c00a17 	ldw	r3,40(r2)
  12517c:	e0bff717 	ldw	r2,-36(fp)
  125180:	1880051e 	bne	r3,r2,125198 <altera_avalon_jtag_uart_read+0x13c>
  125184:	e0bffc17 	ldw	r2,-16(fp)
  125188:	10c00917 	ldw	r3,36(r2)
  12518c:	e0bffc17 	ldw	r2,-16(fp)
  125190:	10800117 	ldw	r2,4(r2)
  125194:	18bff736 	bltu	r3,r2,125174 <__alt_data_end+0xffff18f4>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
  125198:	e0bffc17 	ldw	r2,-16(fp)
  12519c:	10c00a17 	ldw	r3,40(r2)
  1251a0:	e0bff717 	ldw	r2,-36(fp)
  1251a4:	1880011e 	bne	r3,r2,1251ac <altera_avalon_jtag_uart_read+0x150>
      break;
  1251a8:	00000206 	br	1251b4 <altera_avalon_jtag_uart_read+0x158>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  1251ac:	e0bffe17 	ldw	r2,-8(fp)
  1251b0:	00bfb516 	blt	zero,r2,125088 <__alt_data_end+0xffff1808>
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
  1251b4:	e0fff517 	ldw	r3,-44(fp)
  1251b8:	e0bffd17 	ldw	r2,-12(fp)
  1251bc:	18801826 	beq	r3,r2,125220 <altera_avalon_jtag_uart_read+0x1c4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  1251c0:	0005303a 	rdctl	r2,status
  1251c4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  1251c8:	e0fffa17 	ldw	r3,-24(fp)
  1251cc:	00bfff84 	movi	r2,-2
  1251d0:	1884703a 	and	r2,r3,r2
  1251d4:	1001703a 	wrctl	status,r2
  
  return context;
  1251d8:	e0bffa17 	ldw	r2,-24(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
  1251dc:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  1251e0:	e0bffc17 	ldw	r2,-16(fp)
  1251e4:	10800817 	ldw	r2,32(r2)
  1251e8:	10c00054 	ori	r3,r2,1
  1251ec:	e0bffc17 	ldw	r2,-16(fp)
  1251f0:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  1251f4:	e0bffc17 	ldw	r2,-16(fp)
  1251f8:	10800017 	ldw	r2,0(r2)
  1251fc:	10800104 	addi	r2,r2,4
  125200:	1007883a 	mov	r3,r2
  125204:	e0bffc17 	ldw	r2,-16(fp)
  125208:	10800817 	ldw	r2,32(r2)
  12520c:	18800035 	stwio	r2,0(r3)
  125210:	e0bff917 	ldw	r2,-28(fp)
  125214:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  125218:	e0bffb17 	ldw	r2,-20(fp)
  12521c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
  125220:	e0fff517 	ldw	r3,-44(fp)
  125224:	e0bffd17 	ldw	r2,-12(fp)
  125228:	18800426 	beq	r3,r2,12523c <altera_avalon_jtag_uart_read+0x1e0>
    return ptr - buffer;
  12522c:	e0fff517 	ldw	r3,-44(fp)
  125230:	e0bffd17 	ldw	r2,-12(fp)
  125234:	1885c83a 	sub	r2,r3,r2
  125238:	00000606 	br	125254 <altera_avalon_jtag_uart_read+0x1f8>
  else if (flags & O_NONBLOCK)
  12523c:	e0bfff17 	ldw	r2,-4(fp)
  125240:	1090000c 	andi	r2,r2,16384
  125244:	10000226 	beq	r2,zero,125250 <altera_avalon_jtag_uart_read+0x1f4>
    return -EWOULDBLOCK;
  125248:	00bffd44 	movi	r2,-11
  12524c:	00000106 	br	125254 <altera_avalon_jtag_uart_read+0x1f8>
  else
    return -EIO;
  125250:	00bffec4 	movi	r2,-5
}
  125254:	e037883a 	mov	sp,fp
  125258:	dfc00117 	ldw	ra,4(sp)
  12525c:	df000017 	ldw	fp,0(sp)
  125260:	dec00204 	addi	sp,sp,8
  125264:	f800283a 	ret

00125268 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  125268:	defff304 	addi	sp,sp,-52
  12526c:	dfc00c15 	stw	ra,48(sp)
  125270:	df000b15 	stw	fp,44(sp)
  125274:	df000b04 	addi	fp,sp,44
  125278:	e13ffc15 	stw	r4,-16(fp)
  12527c:	e17ffd15 	stw	r5,-12(fp)
  125280:	e1bffe15 	stw	r6,-8(fp)
  125284:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
  125288:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
  12528c:	e0bffd17 	ldw	r2,-12(fp)
  125290:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  125294:	00003806 	br	125378 <altera_avalon_jtag_uart_write+0x110>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
  125298:	e0bffc17 	ldw	r2,-16(fp)
  12529c:	10800c17 	ldw	r2,48(r2)
  1252a0:	e0bff815 	stw	r2,-32(fp)
      out = sp->tx_out;
  1252a4:	e0bffc17 	ldw	r2,-16(fp)
  1252a8:	10800d17 	ldw	r2,52(r2)
  1252ac:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
  1252b0:	e0fff817 	ldw	r3,-32(fp)
  1252b4:	e0bff517 	ldw	r2,-44(fp)
  1252b8:	1880062e 	bgeu	r3,r2,1252d4 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
  1252bc:	e0fff517 	ldw	r3,-44(fp)
  1252c0:	e0bff817 	ldw	r2,-32(fp)
  1252c4:	1885c83a 	sub	r2,r3,r2
  1252c8:	10bfffc4 	addi	r2,r2,-1
  1252cc:	e0bff615 	stw	r2,-40(fp)
  1252d0:	00000b06 	br	125300 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
  1252d4:	e0bff517 	ldw	r2,-44(fp)
  1252d8:	10000526 	beq	r2,zero,1252f0 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
  1252dc:	00c20004 	movi	r3,2048
  1252e0:	e0bff817 	ldw	r2,-32(fp)
  1252e4:	1885c83a 	sub	r2,r3,r2
  1252e8:	e0bff615 	stw	r2,-40(fp)
  1252ec:	00000406 	br	125300 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
  1252f0:	00c1ffc4 	movi	r3,2047
  1252f4:	e0bff817 	ldw	r2,-32(fp)
  1252f8:	1885c83a 	sub	r2,r3,r2
  1252fc:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
  125300:	e0bff617 	ldw	r2,-40(fp)
  125304:	1000011e 	bne	r2,zero,12530c <altera_avalon_jtag_uart_write+0xa4>
        break;
  125308:	00001d06 	br	125380 <altera_avalon_jtag_uart_write+0x118>

      if (n > count)
  12530c:	e0fffe17 	ldw	r3,-8(fp)
  125310:	e0bff617 	ldw	r2,-40(fp)
  125314:	1880022e 	bgeu	r3,r2,125320 <altera_avalon_jtag_uart_write+0xb8>
        n = count;
  125318:	e0bffe17 	ldw	r2,-8(fp)
  12531c:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
  125320:	e0bff817 	ldw	r2,-32(fp)
  125324:	10820e04 	addi	r2,r2,2104
  125328:	e0fffc17 	ldw	r3,-16(fp)
  12532c:	1885883a 	add	r2,r3,r2
  125330:	1009883a 	mov	r4,r2
  125334:	e17ffd17 	ldw	r5,-12(fp)
  125338:	e1bff617 	ldw	r6,-40(fp)
  12533c:	0122fa00 	call	122fa0 <memcpy>
      ptr   += n;
  125340:	e0fffd17 	ldw	r3,-12(fp)
  125344:	e0bff617 	ldw	r2,-40(fp)
  125348:	1885883a 	add	r2,r3,r2
  12534c:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
  125350:	e0fffe17 	ldw	r3,-8(fp)
  125354:	e0bff617 	ldw	r2,-40(fp)
  125358:	1885c83a 	sub	r2,r3,r2
  12535c:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  125360:	e0fff817 	ldw	r3,-32(fp)
  125364:	e0bff617 	ldw	r2,-40(fp)
  125368:	1885883a 	add	r2,r3,r2
  12536c:	10c1ffcc 	andi	r3,r2,2047
  125370:	e0bffc17 	ldw	r2,-16(fp)
  125374:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  125378:	e0bffe17 	ldw	r2,-8(fp)
  12537c:	00bfc616 	blt	zero,r2,125298 <__alt_data_end+0xffff1a18>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  125380:	0005303a 	rdctl	r2,status
  125384:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  125388:	e0fffa17 	ldw	r3,-24(fp)
  12538c:	00bfff84 	movi	r2,-2
  125390:	1884703a 	and	r2,r3,r2
  125394:	1001703a 	wrctl	status,r2
  
  return context;
  125398:	e0bffa17 	ldw	r2,-24(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
  12539c:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  1253a0:	e0bffc17 	ldw	r2,-16(fp)
  1253a4:	10800817 	ldw	r2,32(r2)
  1253a8:	10c00094 	ori	r3,r2,2
  1253ac:	e0bffc17 	ldw	r2,-16(fp)
  1253b0:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  1253b4:	e0bffc17 	ldw	r2,-16(fp)
  1253b8:	10800017 	ldw	r2,0(r2)
  1253bc:	10800104 	addi	r2,r2,4
  1253c0:	1007883a 	mov	r3,r2
  1253c4:	e0bffc17 	ldw	r2,-16(fp)
  1253c8:	10800817 	ldw	r2,32(r2)
  1253cc:	18800035 	stwio	r2,0(r3)
  1253d0:	e0bff917 	ldw	r2,-28(fp)
  1253d4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  1253d8:	e0bffb17 	ldw	r2,-20(fp)
  1253dc:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
  1253e0:	e0bffe17 	ldw	r2,-8(fp)
  1253e4:	0080120e 	bge	zero,r2,125430 <altera_avalon_jtag_uart_write+0x1c8>
    {
      if (flags & O_NONBLOCK)
  1253e8:	e0bfff17 	ldw	r2,-4(fp)
  1253ec:	1090000c 	andi	r2,r2,16384
  1253f0:	10000126 	beq	r2,zero,1253f8 <altera_avalon_jtag_uart_write+0x190>
        break;
  1253f4:	00001006 	br	125438 <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
  1253f8:	0001883a 	nop
  1253fc:	e0bffc17 	ldw	r2,-16(fp)
  125400:	10c00d17 	ldw	r3,52(r2)
  125404:	e0bff517 	ldw	r2,-44(fp)
  125408:	1880051e 	bne	r3,r2,125420 <altera_avalon_jtag_uart_write+0x1b8>
  12540c:	e0bffc17 	ldw	r2,-16(fp)
  125410:	10c00917 	ldw	r3,36(r2)
  125414:	e0bffc17 	ldw	r2,-16(fp)
  125418:	10800117 	ldw	r2,4(r2)
  12541c:	18bff736 	bltu	r3,r2,1253fc <__alt_data_end+0xffff1b7c>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
  125420:	e0bffc17 	ldw	r2,-16(fp)
  125424:	10800917 	ldw	r2,36(r2)
  125428:	10000126 	beq	r2,zero,125430 <altera_avalon_jtag_uart_write+0x1c8>
         break;
  12542c:	00000206 	br	125438 <altera_avalon_jtag_uart_write+0x1d0>
    }
  }
  while (count > 0);
  125430:	e0bffe17 	ldw	r2,-8(fp)
  125434:	00bf9716 	blt	zero,r2,125294 <__alt_data_end+0xffff1a14>
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
  125438:	e0fffd17 	ldw	r3,-12(fp)
  12543c:	e0bff717 	ldw	r2,-36(fp)
  125440:	18800426 	beq	r3,r2,125454 <altera_avalon_jtag_uart_write+0x1ec>
    return ptr - start;
  125444:	e0fffd17 	ldw	r3,-12(fp)
  125448:	e0bff717 	ldw	r2,-36(fp)
  12544c:	1885c83a 	sub	r2,r3,r2
  125450:	00000606 	br	12546c <altera_avalon_jtag_uart_write+0x204>
  else if (flags & O_NONBLOCK)
  125454:	e0bfff17 	ldw	r2,-4(fp)
  125458:	1090000c 	andi	r2,r2,16384
  12545c:	10000226 	beq	r2,zero,125468 <altera_avalon_jtag_uart_write+0x200>
    return -EWOULDBLOCK;
  125460:	00bffd44 	movi	r2,-11
  125464:	00000106 	br	12546c <altera_avalon_jtag_uart_write+0x204>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
  125468:	00bffec4 	movi	r2,-5
}
  12546c:	e037883a 	mov	sp,fp
  125470:	dfc00117 	ldw	ra,4(sp)
  125474:	df000017 	ldw	fp,0(sp)
  125478:	dec00204 	addi	sp,sp,8
  12547c:	f800283a 	ret

00125480 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  125480:	defffe04 	addi	sp,sp,-8
  125484:	dfc00115 	stw	ra,4(sp)
  125488:	df000015 	stw	fp,0(sp)
  12548c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  125490:	008004f4 	movhi	r2,19
  125494:	10a4f204 	addi	r2,r2,-27704
  125498:	10800017 	ldw	r2,0(r2)
  12549c:	10000526 	beq	r2,zero,1254b4 <alt_get_errno+0x34>
  1254a0:	008004f4 	movhi	r2,19
  1254a4:	10a4f204 	addi	r2,r2,-27704
  1254a8:	10800017 	ldw	r2,0(r2)
  1254ac:	103ee83a 	callr	r2
  1254b0:	00000206 	br	1254bc <alt_get_errno+0x3c>
  1254b4:	008004f4 	movhi	r2,19
  1254b8:	10abdd04 	addi	r2,r2,-20620
}
  1254bc:	e037883a 	mov	sp,fp
  1254c0:	dfc00117 	ldw	ra,4(sp)
  1254c4:	df000017 	ldw	fp,0(sp)
  1254c8:	dec00204 	addi	sp,sp,8
  1254cc:	f800283a 	ret

001254d0 <alt_mutex_trylock>:
 *
 * returns 0 on success -1 otherwise
 *
 */
static int alt_mutex_trylock( alt_mutex_dev* dev, alt_u32 value )
{
  1254d0:	defff904 	addi	sp,sp,-28
  1254d4:	df000615 	stw	fp,24(sp)
  1254d8:	df000604 	addi	fp,sp,24
  1254dc:	e13ffe15 	stw	r4,-8(fp)
  1254e0:	e17fff15 	stw	r5,-4(fp)
  alt_u32 id, data, check;
  int ret_code = -1;
  1254e4:	00bfffc4 	movi	r2,-1
  1254e8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_READ_CPUID(id);
  1254ec:	0005317a 	rdctl	r2,cpuid
  1254f0:	e0bffb15 	stw	r2,-20(fp)

  /* the data we want the mutex to hold */
  data = (id << ALTERA_AVALON_MUTEX_MUTEX_OWNER_OFST) | value;
  1254f4:	e0bffb17 	ldw	r2,-20(fp)
  1254f8:	1006943a 	slli	r3,r2,16
  1254fc:	e0bfff17 	ldw	r2,-4(fp)
  125500:	1884b03a 	or	r2,r3,r2
  125504:	e0bffc15 	stw	r2,-16(fp)

  /* attempt to write to the mutex */
  IOWR_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base, data);
  125508:	e0bffe17 	ldw	r2,-8(fp)
  12550c:	10800317 	ldw	r2,12(r2)
  125510:	e0fffc17 	ldw	r3,-16(fp)
  125514:	10c00035 	stwio	r3,0(r2)
  
  check = IORD_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base);
  125518:	e0bffe17 	ldw	r2,-8(fp)
  12551c:	10800317 	ldw	r2,12(r2)
  125520:	10800037 	ldwio	r2,0(r2)
  125524:	e0bffd15 	stw	r2,-12(fp)

  if ( check == data)
  125528:	e0fffd17 	ldw	r3,-12(fp)
  12552c:	e0bffc17 	ldw	r2,-16(fp)
  125530:	1880011e 	bne	r3,r2,125538 <alt_mutex_trylock+0x68>
  {
    ret_code = 0;
  125534:	e03ffa15 	stw	zero,-24(fp)
  }

  return ret_code;
  125538:	e0bffa17 	ldw	r2,-24(fp)
}
  12553c:	e037883a 	mov	sp,fp
  125540:	df000017 	ldw	fp,0(sp)
  125544:	dec00104 	addi	sp,sp,4
  125548:	f800283a 	ret

0012554c <altera_avalon_mutex_open>:
 * Search the list of registered mutexes for one with the supplied name.
 *
 * The return value will be NULL on failure, and non-NULL otherwise.
 */
alt_mutex_dev* altera_avalon_mutex_open (const char* name)
{
  12554c:	defffc04 	addi	sp,sp,-16
  125550:	dfc00315 	stw	ra,12(sp)
  125554:	df000215 	stw	fp,8(sp)
  125558:	df000204 	addi	fp,sp,8
  12555c:	e13fff15 	stw	r4,-4(fp)
  alt_mutex_dev* dev;

  dev = (alt_mutex_dev*) alt_find_dev (name, &alt_mutex_list);
  125560:	e13fff17 	ldw	r4,-4(fp)
  125564:	d1600b04 	addi	r5,gp,-32724
  125568:	01266600 	call	126660 <alt_find_dev>
  12556c:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev)
  125570:	e0bffe17 	ldw	r2,-8(fp)
  125574:	1000041e 	bne	r2,zero,125588 <altera_avalon_mutex_open+0x3c>
  {
    ALT_ERRNO = ENODEV;
  125578:	01254800 	call	125480 <alt_get_errno>
  12557c:	1007883a 	mov	r3,r2
  125580:	008004c4 	movi	r2,19
  125584:	18800015 	stw	r2,0(r3)
  }

  return dev;
  125588:	e0bffe17 	ldw	r2,-8(fp)
}
  12558c:	e037883a 	mov	sp,fp
  125590:	dfc00117 	ldw	ra,4(sp)
  125594:	df000017 	ldw	fp,0(sp)
  125598:	dec00204 	addi	sp,sp,8
  12559c:	f800283a 	ret

001255a0 <altera_avalon_mutex_close>:
 * altera_avalon_mutex_close - Does nothing at the moment, but included for 
 * completeness
 *
 */
void altera_avalon_mutex_close (alt_mutex_dev* dev)
{
  1255a0:	defffe04 	addi	sp,sp,-8
  1255a4:	df000115 	stw	fp,4(sp)
  1255a8:	df000104 	addi	fp,sp,4
  1255ac:	e13fff15 	stw	r4,-4(fp)
  return;
  1255b0:	0001883a 	nop
}
  1255b4:	e037883a 	mov	sp,fp
  1255b8:	df000017 	ldw	fp,0(sp)
  1255bc:	dec00104 	addi	sp,sp,4
  1255c0:	f800283a 	ret

001255c4 <altera_avalon_mutex_lock>:
/*
 * altera_avalon_mutex_lock - Lock the hardware mutex
 *
 */
void altera_avalon_mutex_lock( alt_mutex_dev* dev, alt_u32 value )
{
  1255c4:	defffc04 	addi	sp,sp,-16
  1255c8:	dfc00315 	stw	ra,12(sp)
  1255cc:	df000215 	stw	fp,8(sp)
  1255d0:	df000204 	addi	fp,sp,8
  1255d4:	e13ffe15 	stw	r4,-8(fp)
  1255d8:	e17fff15 	stw	r5,-4(fp)
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (dev->lock, 0);

  while ( alt_mutex_trylock( dev, value ) != 0);
  1255dc:	0001883a 	nop
  1255e0:	e13ffe17 	ldw	r4,-8(fp)
  1255e4:	e17fff17 	ldw	r5,-4(fp)
  1255e8:	01254d00 	call	1254d0 <alt_mutex_trylock>
  1255ec:	103ffc1e 	bne	r2,zero,1255e0 <__alt_data_end+0xffff1d60>
}
  1255f0:	e037883a 	mov	sp,fp
  1255f4:	dfc00117 	ldw	ra,4(sp)
  1255f8:	df000017 	ldw	fp,0(sp)
  1255fc:	dec00204 	addi	sp,sp,8
  125600:	f800283a 	ret

00125604 <altera_avalon_mutex_trylock>:
 *
 * returns 0 on success -1 otherwise
 *
 */
int altera_avalon_mutex_trylock( alt_mutex_dev* dev, alt_u32 value )
{
  125604:	defffa04 	addi	sp,sp,-24
  125608:	dfc00515 	stw	ra,20(sp)
  12560c:	df000415 	stw	fp,16(sp)
  125610:	df000404 	addi	fp,sp,16
  125614:	e13ffd15 	stw	r4,-12(fp)
  125618:	e17ffe15 	stw	r5,-8(fp)
  int ret_code;

  ALT_SEM_PEND (dev->lock, 0);

  ret_code = alt_mutex_trylock( dev, value);
  12561c:	e13ffd17 	ldw	r4,-12(fp)
  125620:	e17ffe17 	ldw	r5,-8(fp)
  125624:	01254d00 	call	1254d0 <alt_mutex_trylock>
  125628:	e0bffc15 	stw	r2,-16(fp)
  if (ret_code)
  {
    ALT_SEM_POST (dev->lock);
  }

  return ret_code;
  12562c:	e0bffc17 	ldw	r2,-16(fp)
}
  125630:	e037883a 	mov	sp,fp
  125634:	dfc00117 	ldw	ra,4(sp)
  125638:	df000017 	ldw	fp,0(sp)
  12563c:	dec00204 	addi	sp,sp,8
  125640:	f800283a 	ret

00125644 <altera_avalon_mutex_unlock>:
 * This function does not check that you own the Mutex if you try to release
 * a Mutex you do not own the behaviour is undefined
 *
 */
void altera_avalon_mutex_unlock( alt_mutex_dev* dev )
{
  125644:	defffd04 	addi	sp,sp,-12
  125648:	df000215 	stw	fp,8(sp)
  12564c:	df000204 	addi	fp,sp,8
  125650:	e13fff15 	stw	r4,-4(fp)
  alt_u32 id;
  NIOS2_READ_CPUID(id);
  125654:	0005317a 	rdctl	r2,cpuid
  125658:	e0bffe15 	stw	r2,-8(fp)

  /*
  * This Mutex has been claimed and released since Reset so clear the Reset bit
  * This MUST happen before we release the MUTEX
  */
  IOWR_ALTERA_AVALON_MUTEX_RESET(dev->mutex_base, 
  12565c:	e0bfff17 	ldw	r2,-4(fp)
  125660:	10800317 	ldw	r2,12(r2)
  125664:	10800104 	addi	r2,r2,4
  125668:	00c00044 	movi	r3,1
  12566c:	10c00035 	stwio	r3,0(r2)
                                  ALTERA_AVALON_MUTEX_RESET_RESET_MSK);
  IOWR_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base, 
  125670:	e0bfff17 	ldw	r2,-4(fp)
  125674:	10800317 	ldw	r2,12(r2)
  125678:	e0fffe17 	ldw	r3,-8(fp)
  12567c:	1806943a 	slli	r3,r3,16
  125680:	10c00035 	stwio	r3,0(r2)

  /*
  * Now that access to the hardware Mutex is complete, release the thread lock
  */
  ALT_SEM_POST (dev->lock);
}
  125684:	e037883a 	mov	sp,fp
  125688:	df000017 	ldw	fp,0(sp)
  12568c:	dec00104 	addi	sp,sp,4
  125690:	f800283a 	ret

00125694 <altera_avalon_mutex_is_mine>:
 * altera_avalon_mutex_is_mine - Do I own the Mutex?
 *
 *  returns non zero if the mutex is owned by this CPU
 */
int altera_avalon_mutex_is_mine( alt_mutex_dev* dev )
{
  125694:	defff904 	addi	sp,sp,-28
  125698:	df000615 	stw	fp,24(sp)
  12569c:	df000604 	addi	fp,sp,24
  1256a0:	e13fff15 	stw	r4,-4(fp)
  alt_u32 id, data, owner, value;
  int ret_code = 0;
  1256a4:	e03ffa15 	stw	zero,-24(fp)

  NIOS2_READ_CPUID(id);
  1256a8:	0005317a 	rdctl	r2,cpuid
  1256ac:	e0bffb15 	stw	r2,-20(fp)

  /* retrieve the contents of the mutex */
  data = IORD_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base);
  1256b0:	e0bfff17 	ldw	r2,-4(fp)
  1256b4:	10800317 	ldw	r2,12(r2)
  1256b8:	10800037 	ldwio	r2,0(r2)
  1256bc:	e0bffc15 	stw	r2,-16(fp)
  owner = (data & ALTERA_AVALON_MUTEX_MUTEX_OWNER_MSK) >> 
  1256c0:	e0bffc17 	ldw	r2,-16(fp)
  1256c4:	1004d43a 	srli	r2,r2,16
  1256c8:	e0bffd15 	stw	r2,-12(fp)
              ALTERA_AVALON_MUTEX_MUTEX_OWNER_OFST;

  if (owner == id) 
  1256cc:	e0fffd17 	ldw	r3,-12(fp)
  1256d0:	e0bffb17 	ldw	r2,-20(fp)
  1256d4:	1880071e 	bne	r3,r2,1256f4 <altera_avalon_mutex_is_mine+0x60>
  {
    value = (data & ALTERA_AVALON_MUTEX_MUTEX_VALUE_MSK) >> 
  1256d8:	e0bffc17 	ldw	r2,-16(fp)
  1256dc:	10bfffcc 	andi	r2,r2,65535
  1256e0:	e0bffe15 	stw	r2,-8(fp)
                  ALTERA_AVALON_MUTEX_MUTEX_VALUE_OFST;
    if (value != 0)
  1256e4:	e0bffe17 	ldw	r2,-8(fp)
  1256e8:	10000226 	beq	r2,zero,1256f4 <altera_avalon_mutex_is_mine+0x60>
    {
      ret_code = 1;
  1256ec:	00800044 	movi	r2,1
  1256f0:	e0bffa15 	stw	r2,-24(fp)
    }
  }

  return ret_code;
  1256f4:	e0bffa17 	ldw	r2,-24(fp)
}
  1256f8:	e037883a 	mov	sp,fp
  1256fc:	df000017 	ldw	fp,0(sp)
  125700:	dec00104 	addi	sp,sp,4
  125704:	f800283a 	ret

00125708 <altera_avalon_mutex_first_lock>:
 *
 * Has this Mutex been released since reset if not return 1
 * otherwise return 0
 */
int altera_avalon_mutex_first_lock( alt_mutex_dev* dev )
{
  125708:	defffc04 	addi	sp,sp,-16
  12570c:	df000315 	stw	fp,12(sp)
  125710:	df000304 	addi	fp,sp,12
  125714:	e13fff15 	stw	r4,-4(fp)
  alt_u32 data;
  int ret_code = 0;
  125718:	e03ffd15 	stw	zero,-12(fp)

  data = IORD_ALTERA_AVALON_MUTEX_RESET(dev->mutex_base);
  12571c:	e0bfff17 	ldw	r2,-4(fp)
  125720:	10800317 	ldw	r2,12(r2)
  125724:	10800104 	addi	r2,r2,4
  125728:	10800037 	ldwio	r2,0(r2)
  12572c:	e0bffe15 	stw	r2,-8(fp)

  if (data & ALTERA_AVALON_MUTEX_RESET_RESET_MSK) 
  125730:	e0bffe17 	ldw	r2,-8(fp)
  125734:	1080004c 	andi	r2,r2,1
  125738:	10000226 	beq	r2,zero,125744 <altera_avalon_mutex_first_lock+0x3c>
  {
    ret_code = 1;
  12573c:	00800044 	movi	r2,1
  125740:	e0bffd15 	stw	r2,-12(fp)
  }

  return ret_code;
  125744:	e0bffd17 	ldw	r2,-12(fp)
}
  125748:	e037883a 	mov	sp,fp
  12574c:	df000017 	ldw	fp,0(sp)
  125750:	dec00104 	addi	sp,sp,4
  125754:	f800283a 	ret

00125758 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  125758:	defffa04 	addi	sp,sp,-24
  12575c:	dfc00515 	stw	ra,20(sp)
  125760:	df000415 	stw	fp,16(sp)
  125764:	df000404 	addi	fp,sp,16
  125768:	e13ffd15 	stw	r4,-12(fp)
  12576c:	e17ffe15 	stw	r5,-8(fp)
  125770:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  125774:	e0bffd17 	ldw	r2,-12(fp)
  125778:	10800017 	ldw	r2,0(r2)
  12577c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
  125780:	e0bffc17 	ldw	r2,-16(fp)
  125784:	10c00a04 	addi	r3,r2,40
  125788:	e0bffd17 	ldw	r2,-12(fp)
  12578c:	10800217 	ldw	r2,8(r2)
  125790:	1809883a 	mov	r4,r3
  125794:	e17ffe17 	ldw	r5,-8(fp)
  125798:	e1bfff17 	ldw	r6,-4(fp)
  12579c:	100f883a 	mov	r7,r2
  1257a0:	0125c700 	call	125c70 <altera_avalon_uart_read>
      fd->fd_flags);
}
  1257a4:	e037883a 	mov	sp,fp
  1257a8:	dfc00117 	ldw	ra,4(sp)
  1257ac:	df000017 	ldw	fp,0(sp)
  1257b0:	dec00204 	addi	sp,sp,8
  1257b4:	f800283a 	ret

001257b8 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  1257b8:	defffa04 	addi	sp,sp,-24
  1257bc:	dfc00515 	stw	ra,20(sp)
  1257c0:	df000415 	stw	fp,16(sp)
  1257c4:	df000404 	addi	fp,sp,16
  1257c8:	e13ffd15 	stw	r4,-12(fp)
  1257cc:	e17ffe15 	stw	r5,-8(fp)
  1257d0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  1257d4:	e0bffd17 	ldw	r2,-12(fp)
  1257d8:	10800017 	ldw	r2,0(r2)
  1257dc:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
  1257e0:	e0bffc17 	ldw	r2,-16(fp)
  1257e4:	10c00a04 	addi	r3,r2,40
  1257e8:	e0bffd17 	ldw	r2,-12(fp)
  1257ec:	10800217 	ldw	r2,8(r2)
  1257f0:	1809883a 	mov	r4,r3
  1257f4:	e17ffe17 	ldw	r5,-8(fp)
  1257f8:	e1bfff17 	ldw	r6,-4(fp)
  1257fc:	100f883a 	mov	r7,r2
  125800:	0125e9c0 	call	125e9c <altera_avalon_uart_write>
      fd->fd_flags);
}
  125804:	e037883a 	mov	sp,fp
  125808:	dfc00117 	ldw	ra,4(sp)
  12580c:	df000017 	ldw	fp,0(sp)
  125810:	dec00204 	addi	sp,sp,8
  125814:	f800283a 	ret

00125818 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
  125818:	defffc04 	addi	sp,sp,-16
  12581c:	dfc00315 	stw	ra,12(sp)
  125820:	df000215 	stw	fp,8(sp)
  125824:	df000204 	addi	fp,sp,8
  125828:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  12582c:	e0bfff17 	ldw	r2,-4(fp)
  125830:	10800017 	ldw	r2,0(r2)
  125834:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
  125838:	e0bffe17 	ldw	r2,-8(fp)
  12583c:	10c00a04 	addi	r3,r2,40
  125840:	e0bfff17 	ldw	r2,-4(fp)
  125844:	10800217 	ldw	r2,8(r2)
  125848:	1809883a 	mov	r4,r3
  12584c:	100b883a 	mov	r5,r2
  125850:	0125bcc0 	call	125bcc <altera_avalon_uart_close>
}
  125854:	e037883a 	mov	sp,fp
  125858:	dfc00117 	ldw	ra,4(sp)
  12585c:	df000017 	ldw	fp,0(sp)
  125860:	dec00204 	addi	sp,sp,8
  125864:	f800283a 	ret

00125868 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
  125868:	defff804 	addi	sp,sp,-32
  12586c:	dfc00715 	stw	ra,28(sp)
  125870:	df000615 	stw	fp,24(sp)
  125874:	df000604 	addi	fp,sp,24
  125878:	e13ffd15 	stw	r4,-12(fp)
  12587c:	e17ffe15 	stw	r5,-8(fp)
  125880:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
  125884:	e0bffd17 	ldw	r2,-12(fp)
  125888:	10800017 	ldw	r2,0(r2)
  12588c:	e0bffb15 	stw	r2,-20(fp)
  125890:	0005883a 	mov	r2,zero
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
  125894:	1000041e 	bne	r2,zero,1258a8 <altera_avalon_uart_init+0x40>
  125898:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
  12589c:	1000021e 	bne	r2,zero,1258a8 <altera_avalon_uart_init+0x40>
  1258a0:	0005883a 	mov	r2,zero
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
  1258a4:	10000226 	beq	r2,zero,1258b0 <altera_avalon_uart_init+0x48>
  1258a8:	00800044 	movi	r2,1
  1258ac:	00000106 	br	1258b4 <altera_avalon_uart_init+0x4c>
  1258b0:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
  1258b4:	e0bffc15 	stw	r2,-16(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
  1258b8:	e0bffc17 	ldw	r2,-16(fp)
  1258bc:	10000f1e 	bne	r2,zero,1258fc <altera_avalon_uart_init+0x94>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
  1258c0:	e0bffd17 	ldw	r2,-12(fp)
  1258c4:	00c32004 	movi	r3,3200
  1258c8:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
  1258cc:	e0bffb17 	ldw	r2,-20(fp)
  1258d0:	10800304 	addi	r2,r2,12
  1258d4:	e0fffd17 	ldw	r3,-12(fp)
  1258d8:	18c00117 	ldw	r3,4(r3)
  1258dc:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
  1258e0:	d8000015 	stw	zero,0(sp)
  1258e4:	e13ffe17 	ldw	r4,-8(fp)
  1258e8:	e17fff17 	ldw	r5,-4(fp)
  1258ec:	018004b4 	movhi	r6,18
  1258f0:	31964404 	addi	r6,r6,22800
  1258f4:	e1fffd17 	ldw	r7,-12(fp)
  1258f8:	01268e80 	call	1268e8 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
  1258fc:	e037883a 	mov	sp,fp
  125900:	dfc00117 	ldw	ra,4(sp)
  125904:	df000017 	ldw	fp,0(sp)
  125908:	dec00204 	addi	sp,sp,8
  12590c:	f800283a 	ret

00125910 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
  125910:	defffa04 	addi	sp,sp,-24
  125914:	dfc00515 	stw	ra,20(sp)
  125918:	df000415 	stw	fp,16(sp)
  12591c:	df000404 	addi	fp,sp,16
  125920:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
  125924:	e0bfff17 	ldw	r2,-4(fp)
  125928:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
  12592c:	e0bffc17 	ldw	r2,-16(fp)
  125930:	10800017 	ldw	r2,0(r2)
  125934:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
  125938:	e0bffd17 	ldw	r2,-12(fp)
  12593c:	10800204 	addi	r2,r2,8
  125940:	10800037 	ldwio	r2,0(r2)
  125944:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
  125948:	e0bffd17 	ldw	r2,-12(fp)
  12594c:	10800204 	addi	r2,r2,8
  125950:	0007883a 	mov	r3,zero
  125954:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
  125958:	e0bffd17 	ldw	r2,-12(fp)
  12595c:	10800204 	addi	r2,r2,8
  125960:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
  125964:	e0bffe17 	ldw	r2,-8(fp)
  125968:	1080200c 	andi	r2,r2,128
  12596c:	10000326 	beq	r2,zero,12597c <altera_avalon_uart_irq+0x6c>
  {
    altera_avalon_uart_rxirq(sp, status);
  125970:	e13ffc17 	ldw	r4,-16(fp)
  125974:	e17ffe17 	ldw	r5,-8(fp)
  125978:	01259a80 	call	1259a8 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
  12597c:	e0bffe17 	ldw	r2,-8(fp)
  125980:	1081100c 	andi	r2,r2,1088
  125984:	10000326 	beq	r2,zero,125994 <altera_avalon_uart_irq+0x84>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
  125988:	e13ffc17 	ldw	r4,-16(fp)
  12598c:	e17ffe17 	ldw	r5,-8(fp)
  125990:	0125a880 	call	125a88 <altera_avalon_uart_txirq>
  }
  

}
  125994:	e037883a 	mov	sp,fp
  125998:	dfc00117 	ldw	ra,4(sp)
  12599c:	df000017 	ldw	fp,0(sp)
  1259a0:	dec00204 	addi	sp,sp,8
  1259a4:	f800283a 	ret

001259a8 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
  1259a8:	defffc04 	addi	sp,sp,-16
  1259ac:	df000315 	stw	fp,12(sp)
  1259b0:	df000304 	addi	fp,sp,12
  1259b4:	e13ffe15 	stw	r4,-8(fp)
  1259b8:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
  1259bc:	e0bfff17 	ldw	r2,-4(fp)
  1259c0:	108000cc 	andi	r2,r2,3
  1259c4:	10000126 	beq	r2,zero,1259cc <altera_avalon_uart_rxirq+0x24>
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
  1259c8:	00002b06 	br	125a78 <altera_avalon_uart_rxirq+0xd0>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
  1259cc:	e0bffe17 	ldw	r2,-8(fp)
  1259d0:	10800317 	ldw	r2,12(r2)
  1259d4:	e0bffe17 	ldw	r2,-8(fp)
  1259d8:	10800217 	ldw	r2,8(r2)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  1259dc:	e0bffe17 	ldw	r2,-8(fp)
  1259e0:	10800317 	ldw	r2,12(r2)
  1259e4:	10800044 	addi	r2,r2,1
  1259e8:	10800fcc 	andi	r2,r2,63
  1259ec:	e0bffd15 	stw	r2,-12(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
  1259f0:	e0bffe17 	ldw	r2,-8(fp)
  1259f4:	10800317 	ldw	r2,12(r2)
  1259f8:	e0fffe17 	ldw	r3,-8(fp)
  1259fc:	18c00017 	ldw	r3,0(r3)
  125a00:	18c00037 	ldwio	r3,0(r3)
  125a04:	1809883a 	mov	r4,r3
  125a08:	e0fffe17 	ldw	r3,-8(fp)
  125a0c:	1885883a 	add	r2,r3,r2
  125a10:	10800704 	addi	r2,r2,28
  125a14:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
  125a18:	e0bffe17 	ldw	r2,-8(fp)
  125a1c:	e0fffd17 	ldw	r3,-12(fp)
  125a20:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  125a24:	e0bffe17 	ldw	r2,-8(fp)
  125a28:	10800317 	ldw	r2,12(r2)
  125a2c:	10800044 	addi	r2,r2,1
  125a30:	10800fcc 	andi	r2,r2,63
  125a34:	e0bffd15 	stw	r2,-12(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
  125a38:	e0bffe17 	ldw	r2,-8(fp)
  125a3c:	10c00217 	ldw	r3,8(r2)
  125a40:	e0bffd17 	ldw	r2,-12(fp)
  125a44:	18800c1e 	bne	r3,r2,125a78 <altera_avalon_uart_rxirq+0xd0>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  125a48:	e0bffe17 	ldw	r2,-8(fp)
  125a4c:	10c00117 	ldw	r3,4(r2)
  125a50:	00bfdfc4 	movi	r2,-129
  125a54:	1886703a 	and	r3,r3,r2
  125a58:	e0bffe17 	ldw	r2,-8(fp)
  125a5c:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  125a60:	e0bffe17 	ldw	r2,-8(fp)
  125a64:	10800017 	ldw	r2,0(r2)
  125a68:	10800304 	addi	r2,r2,12
  125a6c:	e0fffe17 	ldw	r3,-8(fp)
  125a70:	18c00117 	ldw	r3,4(r3)
  125a74:	10c00035 	stwio	r3,0(r2)
  }   
}
  125a78:	e037883a 	mov	sp,fp
  125a7c:	df000017 	ldw	fp,0(sp)
  125a80:	dec00104 	addi	sp,sp,4
  125a84:	f800283a 	ret

00125a88 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
  125a88:	defffb04 	addi	sp,sp,-20
  125a8c:	df000415 	stw	fp,16(sp)
  125a90:	df000404 	addi	fp,sp,16
  125a94:	e13ffc15 	stw	r4,-16(fp)
  125a98:	e17ffd15 	stw	r5,-12(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
  125a9c:	e0bffc17 	ldw	r2,-16(fp)
  125aa0:	10c00417 	ldw	r3,16(r2)
  125aa4:	e0bffc17 	ldw	r2,-16(fp)
  125aa8:	10800517 	ldw	r2,20(r2)
  125aac:	18803226 	beq	r3,r2,125b78 <altera_avalon_uart_txirq+0xf0>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
  125ab0:	e0bffc17 	ldw	r2,-16(fp)
  125ab4:	10800617 	ldw	r2,24(r2)
  125ab8:	1080008c 	andi	r2,r2,2
  125abc:	10000326 	beq	r2,zero,125acc <altera_avalon_uart_txirq+0x44>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
  125ac0:	e0bffd17 	ldw	r2,-12(fp)
  125ac4:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
  125ac8:	10001d26 	beq	r2,zero,125b40 <altera_avalon_uart_txirq+0xb8>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
  125acc:	e0bffc17 	ldw	r2,-16(fp)
  125ad0:	10800417 	ldw	r2,16(r2)
  125ad4:	e0bffc17 	ldw	r2,-16(fp)
  125ad8:	10800517 	ldw	r2,20(r2)
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
  125adc:	e0bffc17 	ldw	r2,-16(fp)
  125ae0:	10800017 	ldw	r2,0(r2)
  125ae4:	10800104 	addi	r2,r2,4
  125ae8:	e0fffc17 	ldw	r3,-16(fp)
  125aec:	18c00417 	ldw	r3,16(r3)
  125af0:	e13ffc17 	ldw	r4,-16(fp)
  125af4:	20c7883a 	add	r3,r4,r3
  125af8:	18c01704 	addi	r3,r3,92
  125afc:	18c00003 	ldbu	r3,0(r3)
  125b00:	18c03fcc 	andi	r3,r3,255
  125b04:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
  125b08:	e0bffc17 	ldw	r2,-16(fp)
  125b0c:	10800417 	ldw	r2,16(r2)
  125b10:	10800044 	addi	r2,r2,1
  125b14:	e0fffc17 	ldw	r3,-16(fp)
  125b18:	18800415 	stw	r2,16(r3)
  125b1c:	10c00fcc 	andi	r3,r2,63
  125b20:	e0bffc17 	ldw	r2,-16(fp)
  125b24:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
  125b28:	e0bffc17 	ldw	r2,-16(fp)
  125b2c:	10800117 	ldw	r2,4(r2)
  125b30:	10c01014 	ori	r3,r2,64
  125b34:	e0bffc17 	ldw	r2,-16(fp)
  125b38:	10c00115 	stw	r3,4(r2)
  125b3c:	00000e06 	br	125b78 <altera_avalon_uart_txirq+0xf0>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
  125b40:	e0bffc17 	ldw	r2,-16(fp)
  125b44:	10800017 	ldw	r2,0(r2)
  125b48:	10800204 	addi	r2,r2,8
  125b4c:	10800037 	ldwio	r2,0(r2)
  125b50:	e0bffd15 	stw	r2,-12(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
  125b54:	e0bffd17 	ldw	r2,-12(fp)
  125b58:	1082000c 	andi	r2,r2,2048
  125b5c:	1000061e 	bne	r2,zero,125b78 <altera_avalon_uart_txirq+0xf0>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
  125b60:	e0bffc17 	ldw	r2,-16(fp)
  125b64:	10c00117 	ldw	r3,4(r2)
  125b68:	00bfefc4 	movi	r2,-65
  125b6c:	1886703a 	and	r3,r3,r2
  125b70:	e0bffc17 	ldw	r2,-16(fp)
  125b74:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
  125b78:	e0bffc17 	ldw	r2,-16(fp)
  125b7c:	10c00417 	ldw	r3,16(r2)
  125b80:	e0bffc17 	ldw	r2,-16(fp)
  125b84:	10800517 	ldw	r2,20(r2)
  125b88:	1880061e 	bne	r3,r2,125ba4 <altera_avalon_uart_txirq+0x11c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  125b8c:	e0bffc17 	ldw	r2,-16(fp)
  125b90:	10c00117 	ldw	r3,4(r2)
  125b94:	00beefc4 	movi	r2,-1089
  125b98:	1886703a 	and	r3,r3,r2
  125b9c:	e0bffc17 	ldw	r2,-16(fp)
  125ba0:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  125ba4:	e0bffc17 	ldw	r2,-16(fp)
  125ba8:	10800017 	ldw	r2,0(r2)
  125bac:	10800304 	addi	r2,r2,12
  125bb0:	e0fffc17 	ldw	r3,-16(fp)
  125bb4:	18c00117 	ldw	r3,4(r3)
  125bb8:	10c00035 	stwio	r3,0(r2)
}
  125bbc:	e037883a 	mov	sp,fp
  125bc0:	df000017 	ldw	fp,0(sp)
  125bc4:	dec00104 	addi	sp,sp,4
  125bc8:	f800283a 	ret

00125bcc <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  125bcc:	defffd04 	addi	sp,sp,-12
  125bd0:	df000215 	stw	fp,8(sp)
  125bd4:	df000204 	addi	fp,sp,8
  125bd8:	e13ffe15 	stw	r4,-8(fp)
  125bdc:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
  125be0:	00000506 	br	125bf8 <altera_avalon_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
  125be4:	e0bfff17 	ldw	r2,-4(fp)
  125be8:	1090000c 	andi	r2,r2,16384
  125bec:	10000226 	beq	r2,zero,125bf8 <altera_avalon_uart_close+0x2c>
      return -EWOULDBLOCK; 
  125bf0:	00bffd44 	movi	r2,-11
  125bf4:	00000606 	br	125c10 <altera_avalon_uart_close+0x44>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
  125bf8:	e0bffe17 	ldw	r2,-8(fp)
  125bfc:	10c00417 	ldw	r3,16(r2)
  125c00:	e0bffe17 	ldw	r2,-8(fp)
  125c04:	10800517 	ldw	r2,20(r2)
  125c08:	18bff61e 	bne	r3,r2,125be4 <__alt_data_end+0xffff2364>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
  125c0c:	0005883a 	mov	r2,zero
}
  125c10:	e037883a 	mov	sp,fp
  125c14:	df000017 	ldw	fp,0(sp)
  125c18:	dec00104 	addi	sp,sp,4
  125c1c:	f800283a 	ret

00125c20 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  125c20:	defffe04 	addi	sp,sp,-8
  125c24:	dfc00115 	stw	ra,4(sp)
  125c28:	df000015 	stw	fp,0(sp)
  125c2c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  125c30:	008004f4 	movhi	r2,19
  125c34:	10a4f204 	addi	r2,r2,-27704
  125c38:	10800017 	ldw	r2,0(r2)
  125c3c:	10000526 	beq	r2,zero,125c54 <alt_get_errno+0x34>
  125c40:	008004f4 	movhi	r2,19
  125c44:	10a4f204 	addi	r2,r2,-27704
  125c48:	10800017 	ldw	r2,0(r2)
  125c4c:	103ee83a 	callr	r2
  125c50:	00000206 	br	125c5c <alt_get_errno+0x3c>
  125c54:	008004f4 	movhi	r2,19
  125c58:	10abdd04 	addi	r2,r2,-20620
}
  125c5c:	e037883a 	mov	sp,fp
  125c60:	dfc00117 	ldw	ra,4(sp)
  125c64:	df000017 	ldw	fp,0(sp)
  125c68:	dec00204 	addi	sp,sp,8
  125c6c:	f800283a 	ret

00125c70 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
  125c70:	defff204 	addi	sp,sp,-56
  125c74:	dfc00d15 	stw	ra,52(sp)
  125c78:	df000c15 	stw	fp,48(sp)
  125c7c:	df000c04 	addi	fp,sp,48
  125c80:	e13ffc15 	stw	r4,-16(fp)
  125c84:	e17ffd15 	stw	r5,-12(fp)
  125c88:	e1bffe15 	stw	r6,-8(fp)
  125c8c:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
  125c90:	e03ff405 	stb	zero,-48(fp)
  int             count = 0;
  125c94:	e03ff515 	stw	zero,-44(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
  125c98:	e0bfff17 	ldw	r2,-4(fp)
  125c9c:	1090000c 	andi	r2,r2,16384
  125ca0:	1005003a 	cmpeq	r2,r2,zero
  125ca4:	10803fcc 	andi	r2,r2,255
  125ca8:	e0bff615 	stw	r2,-40(fp)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
  125cac:	00001306 	br	125cfc <altera_avalon_uart_read+0x8c>
    {
      count++;
  125cb0:	e0bff517 	ldw	r2,-44(fp)
  125cb4:	10800044 	addi	r2,r2,1
  125cb8:	e0bff515 	stw	r2,-44(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
  125cbc:	e0bffd17 	ldw	r2,-12(fp)
  125cc0:	10c00044 	addi	r3,r2,1
  125cc4:	e0fffd15 	stw	r3,-12(fp)
  125cc8:	e0fffc17 	ldw	r3,-16(fp)
  125ccc:	18c00217 	ldw	r3,8(r3)
  125cd0:	e13ffc17 	ldw	r4,-16(fp)
  125cd4:	20c7883a 	add	r3,r4,r3
  125cd8:	18c00704 	addi	r3,r3,28
  125cdc:	18c00003 	ldbu	r3,0(r3)
  125ce0:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
  125ce4:	e0bffc17 	ldw	r2,-16(fp)
  125ce8:	10800217 	ldw	r2,8(r2)
  125cec:	10800044 	addi	r2,r2,1
  125cf0:	10c00fcc 	andi	r3,r2,63
  125cf4:	e0bffc17 	ldw	r2,-16(fp)
  125cf8:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
  125cfc:	e0fff517 	ldw	r3,-44(fp)
  125d00:	e0bffe17 	ldw	r2,-8(fp)
  125d04:	1880050e 	bge	r3,r2,125d1c <altera_avalon_uart_read+0xac>
  125d08:	e0bffc17 	ldw	r2,-16(fp)
  125d0c:	10c00217 	ldw	r3,8(r2)
  125d10:	e0bffc17 	ldw	r2,-16(fp)
  125d14:	10800317 	ldw	r2,12(r2)
  125d18:	18bfe51e 	bne	r3,r2,125cb0 <__alt_data_end+0xffff2430>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
  125d1c:	e0bff517 	ldw	r2,-44(fp)
  125d20:	1000251e 	bne	r2,zero,125db8 <altera_avalon_uart_read+0x148>
  125d24:	e0bffc17 	ldw	r2,-16(fp)
  125d28:	10c00217 	ldw	r3,8(r2)
  125d2c:	e0bffc17 	ldw	r2,-16(fp)
  125d30:	10800317 	ldw	r2,12(r2)
  125d34:	1880201e 	bne	r3,r2,125db8 <altera_avalon_uart_read+0x148>
    {
      if (!block)
  125d38:	e0bff617 	ldw	r2,-40(fp)
  125d3c:	1000071e 	bne	r2,zero,125d5c <altera_avalon_uart_read+0xec>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
  125d40:	0125c200 	call	125c20 <alt_get_errno>
  125d44:	1007883a 	mov	r3,r2
  125d48:	008002c4 	movi	r2,11
  125d4c:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
  125d50:	00800044 	movi	r2,1
  125d54:	e0bff405 	stb	r2,-48(fp)
        break;
  125d58:	00001b06 	br	125dc8 <altera_avalon_uart_read+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  125d5c:	0005303a 	rdctl	r2,status
  125d60:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  125d64:	e0fff817 	ldw	r3,-32(fp)
  125d68:	00bfff84 	movi	r2,-2
  125d6c:	1884703a 	and	r2,r3,r2
  125d70:	1001703a 	wrctl	status,r2
  
  return context;
  125d74:	e0bff817 	ldw	r2,-32(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
  125d78:	e0bff715 	stw	r2,-36(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  125d7c:	e0bffc17 	ldw	r2,-16(fp)
  125d80:	10800117 	ldw	r2,4(r2)
  125d84:	10c02014 	ori	r3,r2,128
  125d88:	e0bffc17 	ldw	r2,-16(fp)
  125d8c:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  125d90:	e0bffc17 	ldw	r2,-16(fp)
  125d94:	10800017 	ldw	r2,0(r2)
  125d98:	10800304 	addi	r2,r2,12
  125d9c:	e0fffc17 	ldw	r3,-16(fp)
  125da0:	18c00117 	ldw	r3,4(r3)
  125da4:	10c00035 	stwio	r3,0(r2)
  125da8:	e0bff717 	ldw	r2,-36(fp)
  125dac:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  125db0:	e0bff917 	ldw	r2,-28(fp)
  125db4:	1001703a 	wrctl	status,r2
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
  125db8:	e0bff517 	ldw	r2,-44(fp)
  125dbc:	1000021e 	bne	r2,zero,125dc8 <altera_avalon_uart_read+0x158>
  125dc0:	e0bffe17 	ldw	r2,-8(fp)
  125dc4:	103fb91e 	bne	r2,zero,125cac <__alt_data_end+0xffff242c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  125dc8:	0005303a 	rdctl	r2,status
  125dcc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  125dd0:	e0fffa17 	ldw	r3,-24(fp)
  125dd4:	00bfff84 	movi	r2,-2
  125dd8:	1884703a 	and	r2,r3,r2
  125ddc:	1001703a 	wrctl	status,r2
  
  return context;
  125de0:	e0bffa17 	ldw	r2,-24(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
  125de4:	e0bff715 	stw	r2,-36(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  125de8:	e0bffc17 	ldw	r2,-16(fp)
  125dec:	10800117 	ldw	r2,4(r2)
  125df0:	10c02014 	ori	r3,r2,128
  125df4:	e0bffc17 	ldw	r2,-16(fp)
  125df8:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  125dfc:	e0bffc17 	ldw	r2,-16(fp)
  125e00:	10800017 	ldw	r2,0(r2)
  125e04:	10800304 	addi	r2,r2,12
  125e08:	e0fffc17 	ldw	r3,-16(fp)
  125e0c:	18c00117 	ldw	r3,4(r3)
  125e10:	10c00035 	stwio	r3,0(r2)
  125e14:	e0bff717 	ldw	r2,-36(fp)
  125e18:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  125e1c:	e0bffb17 	ldw	r2,-20(fp)
  125e20:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
  125e24:	e0bff403 	ldbu	r2,-48(fp)
  125e28:	10000226 	beq	r2,zero,125e34 <altera_avalon_uart_read+0x1c4>
    return -EWOULDBLOCK;
  125e2c:	00bffd44 	movi	r2,-11
  125e30:	00000106 	br	125e38 <altera_avalon_uart_read+0x1c8>
  }
  else {
    return count;
  125e34:	e0bff517 	ldw	r2,-44(fp)
  }
}
  125e38:	e037883a 	mov	sp,fp
  125e3c:	dfc00117 	ldw	ra,4(sp)
  125e40:	df000017 	ldw	fp,0(sp)
  125e44:	dec00204 	addi	sp,sp,8
  125e48:	f800283a 	ret

00125e4c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  125e4c:	defffe04 	addi	sp,sp,-8
  125e50:	dfc00115 	stw	ra,4(sp)
  125e54:	df000015 	stw	fp,0(sp)
  125e58:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  125e5c:	008004f4 	movhi	r2,19
  125e60:	10a4f204 	addi	r2,r2,-27704
  125e64:	10800017 	ldw	r2,0(r2)
  125e68:	10000526 	beq	r2,zero,125e80 <alt_get_errno+0x34>
  125e6c:	008004f4 	movhi	r2,19
  125e70:	10a4f204 	addi	r2,r2,-27704
  125e74:	10800017 	ldw	r2,0(r2)
  125e78:	103ee83a 	callr	r2
  125e7c:	00000206 	br	125e88 <alt_get_errno+0x3c>
  125e80:	008004f4 	movhi	r2,19
  125e84:	10abdd04 	addi	r2,r2,-20620
}
  125e88:	e037883a 	mov	sp,fp
  125e8c:	dfc00117 	ldw	ra,4(sp)
  125e90:	df000017 	ldw	fp,0(sp)
  125e94:	dec00204 	addi	sp,sp,8
  125e98:	f800283a 	ret

00125e9c <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
  125e9c:	defff204 	addi	sp,sp,-56
  125ea0:	dfc00d15 	stw	ra,52(sp)
  125ea4:	df000c15 	stw	fp,48(sp)
  125ea8:	df000c04 	addi	fp,sp,48
  125eac:	e13ffc15 	stw	r4,-16(fp)
  125eb0:	e17ffd15 	stw	r5,-12(fp)
  125eb4:	e1bffe15 	stw	r6,-8(fp)
  125eb8:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
  125ebc:	e0bffe17 	ldw	r2,-8(fp)
  125ec0:	e0bff415 	stw	r2,-48(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
  125ec4:	e0bfff17 	ldw	r2,-4(fp)
  125ec8:	1090000c 	andi	r2,r2,16384
  125ecc:	e0bff515 	stw	r2,-44(fp)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
  125ed0:	00003c06 	br	125fc4 <altera_avalon_uart_write+0x128>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  125ed4:	e0bffc17 	ldw	r2,-16(fp)
  125ed8:	10800517 	ldw	r2,20(r2)
  125edc:	10800044 	addi	r2,r2,1
  125ee0:	10800fcc 	andi	r2,r2,63
  125ee4:	e0bff615 	stw	r2,-40(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
  125ee8:	e0bffc17 	ldw	r2,-16(fp)
  125eec:	10c00417 	ldw	r3,16(r2)
  125ef0:	e0bff617 	ldw	r2,-40(fp)
  125ef4:	1880221e 	bne	r3,r2,125f80 <altera_avalon_uart_write+0xe4>
    {
      if (no_block)
  125ef8:	e0bff517 	ldw	r2,-44(fp)
  125efc:	10000526 	beq	r2,zero,125f14 <altera_avalon_uart_write+0x78>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
  125f00:	0125e4c0 	call	125e4c <alt_get_errno>
  125f04:	1007883a 	mov	r3,r2
  125f08:	008002c4 	movi	r2,11
  125f0c:	18800015 	stw	r2,0(r3)
        break;
  125f10:	00002e06 	br	125fcc <altera_avalon_uart_write+0x130>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  125f14:	0005303a 	rdctl	r2,status
  125f18:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  125f1c:	e0fff817 	ldw	r3,-32(fp)
  125f20:	00bfff84 	movi	r2,-2
  125f24:	1884703a 	and	r2,r3,r2
  125f28:	1001703a 	wrctl	status,r2
  
  return context;
  125f2c:	e0bff817 	ldw	r2,-32(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
  125f30:	e0bff715 	stw	r2,-36(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  125f34:	e0bffc17 	ldw	r2,-16(fp)
  125f38:	10800117 	ldw	r2,4(r2)
  125f3c:	10c11014 	ori	r3,r2,1088
  125f40:	e0bffc17 	ldw	r2,-16(fp)
  125f44:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  125f48:	e0bffc17 	ldw	r2,-16(fp)
  125f4c:	10800017 	ldw	r2,0(r2)
  125f50:	10800304 	addi	r2,r2,12
  125f54:	e0fffc17 	ldw	r3,-16(fp)
  125f58:	18c00117 	ldw	r3,4(r3)
  125f5c:	10c00035 	stwio	r3,0(r2)
  125f60:	e0bff717 	ldw	r2,-36(fp)
  125f64:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  125f68:	e0bff917 	ldw	r2,-28(fp)
  125f6c:	1001703a 	wrctl	status,r2
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
  125f70:	e0bffc17 	ldw	r2,-16(fp)
  125f74:	10c00417 	ldw	r3,16(r2)
  125f78:	e0bff617 	ldw	r2,-40(fp)
  125f7c:	18bffc26 	beq	r3,r2,125f70 <__alt_data_end+0xffff26f0>
      }
    }

    count--;
  125f80:	e0bff417 	ldw	r2,-48(fp)
  125f84:	10bfffc4 	addi	r2,r2,-1
  125f88:	e0bff415 	stw	r2,-48(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
  125f8c:	e0bffc17 	ldw	r2,-16(fp)
  125f90:	10c00517 	ldw	r3,20(r2)
  125f94:	e0bffd17 	ldw	r2,-12(fp)
  125f98:	11000044 	addi	r4,r2,1
  125f9c:	e13ffd15 	stw	r4,-12(fp)
  125fa0:	10800003 	ldbu	r2,0(r2)
  125fa4:	1009883a 	mov	r4,r2
  125fa8:	e0bffc17 	ldw	r2,-16(fp)
  125fac:	10c5883a 	add	r2,r2,r3
  125fb0:	10801704 	addi	r2,r2,92
  125fb4:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
  125fb8:	e0bffc17 	ldw	r2,-16(fp)
  125fbc:	e0fff617 	ldw	r3,-40(fp)
  125fc0:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
  125fc4:	e0bff417 	ldw	r2,-48(fp)
  125fc8:	103fc21e 	bne	r2,zero,125ed4 <__alt_data_end+0xffff2654>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  125fcc:	0005303a 	rdctl	r2,status
  125fd0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  125fd4:	e0fffa17 	ldw	r3,-24(fp)
  125fd8:	00bfff84 	movi	r2,-2
  125fdc:	1884703a 	and	r2,r3,r2
  125fe0:	1001703a 	wrctl	status,r2
  
  return context;
  125fe4:	e0bffa17 	ldw	r2,-24(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
  125fe8:	e0bff715 	stw	r2,-36(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  125fec:	e0bffc17 	ldw	r2,-16(fp)
  125ff0:	10800117 	ldw	r2,4(r2)
  125ff4:	10c11014 	ori	r3,r2,1088
  125ff8:	e0bffc17 	ldw	r2,-16(fp)
  125ffc:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  126000:	e0bffc17 	ldw	r2,-16(fp)
  126004:	10800017 	ldw	r2,0(r2)
  126008:	10800304 	addi	r2,r2,12
  12600c:	e0fffc17 	ldw	r3,-16(fp)
  126010:	18c00117 	ldw	r3,4(r3)
  126014:	10c00035 	stwio	r3,0(r2)
  126018:	e0bff717 	ldw	r2,-36(fp)
  12601c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  126020:	e0bffb17 	ldw	r2,-20(fp)
  126024:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
  126028:	e0fffe17 	ldw	r3,-8(fp)
  12602c:	e0bff417 	ldw	r2,-48(fp)
  126030:	1885c83a 	sub	r2,r3,r2
}
  126034:	e037883a 	mov	sp,fp
  126038:	dfc00117 	ldw	ra,4(sp)
  12603c:	df000017 	ldw	fp,0(sp)
  126040:	dec00204 	addi	sp,sp,8
  126044:	f800283a 	ret

00126048 <alt_up_char_buffer_init>:
#include <priv/alt_file.h>

#include "altera_up_avalon_video_character_buffer_with_dma.h"
#include "altera_up_avalon_video_character_buffer_with_dma_regs.h"

void alt_up_char_buffer_init(alt_up_char_buffer_dev *char_buffer) {
  126048:	defffc04 	addi	sp,sp,-16
  12604c:	dfc00315 	stw	ra,12(sp)
  126050:	df000215 	stw	fp,8(sp)
  126054:	df000204 	addi	fp,sp,8
  126058:	e13fff15 	stw	r4,-4(fp)
	char * name;
	name = (char *) char_buffer->dev.name;
  12605c:	e0bfff17 	ldw	r2,-4(fp)
  126060:	10800217 	ldw	r2,8(r2)
  126064:	e0bffe15 	stw	r2,-8(fp)

	for ( ; (*name) != '\0'; name++) {
  126068:	00000b06 	br	126098 <alt_up_char_buffer_init+0x50>
		if (strcmp(name, "_avalon_char_buffer_slave") == 0) {
  12606c:	e13ffe17 	ldw	r4,-8(fp)
  126070:	014004b4 	movhi	r5,18
  126074:	295e0e04 	addi	r5,r5,30776
  126078:	01272040 	call	127204 <strcmp>
  12607c:	1000031e 	bne	r2,zero,12608c <alt_up_char_buffer_init+0x44>
			(*name) = '\0';
  126080:	e0bffe17 	ldw	r2,-8(fp)
  126084:	10000005 	stb	zero,0(r2)
			break;
  126088:	00000906 	br	1260b0 <alt_up_char_buffer_init+0x68>

void alt_up_char_buffer_init(alt_up_char_buffer_dev *char_buffer) {
	char * name;
	name = (char *) char_buffer->dev.name;

	for ( ; (*name) != '\0'; name++) {
  12608c:	e0bffe17 	ldw	r2,-8(fp)
  126090:	10800044 	addi	r2,r2,1
  126094:	e0bffe15 	stw	r2,-8(fp)
  126098:	e0bffe17 	ldw	r2,-8(fp)
  12609c:	10800003 	ldbu	r2,0(r2)
  1260a0:	10803fcc 	andi	r2,r2,255
  1260a4:	1080201c 	xori	r2,r2,128
  1260a8:	10bfe004 	addi	r2,r2,-128
  1260ac:	103fef1e 	bne	r2,zero,12606c <__alt_data_end+0xffff27ec>
			(*name) = '\0';
			break;
		}
	}
	
	return;
  1260b0:	0001883a 	nop
}
  1260b4:	e037883a 	mov	sp,fp
  1260b8:	dfc00117 	ldw	ra,4(sp)
  1260bc:	df000017 	ldw	fp,0(sp)
  1260c0:	dec00204 	addi	sp,sp,8
  1260c4:	f800283a 	ret

001260c8 <alt_up_char_buffer_open_dev>:

alt_up_char_buffer_dev* alt_up_char_buffer_open_dev(const char* name) {
  1260c8:	defffc04 	addi	sp,sp,-16
  1260cc:	dfc00315 	stw	ra,12(sp)
  1260d0:	df000215 	stw	fp,8(sp)
  1260d4:	df000204 	addi	fp,sp,8
  1260d8:	e13fff15 	stw	r4,-4(fp)
  // find the device from the device list 
  // (see altera_hal/HAL/inc/priv/alt_file.h 
  // and altera_hal/HAL/src/alt_find_dev.c 
  // for details)
  alt_up_char_buffer_dev *dev = (alt_up_char_buffer_dev *)alt_find_dev(name, &alt_dev_list);
  1260dc:	e13fff17 	ldw	r4,-4(fp)
  1260e0:	014004f4 	movhi	r5,19
  1260e4:	2964ef04 	addi	r5,r5,-27716
  1260e8:	01266600 	call	126660 <alt_find_dev>
  1260ec:	e0bffe15 	stw	r2,-8(fp)

  return dev;
  1260f0:	e0bffe17 	ldw	r2,-8(fp)
}
  1260f4:	e037883a 	mov	sp,fp
  1260f8:	dfc00117 	ldw	ra,4(sp)
  1260fc:	df000017 	ldw	fp,0(sp)
  126100:	dec00204 	addi	sp,sp,8
  126104:	f800283a 	ret

00126108 <alt_up_char_buffer_draw>:

int alt_up_char_buffer_draw(alt_up_char_buffer_dev *char_buffer, unsigned char ch, 
	unsigned int x, unsigned int y) {
  126108:	defffa04 	addi	sp,sp,-24
  12610c:	df000515 	stw	fp,20(sp)
  126110:	df000504 	addi	fp,sp,20
  126114:	e13ffc15 	stw	r4,-16(fp)
  126118:	2805883a 	mov	r2,r5
  12611c:	e1bffe15 	stw	r6,-8(fp)
  126120:	e1ffff15 	stw	r7,-4(fp)
  126124:	e0bffd05 	stb	r2,-12(fp)
	// boundary check
	if (x >= char_buffer->x_resolution || y >= char_buffer->y_resolution )
  126128:	e0bffc17 	ldw	r2,-16(fp)
  12612c:	10800c17 	ldw	r2,48(r2)
  126130:	e0fffe17 	ldw	r3,-8(fp)
  126134:	1880042e 	bgeu	r3,r2,126148 <alt_up_char_buffer_draw+0x40>
  126138:	e0bffc17 	ldw	r2,-16(fp)
  12613c:	10800d17 	ldw	r2,52(r2)
  126140:	e0ffff17 	ldw	r3,-4(fp)
  126144:	18800236 	bltu	r3,r2,126150 <alt_up_char_buffer_draw+0x48>
		return -1;
  126148:	00bfffc4 	movi	r2,-1
  12614c:	00001d06 	br	1261c4 <alt_up_char_buffer_draw+0xbc>
	
	unsigned int addr = 0;
  126150:	e03ffb15 	stw	zero,-20(fp)
	addr |= ((x & char_buffer->x_coord_mask) << char_buffer->x_coord_offset);
  126154:	e0bffc17 	ldw	r2,-16(fp)
  126158:	10c00f17 	ldw	r3,60(r2)
  12615c:	e0bffe17 	ldw	r2,-8(fp)
  126160:	1884703a 	and	r2,r3,r2
  126164:	e0fffc17 	ldw	r3,-16(fp)
  126168:	18c00e17 	ldw	r3,56(r3)
  12616c:	10c4983a 	sll	r2,r2,r3
  126170:	e0fffb17 	ldw	r3,-20(fp)
  126174:	1884b03a 	or	r2,r3,r2
  126178:	e0bffb15 	stw	r2,-20(fp)
	addr |= ((y & char_buffer->y_coord_mask) << char_buffer->y_coord_offset);
  12617c:	e0bffc17 	ldw	r2,-16(fp)
  126180:	10c01117 	ldw	r3,68(r2)
  126184:	e0bfff17 	ldw	r2,-4(fp)
  126188:	1884703a 	and	r2,r3,r2
  12618c:	e0fffc17 	ldw	r3,-16(fp)
  126190:	18c01017 	ldw	r3,64(r3)
  126194:	10c4983a 	sll	r2,r2,r3
  126198:	e0fffb17 	ldw	r3,-20(fp)
  12619c:	1884b03a 	or	r2,r3,r2
  1261a0:	e0bffb15 	stw	r2,-20(fp)
	IOWR_8DIRECT(char_buffer->buffer_base, addr, ch);
  1261a4:	e0bffc17 	ldw	r2,-16(fp)
  1261a8:	10c00b17 	ldw	r3,44(r2)
  1261ac:	e0bffb17 	ldw	r2,-20(fp)
  1261b0:	1885883a 	add	r2,r3,r2
  1261b4:	1007883a 	mov	r3,r2
  1261b8:	e0bffd03 	ldbu	r2,-12(fp)
  1261bc:	18800025 	stbio	r2,0(r3)

	return 0;
  1261c0:	0005883a 	mov	r2,zero
}
  1261c4:	e037883a 	mov	sp,fp
  1261c8:	df000017 	ldw	fp,0(sp)
  1261cc:	dec00104 	addi	sp,sp,4
  1261d0:	f800283a 	ret

001261d4 <alt_up_char_buffer_string>:

int alt_up_char_buffer_string(alt_up_char_buffer_dev *char_buffer, const char *ptr, 
	unsigned int x, unsigned int y) {
  1261d4:	defffa04 	addi	sp,sp,-24
  1261d8:	df000515 	stw	fp,20(sp)
  1261dc:	df000504 	addi	fp,sp,20
  1261e0:	e13ffc15 	stw	r4,-16(fp)
  1261e4:	e17ffd15 	stw	r5,-12(fp)
  1261e8:	e1bffe15 	stw	r6,-8(fp)
  1261ec:	e1ffff15 	stw	r7,-4(fp)
	// boundary check
	if (x >= char_buffer->x_resolution || y >= char_buffer->y_resolution )
  1261f0:	e0bffc17 	ldw	r2,-16(fp)
  1261f4:	10800c17 	ldw	r2,48(r2)
  1261f8:	e0fffe17 	ldw	r3,-8(fp)
  1261fc:	1880042e 	bgeu	r3,r2,126210 <alt_up_char_buffer_string+0x3c>
  126200:	e0bffc17 	ldw	r2,-16(fp)
  126204:	10800d17 	ldw	r2,52(r2)
  126208:	e0ffff17 	ldw	r3,-4(fp)
  12620c:	18800236 	bltu	r3,r2,126218 <alt_up_char_buffer_string+0x44>
		return -1;
  126210:	00bfffc4 	movi	r2,-1
  126214:	00002b06 	br	1262c4 <alt_up_char_buffer_string+0xf0>
	
	unsigned int offset = 0;
  126218:	e03ffb15 	stw	zero,-20(fp)
	offset = (y << char_buffer->y_coord_offset) + x;
  12621c:	e0bffc17 	ldw	r2,-16(fp)
  126220:	10801017 	ldw	r2,64(r2)
  126224:	1007883a 	mov	r3,r2
  126228:	e0bfff17 	ldw	r2,-4(fp)
  12622c:	10c6983a 	sll	r3,r2,r3
  126230:	e0bffe17 	ldw	r2,-8(fp)
  126234:	1885883a 	add	r2,r3,r2
  126238:	e0bffb15 	stw	r2,-20(fp)

	while ( *ptr )
  12623c:	00001a06 	br	1262a8 <alt_up_char_buffer_string+0xd4>
	{
		IOWR_8DIRECT(char_buffer->buffer_base, offset, *ptr);
  126240:	e0bffc17 	ldw	r2,-16(fp)
  126244:	10c00b17 	ldw	r3,44(r2)
  126248:	e0bffb17 	ldw	r2,-20(fp)
  12624c:	1885883a 	add	r2,r3,r2
  126250:	1007883a 	mov	r3,r2
  126254:	e0bffd17 	ldw	r2,-12(fp)
  126258:	10800003 	ldbu	r2,0(r2)
  12625c:	10803fcc 	andi	r2,r2,255
  126260:	1080201c 	xori	r2,r2,128
  126264:	10bfe004 	addi	r2,r2,-128
  126268:	18800025 	stbio	r2,0(r3)
		++ptr;
  12626c:	e0bffd17 	ldw	r2,-12(fp)
  126270:	10800044 	addi	r2,r2,1
  126274:	e0bffd15 	stw	r2,-12(fp)
		if (++x >= char_buffer->x_resolution)
  126278:	e0bffe17 	ldw	r2,-8(fp)
  12627c:	10800044 	addi	r2,r2,1
  126280:	e0bffe15 	stw	r2,-8(fp)
  126284:	e0bffc17 	ldw	r2,-16(fp)
  126288:	10800c17 	ldw	r2,48(r2)
  12628c:	e0fffe17 	ldw	r3,-8(fp)
  126290:	18800236 	bltu	r3,r2,12629c <alt_up_char_buffer_string+0xc8>
			return -1;
  126294:	00bfffc4 	movi	r2,-1
  126298:	00000a06 	br	1262c4 <alt_up_char_buffer_string+0xf0>
		++offset;
  12629c:	e0bffb17 	ldw	r2,-20(fp)
  1262a0:	10800044 	addi	r2,r2,1
  1262a4:	e0bffb15 	stw	r2,-20(fp)
		return -1;
	
	unsigned int offset = 0;
	offset = (y << char_buffer->y_coord_offset) + x;

	while ( *ptr )
  1262a8:	e0bffd17 	ldw	r2,-12(fp)
  1262ac:	10800003 	ldbu	r2,0(r2)
  1262b0:	10803fcc 	andi	r2,r2,255
  1262b4:	1080201c 	xori	r2,r2,128
  1262b8:	10bfe004 	addi	r2,r2,-128
  1262bc:	103fe01e 	bne	r2,zero,126240 <__alt_data_end+0xffff29c0>
		++ptr;
		if (++x >= char_buffer->x_resolution)
			return -1;
		++offset;
	}
	return 0;
  1262c0:	0005883a 	mov	r2,zero
}
  1262c4:	e037883a 	mov	sp,fp
  1262c8:	df000017 	ldw	fp,0(sp)
  1262cc:	dec00104 	addi	sp,sp,4
  1262d0:	f800283a 	ret

001262d4 <alt_up_char_buffer_clear>:

int alt_up_char_buffer_clear(alt_up_char_buffer_dev *char_buffer) {
  1262d4:	defffe04 	addi	sp,sp,-8
  1262d8:	df000115 	stw	fp,4(sp)
  1262dc:	df000104 	addi	fp,sp,4
  1262e0:	e13fff15 	stw	r4,-4(fp)
	IOWR_ALT_UP_CHAR_BUFFER_CLR_SCRN(char_buffer->ctrl_reg_base, 1);
  1262e4:	e0bfff17 	ldw	r2,-4(fp)
  1262e8:	10800a17 	ldw	r2,40(r2)
  1262ec:	10800084 	addi	r2,r2,2
  1262f0:	1007883a 	mov	r3,r2
  1262f4:	00800044 	movi	r2,1
  1262f8:	18800025 	stbio	r2,0(r3)
	while ((IORD_ALT_UP_CHAR_BUFFER_CLR_SCRN(char_buffer->ctrl_reg_base) & ALT_UP_CHAR_BUFFER_CLR_SCRN_MSK) >> ALT_UP_CHAR_BUFFER_CLR_SCRN_OFST);
  1262fc:	0001883a 	nop
  126300:	e0bfff17 	ldw	r2,-4(fp)
  126304:	10800a17 	ldw	r2,40(r2)
  126308:	10800084 	addi	r2,r2,2
  12630c:	10800023 	ldbuio	r2,0(r2)
  126310:	10803fcc 	andi	r2,r2,255
  126314:	1080004c 	andi	r2,r2,1
  126318:	103ff91e 	bne	r2,zero,126300 <__alt_data_end+0xffff2a80>
	return 0;
  12631c:	0005883a 	mov	r2,zero
}
  126320:	e037883a 	mov	sp,fp
  126324:	df000017 	ldw	fp,0(sp)
  126328:	dec00104 	addi	sp,sp,4
  12632c:	f800283a 	ret

00126330 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
  126330:	defff504 	addi	sp,sp,-44
  126334:	df000a15 	stw	fp,40(sp)
  126338:	df000a04 	addi	fp,sp,40
  12633c:	e13ffc15 	stw	r4,-16(fp)
  126340:	e17ffd15 	stw	r5,-12(fp)
  126344:	e1bffe15 	stw	r6,-8(fp)
  126348:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
  12634c:	e03ff615 	stw	zero,-40(fp)
  126350:	008004f4 	movhi	r2,19
  126354:	10abe504 	addi	r2,r2,-20588
  126358:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
  12635c:	10003f26 	beq	r2,zero,12645c <alt_alarm_start+0x12c>
  {
    if (alarm)
  126360:	e0bffc17 	ldw	r2,-16(fp)
  126364:	10003b26 	beq	r2,zero,126454 <alt_alarm_start+0x124>
    {
      alarm->callback = callback;
  126368:	e0bffc17 	ldw	r2,-16(fp)
  12636c:	e0fffe17 	ldw	r3,-8(fp)
  126370:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
  126374:	e0bffc17 	ldw	r2,-16(fp)
  126378:	e0ffff17 	ldw	r3,-4(fp)
  12637c:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  126380:	0005303a 	rdctl	r2,status
  126384:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  126388:	e0fff817 	ldw	r3,-32(fp)
  12638c:	00bfff84 	movi	r2,-2
  126390:	1884703a 	and	r2,r3,r2
  126394:	1001703a 	wrctl	status,r2
  
  return context;
  126398:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
  12639c:	e0bff715 	stw	r2,-36(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
  1263a0:	008004f4 	movhi	r2,19
  1263a4:	10abe604 	addi	r2,r2,-20584
  1263a8:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
  1263ac:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
  1263b0:	e0fffd17 	ldw	r3,-12(fp)
  1263b4:	e0bff617 	ldw	r2,-40(fp)
  1263b8:	1885883a 	add	r2,r3,r2
  1263bc:	10c00044 	addi	r3,r2,1
  1263c0:	e0bffc17 	ldw	r2,-16(fp)
  1263c4:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
  1263c8:	e0bffc17 	ldw	r2,-16(fp)
  1263cc:	10c00217 	ldw	r3,8(r2)
  1263d0:	e0bff617 	ldw	r2,-40(fp)
  1263d4:	1880042e 	bgeu	r3,r2,1263e8 <alt_alarm_start+0xb8>
      {
        alarm->rollover = 1;
  1263d8:	e0bffc17 	ldw	r2,-16(fp)
  1263dc:	00c00044 	movi	r3,1
  1263e0:	10c00405 	stb	r3,16(r2)
  1263e4:	00000206 	br	1263f0 <alt_alarm_start+0xc0>
      }
      else
      {
        alarm->rollover = 0;
  1263e8:	e0bffc17 	ldw	r2,-16(fp)
  1263ec:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
  1263f0:	e0fffc17 	ldw	r3,-16(fp)
  1263f4:	008004f4 	movhi	r2,19
  1263f8:	10a4f704 	addi	r2,r2,-27684
  1263fc:	e0bff915 	stw	r2,-28(fp)
  126400:	e0fffa15 	stw	r3,-24(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  126404:	e0bffa17 	ldw	r2,-24(fp)
  126408:	e0fff917 	ldw	r3,-28(fp)
  12640c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  126410:	e0bff917 	ldw	r2,-28(fp)
  126414:	10c00017 	ldw	r3,0(r2)
  126418:	e0bffa17 	ldw	r2,-24(fp)
  12641c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  126420:	e0bff917 	ldw	r2,-28(fp)
  126424:	10800017 	ldw	r2,0(r2)
  126428:	e0fffa17 	ldw	r3,-24(fp)
  12642c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  126430:	e0bff917 	ldw	r2,-28(fp)
  126434:	e0fffa17 	ldw	r3,-24(fp)
  126438:	10c00015 	stw	r3,0(r2)
  12643c:	e0bff717 	ldw	r2,-36(fp)
  126440:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  126444:	e0bffb17 	ldw	r2,-20(fp)
  126448:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
  12644c:	0005883a 	mov	r2,zero
  126450:	00000306 	br	126460 <alt_alarm_start+0x130>
    }
    else
    {
      return -EINVAL;
  126454:	00bffa84 	movi	r2,-22
  126458:	00000106 	br	126460 <alt_alarm_start+0x130>
    }
  }
  else
  {
    return -ENOTSUP;
  12645c:	00bfde84 	movi	r2,-134
  }
}
  126460:	e037883a 	mov	sp,fp
  126464:	df000017 	ldw	fp,0(sp)
  126468:	dec00104 	addi	sp,sp,4
  12646c:	f800283a 	ret

00126470 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  126470:	defffe04 	addi	sp,sp,-8
  126474:	df000115 	stw	fp,4(sp)
  126478:	df000104 	addi	fp,sp,4
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  12647c:	e03fff15 	stw	zero,-4(fp)
  126480:	00000506 	br	126498 <alt_dcache_flush_all+0x28>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  126484:	e0bfff17 	ldw	r2,-4(fp)
  126488:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  12648c:	e0bfff17 	ldw	r2,-4(fp)
  126490:	10800804 	addi	r2,r2,32
  126494:	e0bfff15 	stw	r2,-4(fp)
  126498:	e0bfff17 	ldw	r2,-4(fp)
  12649c:	10820030 	cmpltui	r2,r2,2048
  1264a0:	103ff81e 	bne	r2,zero,126484 <__alt_data_end+0xffff2c04>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
  1264a4:	e037883a 	mov	sp,fp
  1264a8:	df000017 	ldw	fp,0(sp)
  1264ac:	dec00104 	addi	sp,sp,4
  1264b0:	f800283a 	ret

001264b4 <alt_get_errno>:
  1264b4:	defffe04 	addi	sp,sp,-8
  1264b8:	dfc00115 	stw	ra,4(sp)
  1264bc:	df000015 	stw	fp,0(sp)
  1264c0:	d839883a 	mov	fp,sp
  1264c4:	008004f4 	movhi	r2,19
  1264c8:	10a4f204 	addi	r2,r2,-27704
  1264cc:	10800017 	ldw	r2,0(r2)
  1264d0:	10000526 	beq	r2,zero,1264e8 <alt_get_errno+0x34>
  1264d4:	008004f4 	movhi	r2,19
  1264d8:	10a4f204 	addi	r2,r2,-27704
  1264dc:	10800017 	ldw	r2,0(r2)
  1264e0:	103ee83a 	callr	r2
  1264e4:	00000206 	br	1264f0 <alt_get_errno+0x3c>
  1264e8:	008004f4 	movhi	r2,19
  1264ec:	10abdd04 	addi	r2,r2,-20620
  1264f0:	e037883a 	mov	sp,fp
  1264f4:	dfc00117 	ldw	ra,4(sp)
  1264f8:	df000017 	ldw	fp,0(sp)
  1264fc:	dec00204 	addi	sp,sp,8
  126500:	f800283a 	ret

00126504 <alt_dev_llist_insert>:
  126504:	defffa04 	addi	sp,sp,-24
  126508:	dfc00515 	stw	ra,20(sp)
  12650c:	df000415 	stw	fp,16(sp)
  126510:	df000404 	addi	fp,sp,16
  126514:	e13ffe15 	stw	r4,-8(fp)
  126518:	e17fff15 	stw	r5,-4(fp)
  12651c:	e0bffe17 	ldw	r2,-8(fp)
  126520:	10000326 	beq	r2,zero,126530 <alt_dev_llist_insert+0x2c>
  126524:	e0bffe17 	ldw	r2,-8(fp)
  126528:	10800217 	ldw	r2,8(r2)
  12652c:	1000061e 	bne	r2,zero,126548 <alt_dev_llist_insert+0x44>
  126530:	01264b40 	call	1264b4 <alt_get_errno>
  126534:	1007883a 	mov	r3,r2
  126538:	00800584 	movi	r2,22
  12653c:	18800015 	stw	r2,0(r3)
  126540:	00bffa84 	movi	r2,-22
  126544:	00001306 	br	126594 <alt_dev_llist_insert+0x90>
  126548:	e0bffe17 	ldw	r2,-8(fp)
  12654c:	e0ffff17 	ldw	r3,-4(fp)
  126550:	e0fffc15 	stw	r3,-16(fp)
  126554:	e0bffd15 	stw	r2,-12(fp)
  126558:	e0bffd17 	ldw	r2,-12(fp)
  12655c:	e0fffc17 	ldw	r3,-16(fp)
  126560:	10c00115 	stw	r3,4(r2)
  126564:	e0bffc17 	ldw	r2,-16(fp)
  126568:	10c00017 	ldw	r3,0(r2)
  12656c:	e0bffd17 	ldw	r2,-12(fp)
  126570:	10c00015 	stw	r3,0(r2)
  126574:	e0bffc17 	ldw	r2,-16(fp)
  126578:	10800017 	ldw	r2,0(r2)
  12657c:	e0fffd17 	ldw	r3,-12(fp)
  126580:	10c00115 	stw	r3,4(r2)
  126584:	e0bffc17 	ldw	r2,-16(fp)
  126588:	e0fffd17 	ldw	r3,-12(fp)
  12658c:	10c00015 	stw	r3,0(r2)
  126590:	0005883a 	mov	r2,zero
  126594:	e037883a 	mov	sp,fp
  126598:	dfc00117 	ldw	ra,4(sp)
  12659c:	df000017 	ldw	fp,0(sp)
  1265a0:	dec00204 	addi	sp,sp,8
  1265a4:	f800283a 	ret

001265a8 <_do_ctors>:
  1265a8:	defffd04 	addi	sp,sp,-12
  1265ac:	dfc00215 	stw	ra,8(sp)
  1265b0:	df000115 	stw	fp,4(sp)
  1265b4:	df000104 	addi	fp,sp,4
  1265b8:	008004b4 	movhi	r2,18
  1265bc:	109dbc04 	addi	r2,r2,30448
  1265c0:	e0bfff15 	stw	r2,-4(fp)
  1265c4:	00000606 	br	1265e0 <_do_ctors+0x38>
  1265c8:	e0bfff17 	ldw	r2,-4(fp)
  1265cc:	10800017 	ldw	r2,0(r2)
  1265d0:	103ee83a 	callr	r2
  1265d4:	e0bfff17 	ldw	r2,-4(fp)
  1265d8:	10bfff04 	addi	r2,r2,-4
  1265dc:	e0bfff15 	stw	r2,-4(fp)
  1265e0:	e0ffff17 	ldw	r3,-4(fp)
  1265e4:	008004b4 	movhi	r2,18
  1265e8:	109dbd04 	addi	r2,r2,30452
  1265ec:	18bff62e 	bgeu	r3,r2,1265c8 <__alt_data_end+0xffff2d48>
  1265f0:	e037883a 	mov	sp,fp
  1265f4:	dfc00117 	ldw	ra,4(sp)
  1265f8:	df000017 	ldw	fp,0(sp)
  1265fc:	dec00204 	addi	sp,sp,8
  126600:	f800283a 	ret

00126604 <_do_dtors>:
  126604:	defffd04 	addi	sp,sp,-12
  126608:	dfc00215 	stw	ra,8(sp)
  12660c:	df000115 	stw	fp,4(sp)
  126610:	df000104 	addi	fp,sp,4
  126614:	008004b4 	movhi	r2,18
  126618:	109dbc04 	addi	r2,r2,30448
  12661c:	e0bfff15 	stw	r2,-4(fp)
  126620:	00000606 	br	12663c <_do_dtors+0x38>
  126624:	e0bfff17 	ldw	r2,-4(fp)
  126628:	10800017 	ldw	r2,0(r2)
  12662c:	103ee83a 	callr	r2
  126630:	e0bfff17 	ldw	r2,-4(fp)
  126634:	10bfff04 	addi	r2,r2,-4
  126638:	e0bfff15 	stw	r2,-4(fp)
  12663c:	e0ffff17 	ldw	r3,-4(fp)
  126640:	008004b4 	movhi	r2,18
  126644:	109dbd04 	addi	r2,r2,30452
  126648:	18bff62e 	bgeu	r3,r2,126624 <__alt_data_end+0xffff2da4>
  12664c:	e037883a 	mov	sp,fp
  126650:	dfc00117 	ldw	ra,4(sp)
  126654:	df000017 	ldw	fp,0(sp)
  126658:	dec00204 	addi	sp,sp,8
  12665c:	f800283a 	ret

00126660 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  126660:	defffa04 	addi	sp,sp,-24
  126664:	dfc00515 	stw	ra,20(sp)
  126668:	df000415 	stw	fp,16(sp)
  12666c:	df000404 	addi	fp,sp,16
  126670:	e13ffe15 	stw	r4,-8(fp)
  126674:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
  126678:	e0bfff17 	ldw	r2,-4(fp)
  12667c:	10800017 	ldw	r2,0(r2)
  126680:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
  126684:	e13ffe17 	ldw	r4,-8(fp)
  126688:	01227840 	call	122784 <strlen>
  12668c:	10800044 	addi	r2,r2,1
  126690:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  126694:	00000d06 	br	1266cc <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  126698:	e0bffc17 	ldw	r2,-16(fp)
  12669c:	10c00217 	ldw	r3,8(r2)
  1266a0:	e0bffd17 	ldw	r2,-12(fp)
  1266a4:	1809883a 	mov	r4,r3
  1266a8:	e17ffe17 	ldw	r5,-8(fp)
  1266ac:	100d883a 	mov	r6,r2
  1266b0:	01270200 	call	127020 <memcmp>
  1266b4:	1000021e 	bne	r2,zero,1266c0 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
  1266b8:	e0bffc17 	ldw	r2,-16(fp)
  1266bc:	00000706 	br	1266dc <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
  1266c0:	e0bffc17 	ldw	r2,-16(fp)
  1266c4:	10800017 	ldw	r2,0(r2)
  1266c8:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  1266cc:	e0fffc17 	ldw	r3,-16(fp)
  1266d0:	e0bfff17 	ldw	r2,-4(fp)
  1266d4:	18bff01e 	bne	r3,r2,126698 <__alt_data_end+0xffff2e18>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
  1266d8:	0005883a 	mov	r2,zero
}
  1266dc:	e037883a 	mov	sp,fp
  1266e0:	dfc00117 	ldw	ra,4(sp)
  1266e4:	df000017 	ldw	fp,0(sp)
  1266e8:	dec00204 	addi	sp,sp,8
  1266ec:	f800283a 	ret

001266f0 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
  1266f0:	defffb04 	addi	sp,sp,-20
  1266f4:	dfc00415 	stw	ra,16(sp)
  1266f8:	df000315 	stw	fp,12(sp)
  1266fc:	df000304 	addi	fp,sp,12
  126700:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
  126704:	008004f4 	movhi	r2,19
  126708:	10a4ed04 	addi	r2,r2,-27724
  12670c:	10800017 	ldw	r2,0(r2)
  126710:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  126714:	00003106 	br	1267dc <alt_find_file+0xec>
  {
    len = strlen(next->name);
  126718:	e0bffd17 	ldw	r2,-12(fp)
  12671c:	10800217 	ldw	r2,8(r2)
  126720:	1009883a 	mov	r4,r2
  126724:	01227840 	call	122784 <strlen>
  126728:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
  12672c:	e0bffd17 	ldw	r2,-12(fp)
  126730:	10c00217 	ldw	r3,8(r2)
  126734:	e0bffe17 	ldw	r2,-8(fp)
  126738:	10bfffc4 	addi	r2,r2,-1
  12673c:	1885883a 	add	r2,r3,r2
  126740:	10800003 	ldbu	r2,0(r2)
  126744:	10803fcc 	andi	r2,r2,255
  126748:	1080201c 	xori	r2,r2,128
  12674c:	10bfe004 	addi	r2,r2,-128
  126750:	10800bd8 	cmpnei	r2,r2,47
  126754:	1000031e 	bne	r2,zero,126764 <alt_find_file+0x74>
    {
      len -= 1;
  126758:	e0bffe17 	ldw	r2,-8(fp)
  12675c:	10bfffc4 	addi	r2,r2,-1
  126760:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  126764:	e0bffe17 	ldw	r2,-8(fp)
  126768:	e0ffff17 	ldw	r3,-4(fp)
  12676c:	1885883a 	add	r2,r3,r2
  126770:	10800003 	ldbu	r2,0(r2)
  126774:	10803fcc 	andi	r2,r2,255
  126778:	1080201c 	xori	r2,r2,128
  12677c:	10bfe004 	addi	r2,r2,-128
  126780:	10800be0 	cmpeqi	r2,r2,47
  126784:	1000081e 	bne	r2,zero,1267a8 <alt_find_file+0xb8>
  126788:	e0bffe17 	ldw	r2,-8(fp)
  12678c:	e0ffff17 	ldw	r3,-4(fp)
  126790:	1885883a 	add	r2,r3,r2
  126794:	10800003 	ldbu	r2,0(r2)
  126798:	10803fcc 	andi	r2,r2,255
  12679c:	1080201c 	xori	r2,r2,128
  1267a0:	10bfe004 	addi	r2,r2,-128
  1267a4:	10000a1e 	bne	r2,zero,1267d0 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
  1267a8:	e0bffd17 	ldw	r2,-12(fp)
  1267ac:	10c00217 	ldw	r3,8(r2)
  1267b0:	e0bffe17 	ldw	r2,-8(fp)
  1267b4:	1809883a 	mov	r4,r3
  1267b8:	e17fff17 	ldw	r5,-4(fp)
  1267bc:	100d883a 	mov	r6,r2
  1267c0:	01270200 	call	127020 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  1267c4:	1000021e 	bne	r2,zero,1267d0 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
  1267c8:	e0bffd17 	ldw	r2,-12(fp)
  1267cc:	00000806 	br	1267f0 <alt_find_file+0x100>
    }
    next = (alt_dev*) next->llist.next;
  1267d0:	e0bffd17 	ldw	r2,-12(fp)
  1267d4:	10800017 	ldw	r2,0(r2)
  1267d8:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  1267dc:	e0fffd17 	ldw	r3,-12(fp)
  1267e0:	008004f4 	movhi	r2,19
  1267e4:	10a4ed04 	addi	r2,r2,-27724
  1267e8:	18bfcb1e 	bne	r3,r2,126718 <__alt_data_end+0xffff2e98>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
  1267ec:	0005883a 	mov	r2,zero
}
  1267f0:	e037883a 	mov	sp,fp
  1267f4:	dfc00117 	ldw	ra,4(sp)
  1267f8:	df000017 	ldw	fp,0(sp)
  1267fc:	dec00204 	addi	sp,sp,8
  126800:	f800283a 	ret

00126804 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
  126804:	defffc04 	addi	sp,sp,-16
  126808:	df000315 	stw	fp,12(sp)
  12680c:	df000304 	addi	fp,sp,12
  126810:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
  126814:	00bffa04 	movi	r2,-24
  126818:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  12681c:	e03ffd15 	stw	zero,-12(fp)
  126820:	00001d06 	br	126898 <alt_get_fd+0x94>
  {
    if (!alt_fd_list[i].dev)
  126824:	008004f4 	movhi	r2,19
  126828:	10a02a04 	addi	r2,r2,-32600
  12682c:	e0fffd17 	ldw	r3,-12(fp)
  126830:	18c00324 	muli	r3,r3,12
  126834:	10c5883a 	add	r2,r2,r3
  126838:	10800017 	ldw	r2,0(r2)
  12683c:	1000131e 	bne	r2,zero,12688c <alt_get_fd+0x88>
    {
      alt_fd_list[i].dev = dev;
  126840:	008004f4 	movhi	r2,19
  126844:	10a02a04 	addi	r2,r2,-32600
  126848:	e0fffd17 	ldw	r3,-12(fp)
  12684c:	18c00324 	muli	r3,r3,12
  126850:	10c5883a 	add	r2,r2,r3
  126854:	e0ffff17 	ldw	r3,-4(fp)
  126858:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
  12685c:	008004f4 	movhi	r2,19
  126860:	10a4f104 	addi	r2,r2,-27708
  126864:	10c00017 	ldw	r3,0(r2)
  126868:	e0bffd17 	ldw	r2,-12(fp)
  12686c:	1880040e 	bge	r3,r2,126880 <alt_get_fd+0x7c>
      {
        alt_max_fd = i;
  126870:	008004f4 	movhi	r2,19
  126874:	10a4f104 	addi	r2,r2,-27708
  126878:	e0fffd17 	ldw	r3,-12(fp)
  12687c:	10c00015 	stw	r3,0(r2)
      }
      rc = i;
  126880:	e0bffd17 	ldw	r2,-12(fp)
  126884:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
  126888:	00000606 	br	1268a4 <alt_get_fd+0xa0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  12688c:	e0bffd17 	ldw	r2,-12(fp)
  126890:	10800044 	addi	r2,r2,1
  126894:	e0bffd15 	stw	r2,-12(fp)
  126898:	e0bffd17 	ldw	r2,-12(fp)
  12689c:	10800810 	cmplti	r2,r2,32
  1268a0:	103fe01e 	bne	r2,zero,126824 <__alt_data_end+0xffff2fa4>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
  1268a4:	e0bffe17 	ldw	r2,-8(fp)
}
  1268a8:	e037883a 	mov	sp,fp
  1268ac:	df000017 	ldw	fp,0(sp)
  1268b0:	dec00104 	addi	sp,sp,4
  1268b4:	f800283a 	ret

001268b8 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  1268b8:	defffe04 	addi	sp,sp,-8
  1268bc:	dfc00115 	stw	ra,4(sp)
  1268c0:	df000015 	stw	fp,0(sp)
  1268c4:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
  1268c8:	0009883a 	mov	r4,zero
  1268cc:	01440004 	movi	r5,4096
  1268d0:	0126eac0 	call	126eac <alt_icache_flush>
#endif
}
  1268d4:	e037883a 	mov	sp,fp
  1268d8:	dfc00117 	ldw	ra,4(sp)
  1268dc:	df000017 	ldw	fp,0(sp)
  1268e0:	dec00204 	addi	sp,sp,8
  1268e4:	f800283a 	ret

001268e8 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  1268e8:	defff904 	addi	sp,sp,-28
  1268ec:	dfc00615 	stw	ra,24(sp)
  1268f0:	df000515 	stw	fp,20(sp)
  1268f4:	df000504 	addi	fp,sp,20
  1268f8:	e13ffc15 	stw	r4,-16(fp)
  1268fc:	e17ffd15 	stw	r5,-12(fp)
  126900:	e1bffe15 	stw	r6,-8(fp)
  126904:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  126908:	e0800217 	ldw	r2,8(fp)
  12690c:	d8800015 	stw	r2,0(sp)
  126910:	e13ffc17 	ldw	r4,-16(fp)
  126914:	e17ffd17 	ldw	r5,-12(fp)
  126918:	e1bffe17 	ldw	r6,-8(fp)
  12691c:	e1ffff17 	ldw	r7,-4(fp)
  126920:	0126ac80 	call	126ac8 <alt_iic_isr_register>
}  
  126924:	e037883a 	mov	sp,fp
  126928:	dfc00117 	ldw	ra,4(sp)
  12692c:	df000017 	ldw	fp,0(sp)
  126930:	dec00204 	addi	sp,sp,8
  126934:	f800283a 	ret

00126938 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
  126938:	defff904 	addi	sp,sp,-28
  12693c:	df000615 	stw	fp,24(sp)
  126940:	df000604 	addi	fp,sp,24
  126944:	e13ffe15 	stw	r4,-8(fp)
  126948:	e17fff15 	stw	r5,-4(fp)
  12694c:	e0bfff17 	ldw	r2,-4(fp)
  126950:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  126954:	0005303a 	rdctl	r2,status
  126958:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  12695c:	e0fffb17 	ldw	r3,-20(fp)
  126960:	00bfff84 	movi	r2,-2
  126964:	1884703a 	and	r2,r3,r2
  126968:	1001703a 	wrctl	status,r2
  
  return context;
  12696c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  126970:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
  126974:	e0bffa17 	ldw	r2,-24(fp)
  126978:	00c00044 	movi	r3,1
  12697c:	1884983a 	sll	r2,r3,r2
  126980:	1007883a 	mov	r3,r2
  126984:	008004f4 	movhi	r2,19
  126988:	10abe404 	addi	r2,r2,-20592
  12698c:	10800017 	ldw	r2,0(r2)
  126990:	1886b03a 	or	r3,r3,r2
  126994:	008004f4 	movhi	r2,19
  126998:	10abe404 	addi	r2,r2,-20592
  12699c:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  1269a0:	008004f4 	movhi	r2,19
  1269a4:	10abe404 	addi	r2,r2,-20592
  1269a8:	10800017 	ldw	r2,0(r2)
  1269ac:	100170fa 	wrctl	ienable,r2
  1269b0:	e0bffc17 	ldw	r2,-16(fp)
  1269b4:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  1269b8:	e0bffd17 	ldw	r2,-12(fp)
  1269bc:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  1269c0:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
  1269c4:	0001883a 	nop
}
  1269c8:	e037883a 	mov	sp,fp
  1269cc:	df000017 	ldw	fp,0(sp)
  1269d0:	dec00104 	addi	sp,sp,4
  1269d4:	f800283a 	ret

001269d8 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
  1269d8:	defff904 	addi	sp,sp,-28
  1269dc:	df000615 	stw	fp,24(sp)
  1269e0:	df000604 	addi	fp,sp,24
  1269e4:	e13ffe15 	stw	r4,-8(fp)
  1269e8:	e17fff15 	stw	r5,-4(fp)
  1269ec:	e0bfff17 	ldw	r2,-4(fp)
  1269f0:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  1269f4:	0005303a 	rdctl	r2,status
  1269f8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  1269fc:	e0fffb17 	ldw	r3,-20(fp)
  126a00:	00bfff84 	movi	r2,-2
  126a04:	1884703a 	and	r2,r3,r2
  126a08:	1001703a 	wrctl	status,r2
  
  return context;
  126a0c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  126a10:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
  126a14:	e0bffa17 	ldw	r2,-24(fp)
  126a18:	00c00044 	movi	r3,1
  126a1c:	1884983a 	sll	r2,r3,r2
  126a20:	0084303a 	nor	r2,zero,r2
  126a24:	1007883a 	mov	r3,r2
  126a28:	008004f4 	movhi	r2,19
  126a2c:	10abe404 	addi	r2,r2,-20592
  126a30:	10800017 	ldw	r2,0(r2)
  126a34:	1886703a 	and	r3,r3,r2
  126a38:	008004f4 	movhi	r2,19
  126a3c:	10abe404 	addi	r2,r2,-20592
  126a40:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  126a44:	008004f4 	movhi	r2,19
  126a48:	10abe404 	addi	r2,r2,-20592
  126a4c:	10800017 	ldw	r2,0(r2)
  126a50:	100170fa 	wrctl	ienable,r2
  126a54:	e0bffc17 	ldw	r2,-16(fp)
  126a58:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  126a5c:	e0bffd17 	ldw	r2,-12(fp)
  126a60:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  126a64:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
  126a68:	0001883a 	nop
}
  126a6c:	e037883a 	mov	sp,fp
  126a70:	df000017 	ldw	fp,0(sp)
  126a74:	dec00104 	addi	sp,sp,4
  126a78:	f800283a 	ret

00126a7c <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
  126a7c:	defffc04 	addi	sp,sp,-16
  126a80:	df000315 	stw	fp,12(sp)
  126a84:	df000304 	addi	fp,sp,12
  126a88:	e13ffe15 	stw	r4,-8(fp)
  126a8c:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  126a90:	000530fa 	rdctl	r2,ienable
  126a94:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
  126a98:	e0bfff17 	ldw	r2,-4(fp)
  126a9c:	00c00044 	movi	r3,1
  126aa0:	1884983a 	sll	r2,r3,r2
  126aa4:	1007883a 	mov	r3,r2
  126aa8:	e0bffd17 	ldw	r2,-12(fp)
  126aac:	1884703a 	and	r2,r3,r2
  126ab0:	1004c03a 	cmpne	r2,r2,zero
  126ab4:	10803fcc 	andi	r2,r2,255
}
  126ab8:	e037883a 	mov	sp,fp
  126abc:	df000017 	ldw	fp,0(sp)
  126ac0:	dec00104 	addi	sp,sp,4
  126ac4:	f800283a 	ret

00126ac8 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  126ac8:	defff504 	addi	sp,sp,-44
  126acc:	dfc00a15 	stw	ra,40(sp)
  126ad0:	df000915 	stw	fp,36(sp)
  126ad4:	df000904 	addi	fp,sp,36
  126ad8:	e13ffc15 	stw	r4,-16(fp)
  126adc:	e17ffd15 	stw	r5,-12(fp)
  126ae0:	e1bffe15 	stw	r6,-8(fp)
  126ae4:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
  126ae8:	00bffa84 	movi	r2,-22
  126aec:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  126af0:	e0bffd17 	ldw	r2,-12(fp)
  126af4:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
  126af8:	e0bff817 	ldw	r2,-32(fp)
  126afc:	10800808 	cmpgei	r2,r2,32
  126b00:	1000271e 	bne	r2,zero,126ba0 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  126b04:	0005303a 	rdctl	r2,status
  126b08:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  126b0c:	e0fffa17 	ldw	r3,-24(fp)
  126b10:	00bfff84 	movi	r2,-2
  126b14:	1884703a 	and	r2,r3,r2
  126b18:	1001703a 	wrctl	status,r2
  
  return context;
  126b1c:	e0bffa17 	ldw	r2,-24(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
  126b20:	e0bff915 	stw	r2,-28(fp)

    alt_irq[id].handler = isr;
  126b24:	008004f4 	movhi	r2,19
  126b28:	10abf204 	addi	r2,r2,-20536
  126b2c:	e0fff817 	ldw	r3,-32(fp)
  126b30:	180690fa 	slli	r3,r3,3
  126b34:	10c5883a 	add	r2,r2,r3
  126b38:	e0fffe17 	ldw	r3,-8(fp)
  126b3c:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
  126b40:	008004f4 	movhi	r2,19
  126b44:	10abf204 	addi	r2,r2,-20536
  126b48:	e0fff817 	ldw	r3,-32(fp)
  126b4c:	180690fa 	slli	r3,r3,3
  126b50:	10c5883a 	add	r2,r2,r3
  126b54:	10800104 	addi	r2,r2,4
  126b58:	e0ffff17 	ldw	r3,-4(fp)
  126b5c:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  126b60:	e0bffe17 	ldw	r2,-8(fp)
  126b64:	10000526 	beq	r2,zero,126b7c <alt_iic_isr_register+0xb4>
  126b68:	e0bff817 	ldw	r2,-32(fp)
  126b6c:	e13ffc17 	ldw	r4,-16(fp)
  126b70:	100b883a 	mov	r5,r2
  126b74:	01269380 	call	126938 <alt_ic_irq_enable>
  126b78:	00000406 	br	126b8c <alt_iic_isr_register+0xc4>
  126b7c:	e0bff817 	ldw	r2,-32(fp)
  126b80:	e13ffc17 	ldw	r4,-16(fp)
  126b84:	100b883a 	mov	r5,r2
  126b88:	01269d80 	call	1269d8 <alt_ic_irq_disable>
  126b8c:	e0bff715 	stw	r2,-36(fp)
  126b90:	e0bff917 	ldw	r2,-28(fp)
  126b94:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  126b98:	e0bffb17 	ldw	r2,-20(fp)
  126b9c:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
  126ba0:	e0bff717 	ldw	r2,-36(fp)
}
  126ba4:	e037883a 	mov	sp,fp
  126ba8:	dfc00117 	ldw	ra,4(sp)
  126bac:	df000017 	ldw	fp,0(sp)
  126bb0:	dec00204 	addi	sp,sp,8
  126bb4:	f800283a 	ret

00126bb8 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
  126bb8:	defff904 	addi	sp,sp,-28
  126bbc:	dfc00615 	stw	ra,24(sp)
  126bc0:	df000515 	stw	fp,20(sp)
  126bc4:	df000504 	addi	fp,sp,20
  126bc8:	e13ffc15 	stw	r4,-16(fp)
  126bcc:	e17ffd15 	stw	r5,-12(fp)
  126bd0:	e1bffe15 	stw	r6,-8(fp)
  126bd4:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
  126bd8:	e13ffd17 	ldw	r4,-12(fp)
  126bdc:	e17ffe17 	ldw	r5,-8(fp)
  126be0:	e1bfff17 	ldw	r6,-4(fp)
  126be4:	012407c0 	call	12407c <open>
  126be8:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
  126bec:	e0bffb17 	ldw	r2,-20(fp)
  126bf0:	10001c16 	blt	r2,zero,126c64 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
  126bf4:	008004f4 	movhi	r2,19
  126bf8:	10a02a04 	addi	r2,r2,-32600
  126bfc:	e0fffb17 	ldw	r3,-20(fp)
  126c00:	18c00324 	muli	r3,r3,12
  126c04:	10c5883a 	add	r2,r2,r3
  126c08:	10c00017 	ldw	r3,0(r2)
  126c0c:	e0bffc17 	ldw	r2,-16(fp)
  126c10:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
  126c14:	008004f4 	movhi	r2,19
  126c18:	10a02a04 	addi	r2,r2,-32600
  126c1c:	e0fffb17 	ldw	r3,-20(fp)
  126c20:	18c00324 	muli	r3,r3,12
  126c24:	10c5883a 	add	r2,r2,r3
  126c28:	10800104 	addi	r2,r2,4
  126c2c:	10c00017 	ldw	r3,0(r2)
  126c30:	e0bffc17 	ldw	r2,-16(fp)
  126c34:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
  126c38:	008004f4 	movhi	r2,19
  126c3c:	10a02a04 	addi	r2,r2,-32600
  126c40:	e0fffb17 	ldw	r3,-20(fp)
  126c44:	18c00324 	muli	r3,r3,12
  126c48:	10c5883a 	add	r2,r2,r3
  126c4c:	10800204 	addi	r2,r2,8
  126c50:	10c00017 	ldw	r3,0(r2)
  126c54:	e0bffc17 	ldw	r2,-16(fp)
  126c58:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
  126c5c:	e13ffb17 	ldw	r4,-20(fp)
  126c60:	012458c0 	call	12458c <alt_release_fd>
  }
} 
  126c64:	e037883a 	mov	sp,fp
  126c68:	dfc00117 	ldw	ra,4(sp)
  126c6c:	df000017 	ldw	fp,0(sp)
  126c70:	dec00204 	addi	sp,sp,8
  126c74:	f800283a 	ret

00126c78 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
  126c78:	defffb04 	addi	sp,sp,-20
  126c7c:	dfc00415 	stw	ra,16(sp)
  126c80:	df000315 	stw	fp,12(sp)
  126c84:	df000304 	addi	fp,sp,12
  126c88:	e13ffd15 	stw	r4,-12(fp)
  126c8c:	e17ffe15 	stw	r5,-8(fp)
  126c90:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
  126c94:	010004f4 	movhi	r4,19
  126c98:	21202d04 	addi	r4,r4,-32588
  126c9c:	e17ffd17 	ldw	r5,-12(fp)
  126ca0:	01800044 	movi	r6,1
  126ca4:	01c07fc4 	movi	r7,511
  126ca8:	0126bb80 	call	126bb8 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
  126cac:	010004f4 	movhi	r4,19
  126cb0:	21202a04 	addi	r4,r4,-32600
  126cb4:	e17ffe17 	ldw	r5,-8(fp)
  126cb8:	000d883a 	mov	r6,zero
  126cbc:	01c07fc4 	movi	r7,511
  126cc0:	0126bb80 	call	126bb8 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
  126cc4:	010004f4 	movhi	r4,19
  126cc8:	21203004 	addi	r4,r4,-32576
  126ccc:	e17fff17 	ldw	r5,-4(fp)
  126cd0:	01800044 	movi	r6,1
  126cd4:	01c07fc4 	movi	r7,511
  126cd8:	0126bb80 	call	126bb8 <alt_open_fd>
}  
  126cdc:	e037883a 	mov	sp,fp
  126ce0:	dfc00117 	ldw	ra,4(sp)
  126ce4:	df000017 	ldw	fp,0(sp)
  126ce8:	dec00204 	addi	sp,sp,8
  126cec:	f800283a 	ret

00126cf0 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
  126cf0:	defffa04 	addi	sp,sp,-24
  126cf4:	df000515 	stw	fp,20(sp)
  126cf8:	df000504 	addi	fp,sp,20
  126cfc:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  126d00:	0005303a 	rdctl	r2,status
  126d04:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  126d08:	e0fffc17 	ldw	r3,-16(fp)
  126d0c:	00bfff84 	movi	r2,-2
  126d10:	1884703a 	and	r2,r3,r2
  126d14:	1001703a 	wrctl	status,r2
  
  return context;
  126d18:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
  126d1c:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
  126d20:	e0bfff17 	ldw	r2,-4(fp)
  126d24:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
  126d28:	e0bffd17 	ldw	r2,-12(fp)
  126d2c:	10800017 	ldw	r2,0(r2)
  126d30:	e0fffd17 	ldw	r3,-12(fp)
  126d34:	18c00117 	ldw	r3,4(r3)
  126d38:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
  126d3c:	e0bffd17 	ldw	r2,-12(fp)
  126d40:	10800117 	ldw	r2,4(r2)
  126d44:	e0fffd17 	ldw	r3,-12(fp)
  126d48:	18c00017 	ldw	r3,0(r3)
  126d4c:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
  126d50:	e0bffd17 	ldw	r2,-12(fp)
  126d54:	e0fffd17 	ldw	r3,-12(fp)
  126d58:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
  126d5c:	e0bffd17 	ldw	r2,-12(fp)
  126d60:	e0fffd17 	ldw	r3,-12(fp)
  126d64:	10c00015 	stw	r3,0(r2)
  126d68:	e0bffb17 	ldw	r2,-20(fp)
  126d6c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  126d70:	e0bffe17 	ldw	r2,-8(fp)
  126d74:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
  126d78:	e037883a 	mov	sp,fp
  126d7c:	df000017 	ldw	fp,0(sp)
  126d80:	dec00104 	addi	sp,sp,4
  126d84:	f800283a 	ret

00126d88 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
  126d88:	defffb04 	addi	sp,sp,-20
  126d8c:	dfc00415 	stw	ra,16(sp)
  126d90:	df000315 	stw	fp,12(sp)
  126d94:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
  126d98:	d0a00e17 	ldw	r2,-32712(gp)
  126d9c:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
  126da0:	d0a6fd17 	ldw	r2,-25612(gp)
  126da4:	10800044 	addi	r2,r2,1
  126da8:	d0a6fd15 	stw	r2,-25612(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  126dac:	00002e06 	br	126e68 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
  126db0:	e0bffd17 	ldw	r2,-12(fp)
  126db4:	10800017 	ldw	r2,0(r2)
  126db8:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
  126dbc:	e0bffd17 	ldw	r2,-12(fp)
  126dc0:	10800403 	ldbu	r2,16(r2)
  126dc4:	10803fcc 	andi	r2,r2,255
  126dc8:	10000426 	beq	r2,zero,126ddc <alt_tick+0x54>
  126dcc:	d0a6fd17 	ldw	r2,-25612(gp)
  126dd0:	1000021e 	bne	r2,zero,126ddc <alt_tick+0x54>
    {
      alarm->rollover = 0;
  126dd4:	e0bffd17 	ldw	r2,-12(fp)
  126dd8:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
  126ddc:	e0bffd17 	ldw	r2,-12(fp)
  126de0:	10800217 	ldw	r2,8(r2)
  126de4:	d0e6fd17 	ldw	r3,-25612(gp)
  126de8:	18801d36 	bltu	r3,r2,126e60 <alt_tick+0xd8>
  126dec:	e0bffd17 	ldw	r2,-12(fp)
  126df0:	10800403 	ldbu	r2,16(r2)
  126df4:	10803fcc 	andi	r2,r2,255
  126df8:	1000191e 	bne	r2,zero,126e60 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
  126dfc:	e0bffd17 	ldw	r2,-12(fp)
  126e00:	10800317 	ldw	r2,12(r2)
  126e04:	e0fffd17 	ldw	r3,-12(fp)
  126e08:	18c00517 	ldw	r3,20(r3)
  126e0c:	1809883a 	mov	r4,r3
  126e10:	103ee83a 	callr	r2
  126e14:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
  126e18:	e0bfff17 	ldw	r2,-4(fp)
  126e1c:	1000031e 	bne	r2,zero,126e2c <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
  126e20:	e13ffd17 	ldw	r4,-12(fp)
  126e24:	0126cf00 	call	126cf0 <alt_alarm_stop>
  126e28:	00000d06 	br	126e60 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
  126e2c:	e0bffd17 	ldw	r2,-12(fp)
  126e30:	10c00217 	ldw	r3,8(r2)
  126e34:	e0bfff17 	ldw	r2,-4(fp)
  126e38:	1887883a 	add	r3,r3,r2
  126e3c:	e0bffd17 	ldw	r2,-12(fp)
  126e40:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
  126e44:	e0bffd17 	ldw	r2,-12(fp)
  126e48:	10c00217 	ldw	r3,8(r2)
  126e4c:	d0a6fd17 	ldw	r2,-25612(gp)
  126e50:	1880032e 	bgeu	r3,r2,126e60 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
  126e54:	e0bffd17 	ldw	r2,-12(fp)
  126e58:	00c00044 	movi	r3,1
  126e5c:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
  126e60:	e0bffe17 	ldw	r2,-8(fp)
  126e64:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  126e68:	e0fffd17 	ldw	r3,-12(fp)
  126e6c:	d0a00e04 	addi	r2,gp,-32712
  126e70:	18bfcf1e 	bne	r3,r2,126db0 <__alt_data_end+0xffff3530>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
  126e74:	0001883a 	nop
}
  126e78:	e037883a 	mov	sp,fp
  126e7c:	dfc00117 	ldw	ra,4(sp)
  126e80:	df000017 	ldw	fp,0(sp)
  126e84:	dec00204 	addi	sp,sp,8
  126e88:	f800283a 	ret

00126e8c <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
  126e8c:	deffff04 	addi	sp,sp,-4
  126e90:	df000015 	stw	fp,0(sp)
  126e94:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
  126e98:	000170fa 	wrctl	ienable,zero
}
  126e9c:	e037883a 	mov	sp,fp
  126ea0:	df000017 	ldw	fp,0(sp)
  126ea4:	dec00104 	addi	sp,sp,4
  126ea8:	f800283a 	ret

00126eac <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
  126eac:	defffb04 	addi	sp,sp,-20
  126eb0:	df000415 	stw	fp,16(sp)
  126eb4:	df000404 	addi	fp,sp,16
  126eb8:	e13ffe15 	stw	r4,-8(fp)
  126ebc:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
  126ec0:	e0bfff17 	ldw	r2,-4(fp)
  126ec4:	10840070 	cmpltui	r2,r2,4097
  126ec8:	1000021e 	bne	r2,zero,126ed4 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
  126ecc:	00840004 	movi	r2,4096
  126ed0:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
  126ed4:	e0fffe17 	ldw	r3,-8(fp)
  126ed8:	e0bfff17 	ldw	r2,-4(fp)
  126edc:	1885883a 	add	r2,r3,r2
  126ee0:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
  126ee4:	e0bffe17 	ldw	r2,-8(fp)
  126ee8:	e0bffc15 	stw	r2,-16(fp)
  126eec:	00000506 	br	126f04 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
  126ef0:	e0bffc17 	ldw	r2,-16(fp)
  126ef4:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
  126ef8:	e0bffc17 	ldw	r2,-16(fp)
  126efc:	10800804 	addi	r2,r2,32
  126f00:	e0bffc15 	stw	r2,-16(fp)
  126f04:	e0fffc17 	ldw	r3,-16(fp)
  126f08:	e0bffd17 	ldw	r2,-12(fp)
  126f0c:	18bff836 	bltu	r3,r2,126ef0 <__alt_data_end+0xffff3670>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
  126f10:	e0bffe17 	ldw	r2,-8(fp)
  126f14:	108007cc 	andi	r2,r2,31
  126f18:	10000226 	beq	r2,zero,126f24 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
  126f1c:	e0bffc17 	ldw	r2,-16(fp)
  126f20:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
  126f24:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
  126f28:	e037883a 	mov	sp,fp
  126f2c:	df000017 	ldw	fp,0(sp)
  126f30:	dec00104 	addi	sp,sp,4
  126f34:	f800283a 	ret

00126f38 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
  126f38:	defffe04 	addi	sp,sp,-8
  126f3c:	df000115 	stw	fp,4(sp)
  126f40:	df000104 	addi	fp,sp,4
  126f44:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
  126f48:	e0bfff17 	ldw	r2,-4(fp)
  126f4c:	10bffe84 	addi	r2,r2,-6
  126f50:	10c00428 	cmpgeui	r3,r2,16
  126f54:	18001a1e 	bne	r3,zero,126fc0 <alt_exception_cause_generated_bad_addr+0x88>
  126f58:	100690ba 	slli	r3,r2,2
  126f5c:	008004b4 	movhi	r2,18
  126f60:	109bdc04 	addi	r2,r2,28528
  126f64:	1885883a 	add	r2,r3,r2
  126f68:	10800017 	ldw	r2,0(r2)
  126f6c:	1000683a 	jmp	r2
  126f70:	00126fb0 	cmpltui	zero,zero,18878
  126f74:	00126fb0 	cmpltui	zero,zero,18878
  126f78:	00126fc0 	call	126fc <__reset-0x10d904>
  126f7c:	00126fc0 	call	126fc <__reset-0x10d904>
  126f80:	00126fc0 	call	126fc <__reset-0x10d904>
  126f84:	00126fb0 	cmpltui	zero,zero,18878
  126f88:	00126fb8 	rdprs	zero,zero,18878
  126f8c:	00126fc0 	call	126fc <__reset-0x10d904>
  126f90:	00126fb0 	cmpltui	zero,zero,18878
  126f94:	00126fb0 	cmpltui	zero,zero,18878
  126f98:	00126fc0 	call	126fc <__reset-0x10d904>
  126f9c:	00126fb0 	cmpltui	zero,zero,18878
  126fa0:	00126fb8 	rdprs	zero,zero,18878
  126fa4:	00126fc0 	call	126fc <__reset-0x10d904>
  126fa8:	00126fc0 	call	126fc <__reset-0x10d904>
  126fac:	00126fb0 	cmpltui	zero,zero,18878
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
  126fb0:	00800044 	movi	r2,1
  126fb4:	00000306 	br	126fc4 <alt_exception_cause_generated_bad_addr+0x8c>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
  126fb8:	0005883a 	mov	r2,zero
  126fbc:	00000106 	br	126fc4 <alt_exception_cause_generated_bad_addr+0x8c>

  default:
    return 0;
  126fc0:	0005883a 	mov	r2,zero
  }
}
  126fc4:	e037883a 	mov	sp,fp
  126fc8:	df000017 	ldw	fp,0(sp)
  126fcc:	dec00104 	addi	sp,sp,4
  126fd0:	f800283a 	ret

00126fd4 <atexit>:
  126fd4:	200b883a 	mov	r5,r4
  126fd8:	000d883a 	mov	r6,zero
  126fdc:	0009883a 	mov	r4,zero
  126fe0:	000f883a 	mov	r7,zero
  126fe4:	01274181 	jmpi	127418 <__register_exitproc>

00126fe8 <exit>:
  126fe8:	defffe04 	addi	sp,sp,-8
  126fec:	000b883a 	mov	r5,zero
  126ff0:	dc000015 	stw	r16,0(sp)
  126ff4:	dfc00115 	stw	ra,4(sp)
  126ff8:	2021883a 	mov	r16,r4
  126ffc:	012752c0 	call	12752c <__call_exitprocs>
  127000:	008004f4 	movhi	r2,19
  127004:	10a4e904 	addi	r2,r2,-27740
  127008:	11000017 	ldw	r4,0(r2)
  12700c:	20800f17 	ldw	r2,60(r4)
  127010:	10000126 	beq	r2,zero,127018 <exit+0x30>
  127014:	103ee83a 	callr	r2
  127018:	8009883a 	mov	r4,r16
  12701c:	01276c00 	call	1276c0 <_exit>

00127020 <memcmp>:
  127020:	01c000c4 	movi	r7,3
  127024:	3980192e 	bgeu	r7,r6,12708c <memcmp+0x6c>
  127028:	2144b03a 	or	r2,r4,r5
  12702c:	11c4703a 	and	r2,r2,r7
  127030:	10000f26 	beq	r2,zero,127070 <memcmp+0x50>
  127034:	20800003 	ldbu	r2,0(r4)
  127038:	28c00003 	ldbu	r3,0(r5)
  12703c:	10c0151e 	bne	r2,r3,127094 <memcmp+0x74>
  127040:	31bfff84 	addi	r6,r6,-2
  127044:	01ffffc4 	movi	r7,-1
  127048:	00000406 	br	12705c <memcmp+0x3c>
  12704c:	20800003 	ldbu	r2,0(r4)
  127050:	28c00003 	ldbu	r3,0(r5)
  127054:	31bfffc4 	addi	r6,r6,-1
  127058:	10c00e1e 	bne	r2,r3,127094 <memcmp+0x74>
  12705c:	21000044 	addi	r4,r4,1
  127060:	29400044 	addi	r5,r5,1
  127064:	31fff91e 	bne	r6,r7,12704c <__alt_data_end+0xffff37cc>
  127068:	0005883a 	mov	r2,zero
  12706c:	f800283a 	ret
  127070:	20c00017 	ldw	r3,0(r4)
  127074:	28800017 	ldw	r2,0(r5)
  127078:	1880041e 	bne	r3,r2,12708c <memcmp+0x6c>
  12707c:	31bfff04 	addi	r6,r6,-4
  127080:	21000104 	addi	r4,r4,4
  127084:	29400104 	addi	r5,r5,4
  127088:	39bff936 	bltu	r7,r6,127070 <__alt_data_end+0xffff37f0>
  12708c:	303fe91e 	bne	r6,zero,127034 <__alt_data_end+0xffff37b4>
  127090:	003ff506 	br	127068 <__alt_data_end+0xffff37e8>
  127094:	10c5c83a 	sub	r2,r2,r3
  127098:	f800283a 	ret

0012709c <_putc_r>:
  12709c:	defffc04 	addi	sp,sp,-16
  1270a0:	dc000215 	stw	r16,8(sp)
  1270a4:	dfc00315 	stw	ra,12(sp)
  1270a8:	2021883a 	mov	r16,r4
  1270ac:	20000226 	beq	r4,zero,1270b8 <_putc_r+0x1c>
  1270b0:	20800e17 	ldw	r2,56(r4)
  1270b4:	10001b26 	beq	r2,zero,127124 <_putc_r+0x88>
  1270b8:	30800217 	ldw	r2,8(r6)
  1270bc:	10bfffc4 	addi	r2,r2,-1
  1270c0:	30800215 	stw	r2,8(r6)
  1270c4:	10000a16 	blt	r2,zero,1270f0 <_putc_r+0x54>
  1270c8:	30800017 	ldw	r2,0(r6)
  1270cc:	11400005 	stb	r5,0(r2)
  1270d0:	30800017 	ldw	r2,0(r6)
  1270d4:	10c00044 	addi	r3,r2,1
  1270d8:	30c00015 	stw	r3,0(r6)
  1270dc:	10800003 	ldbu	r2,0(r2)
  1270e0:	dfc00317 	ldw	ra,12(sp)
  1270e4:	dc000217 	ldw	r16,8(sp)
  1270e8:	dec00404 	addi	sp,sp,16
  1270ec:	f800283a 	ret
  1270f0:	30c00617 	ldw	r3,24(r6)
  1270f4:	10c00616 	blt	r2,r3,127110 <_putc_r+0x74>
  1270f8:	30800017 	ldw	r2,0(r6)
  1270fc:	00c00284 	movi	r3,10
  127100:	11400005 	stb	r5,0(r2)
  127104:	30800017 	ldw	r2,0(r6)
  127108:	11400003 	ldbu	r5,0(r2)
  12710c:	28fff11e 	bne	r5,r3,1270d4 <__alt_data_end+0xffff3854>
  127110:	8009883a 	mov	r4,r16
  127114:	dfc00317 	ldw	ra,12(sp)
  127118:	dc000217 	ldw	r16,8(sp)
  12711c:	dec00404 	addi	sp,sp,16
  127120:	01272a81 	jmpi	1272a8 <__swbuf_r>
  127124:	d9400015 	stw	r5,0(sp)
  127128:	d9800115 	stw	r6,4(sp)
  12712c:	0120cd40 	call	120cd4 <__sinit>
  127130:	d9800117 	ldw	r6,4(sp)
  127134:	d9400017 	ldw	r5,0(sp)
  127138:	003fdf06 	br	1270b8 <__alt_data_end+0xffff3838>

0012713c <putc>:
  12713c:	defffc04 	addi	sp,sp,-16
  127140:	dc400115 	stw	r17,4(sp)
  127144:	044004f4 	movhi	r17,19
  127148:	8c64ea04 	addi	r17,r17,-27736
  12714c:	dc800215 	stw	r18,8(sp)
  127150:	2025883a 	mov	r18,r4
  127154:	89000017 	ldw	r4,0(r17)
  127158:	dc000015 	stw	r16,0(sp)
  12715c:	dfc00315 	stw	ra,12(sp)
  127160:	2821883a 	mov	r16,r5
  127164:	20000226 	beq	r4,zero,127170 <putc+0x34>
  127168:	20c00e17 	ldw	r3,56(r4)
  12716c:	18001a26 	beq	r3,zero,1271d8 <putc+0x9c>
  127170:	80800217 	ldw	r2,8(r16)
  127174:	10bfffc4 	addi	r2,r2,-1
  127178:	80800215 	stw	r2,8(r16)
  12717c:	10000c16 	blt	r2,zero,1271b0 <putc+0x74>
  127180:	80800017 	ldw	r2,0(r16)
  127184:	14800005 	stb	r18,0(r2)
  127188:	80800017 	ldw	r2,0(r16)
  12718c:	10c00044 	addi	r3,r2,1
  127190:	80c00015 	stw	r3,0(r16)
  127194:	10800003 	ldbu	r2,0(r2)
  127198:	dfc00317 	ldw	ra,12(sp)
  12719c:	dc800217 	ldw	r18,8(sp)
  1271a0:	dc400117 	ldw	r17,4(sp)
  1271a4:	dc000017 	ldw	r16,0(sp)
  1271a8:	dec00404 	addi	sp,sp,16
  1271ac:	f800283a 	ret
  1271b0:	80c00617 	ldw	r3,24(r16)
  1271b4:	10c00a16 	blt	r2,r3,1271e0 <putc+0xa4>
  1271b8:	80800017 	ldw	r2,0(r16)
  1271bc:	00c00284 	movi	r3,10
  1271c0:	14800005 	stb	r18,0(r2)
  1271c4:	80800017 	ldw	r2,0(r16)
  1271c8:	11400003 	ldbu	r5,0(r2)
  1271cc:	28ffef1e 	bne	r5,r3,12718c <__alt_data_end+0xffff390c>
  1271d0:	89000017 	ldw	r4,0(r17)
  1271d4:	00000406 	br	1271e8 <putc+0xac>
  1271d8:	0120cd40 	call	120cd4 <__sinit>
  1271dc:	003fe406 	br	127170 <__alt_data_end+0xffff38f0>
  1271e0:	89000017 	ldw	r4,0(r17)
  1271e4:	900b883a 	mov	r5,r18
  1271e8:	800d883a 	mov	r6,r16
  1271ec:	dfc00317 	ldw	ra,12(sp)
  1271f0:	dc800217 	ldw	r18,8(sp)
  1271f4:	dc400117 	ldw	r17,4(sp)
  1271f8:	dc000017 	ldw	r16,0(sp)
  1271fc:	dec00404 	addi	sp,sp,16
  127200:	01272a81 	jmpi	1272a8 <__swbuf_r>

00127204 <strcmp>:
  127204:	2144b03a 	or	r2,r4,r5
  127208:	108000cc 	andi	r2,r2,3
  12720c:	1000171e 	bne	r2,zero,12726c <strcmp+0x68>
  127210:	20800017 	ldw	r2,0(r4)
  127214:	28c00017 	ldw	r3,0(r5)
  127218:	10c0141e 	bne	r2,r3,12726c <strcmp+0x68>
  12721c:	027fbff4 	movhi	r9,65279
  127220:	4a7fbfc4 	addi	r9,r9,-257
  127224:	0086303a 	nor	r3,zero,r2
  127228:	02202074 	movhi	r8,32897
  12722c:	1245883a 	add	r2,r2,r9
  127230:	42202004 	addi	r8,r8,-32640
  127234:	10c4703a 	and	r2,r2,r3
  127238:	1204703a 	and	r2,r2,r8
  12723c:	10000226 	beq	r2,zero,127248 <strcmp+0x44>
  127240:	00001706 	br	1272a0 <strcmp+0x9c>
  127244:	1000161e 	bne	r2,zero,1272a0 <strcmp+0x9c>
  127248:	21000104 	addi	r4,r4,4
  12724c:	20c00017 	ldw	r3,0(r4)
  127250:	29400104 	addi	r5,r5,4
  127254:	29800017 	ldw	r6,0(r5)
  127258:	1a4f883a 	add	r7,r3,r9
  12725c:	00c4303a 	nor	r2,zero,r3
  127260:	3884703a 	and	r2,r7,r2
  127264:	1204703a 	and	r2,r2,r8
  127268:	19bff626 	beq	r3,r6,127244 <__alt_data_end+0xffff39c4>
  12726c:	20800007 	ldb	r2,0(r4)
  127270:	1000051e 	bne	r2,zero,127288 <strcmp+0x84>
  127274:	00000606 	br	127290 <strcmp+0x8c>
  127278:	21000044 	addi	r4,r4,1
  12727c:	20800007 	ldb	r2,0(r4)
  127280:	29400044 	addi	r5,r5,1
  127284:	10000226 	beq	r2,zero,127290 <strcmp+0x8c>
  127288:	28c00007 	ldb	r3,0(r5)
  12728c:	10fffa26 	beq	r2,r3,127278 <__alt_data_end+0xffff39f8>
  127290:	20800003 	ldbu	r2,0(r4)
  127294:	28c00003 	ldbu	r3,0(r5)
  127298:	10c5c83a 	sub	r2,r2,r3
  12729c:	f800283a 	ret
  1272a0:	0005883a 	mov	r2,zero
  1272a4:	f800283a 	ret

001272a8 <__swbuf_r>:
  1272a8:	defffc04 	addi	sp,sp,-16
  1272ac:	dc800215 	stw	r18,8(sp)
  1272b0:	dc400115 	stw	r17,4(sp)
  1272b4:	dc000015 	stw	r16,0(sp)
  1272b8:	dfc00315 	stw	ra,12(sp)
  1272bc:	2025883a 	mov	r18,r4
  1272c0:	2823883a 	mov	r17,r5
  1272c4:	3021883a 	mov	r16,r6
  1272c8:	20000226 	beq	r4,zero,1272d4 <__swbuf_r+0x2c>
  1272cc:	20800e17 	ldw	r2,56(r4)
  1272d0:	10004126 	beq	r2,zero,1273d8 <__swbuf_r+0x130>
  1272d4:	80c00617 	ldw	r3,24(r16)
  1272d8:	8180030b 	ldhu	r6,12(r16)
  1272dc:	80c00215 	stw	r3,8(r16)
  1272e0:	30c0020c 	andi	r3,r6,8
  1272e4:	18003526 	beq	r3,zero,1273bc <__swbuf_r+0x114>
  1272e8:	80c00417 	ldw	r3,16(r16)
  1272ec:	18003326 	beq	r3,zero,1273bc <__swbuf_r+0x114>
  1272f0:	3088000c 	andi	r2,r6,8192
  1272f4:	8c403fcc 	andi	r17,r17,255
  1272f8:	10001726 	beq	r2,zero,127358 <__swbuf_r+0xb0>
  1272fc:	80800017 	ldw	r2,0(r16)
  127300:	81000517 	ldw	r4,20(r16)
  127304:	10c7c83a 	sub	r3,r2,r3
  127308:	19001d0e 	bge	r3,r4,127380 <__swbuf_r+0xd8>
  12730c:	18c00044 	addi	r3,r3,1
  127310:	81400217 	ldw	r5,8(r16)
  127314:	11000044 	addi	r4,r2,1
  127318:	81000015 	stw	r4,0(r16)
  12731c:	297fffc4 	addi	r5,r5,-1
  127320:	81400215 	stw	r5,8(r16)
  127324:	14400005 	stb	r17,0(r2)
  127328:	80800517 	ldw	r2,20(r16)
  12732c:	10c01d26 	beq	r2,r3,1273a4 <__swbuf_r+0xfc>
  127330:	8080030b 	ldhu	r2,12(r16)
  127334:	1080004c 	andi	r2,r2,1
  127338:	1000181e 	bne	r2,zero,12739c <__swbuf_r+0xf4>
  12733c:	8805883a 	mov	r2,r17
  127340:	dfc00317 	ldw	ra,12(sp)
  127344:	dc800217 	ldw	r18,8(sp)
  127348:	dc400117 	ldw	r17,4(sp)
  12734c:	dc000017 	ldw	r16,0(sp)
  127350:	dec00404 	addi	sp,sp,16
  127354:	f800283a 	ret
  127358:	81001917 	ldw	r4,100(r16)
  12735c:	00b7ffc4 	movi	r2,-8193
  127360:	31880014 	ori	r6,r6,8192
  127364:	2084703a 	and	r2,r4,r2
  127368:	80801915 	stw	r2,100(r16)
  12736c:	80800017 	ldw	r2,0(r16)
  127370:	81000517 	ldw	r4,20(r16)
  127374:	8180030d 	sth	r6,12(r16)
  127378:	10c7c83a 	sub	r3,r2,r3
  12737c:	193fe316 	blt	r3,r4,12730c <__alt_data_end+0xffff3a8c>
  127380:	9009883a 	mov	r4,r18
  127384:	800b883a 	mov	r5,r16
  127388:	012072c0 	call	12072c <_fflush_r>
  12738c:	1000091e 	bne	r2,zero,1273b4 <__swbuf_r+0x10c>
  127390:	80800017 	ldw	r2,0(r16)
  127394:	00c00044 	movi	r3,1
  127398:	003fdd06 	br	127310 <__alt_data_end+0xffff3a90>
  12739c:	00800284 	movi	r2,10
  1273a0:	88bfe61e 	bne	r17,r2,12733c <__alt_data_end+0xffff3abc>
  1273a4:	9009883a 	mov	r4,r18
  1273a8:	800b883a 	mov	r5,r16
  1273ac:	012072c0 	call	12072c <_fflush_r>
  1273b0:	103fe226 	beq	r2,zero,12733c <__alt_data_end+0xffff3abc>
  1273b4:	00bfffc4 	movi	r2,-1
  1273b8:	003fe106 	br	127340 <__alt_data_end+0xffff3ac0>
  1273bc:	9009883a 	mov	r4,r18
  1273c0:	800b883a 	mov	r5,r16
  1273c4:	01238300 	call	123830 <__swsetup_r>
  1273c8:	1000051e 	bne	r2,zero,1273e0 <__swbuf_r+0x138>
  1273cc:	8180030b 	ldhu	r6,12(r16)
  1273d0:	80c00417 	ldw	r3,16(r16)
  1273d4:	003fc606 	br	1272f0 <__alt_data_end+0xffff3a70>
  1273d8:	0120cd40 	call	120cd4 <__sinit>
  1273dc:	003fbd06 	br	1272d4 <__alt_data_end+0xffff3a54>
  1273e0:	80c0030b 	ldhu	r3,12(r16)
  1273e4:	00bfffc4 	movi	r2,-1
  1273e8:	18c01014 	ori	r3,r3,64
  1273ec:	80c0030d 	sth	r3,12(r16)
  1273f0:	00c00244 	movi	r3,9
  1273f4:	90c00015 	stw	r3,0(r18)
  1273f8:	003fd106 	br	127340 <__alt_data_end+0xffff3ac0>

001273fc <__swbuf>:
  1273fc:	00c004f4 	movhi	r3,19
  127400:	18e4ea04 	addi	r3,r3,-27736
  127404:	2005883a 	mov	r2,r4
  127408:	19000017 	ldw	r4,0(r3)
  12740c:	280d883a 	mov	r6,r5
  127410:	100b883a 	mov	r5,r2
  127414:	01272a81 	jmpi	1272a8 <__swbuf_r>

00127418 <__register_exitproc>:
  127418:	008004f4 	movhi	r2,19
  12741c:	defffa04 	addi	sp,sp,-24
  127420:	10a4e904 	addi	r2,r2,-27740
  127424:	dc000315 	stw	r16,12(sp)
  127428:	14000017 	ldw	r16,0(r2)
  12742c:	dc400415 	stw	r17,16(sp)
  127430:	dfc00515 	stw	ra,20(sp)
  127434:	80805217 	ldw	r2,328(r16)
  127438:	2023883a 	mov	r17,r4
  12743c:	10003626 	beq	r2,zero,127518 <__register_exitproc+0x100>
  127440:	10c00117 	ldw	r3,4(r2)
  127444:	010007c4 	movi	r4,31
  127448:	20c00e16 	blt	r4,r3,127484 <__register_exitproc+0x6c>
  12744c:	1a400044 	addi	r9,r3,1
  127450:	8800211e 	bne	r17,zero,1274d8 <__register_exitproc+0xc0>
  127454:	18c00084 	addi	r3,r3,2
  127458:	18c7883a 	add	r3,r3,r3
  12745c:	18c7883a 	add	r3,r3,r3
  127460:	12400115 	stw	r9,4(r2)
  127464:	10c7883a 	add	r3,r2,r3
  127468:	19400015 	stw	r5,0(r3)
  12746c:	0005883a 	mov	r2,zero
  127470:	dfc00517 	ldw	ra,20(sp)
  127474:	dc400417 	ldw	r17,16(sp)
  127478:	dc000317 	ldw	r16,12(sp)
  12747c:	dec00604 	addi	sp,sp,24
  127480:	f800283a 	ret
  127484:	00800034 	movhi	r2,0
  127488:	10800004 	addi	r2,r2,0
  12748c:	10002526 	beq	r2,zero,127524 <__register_exitproc+0x10c>
  127490:	01006404 	movi	r4,400
  127494:	d9400015 	stw	r5,0(sp)
  127498:	d9800115 	stw	r6,4(sp)
  12749c:	d9c00215 	stw	r7,8(sp)
  1274a0:	00000000 	call	0 <__reset-0x120000>
  1274a4:	d9400017 	ldw	r5,0(sp)
  1274a8:	d9800117 	ldw	r6,4(sp)
  1274ac:	d9c00217 	ldw	r7,8(sp)
  1274b0:	10001c26 	beq	r2,zero,127524 <__register_exitproc+0x10c>
  1274b4:	80c05217 	ldw	r3,328(r16)
  1274b8:	10000115 	stw	zero,4(r2)
  1274bc:	02400044 	movi	r9,1
  1274c0:	10c00015 	stw	r3,0(r2)
  1274c4:	80805215 	stw	r2,328(r16)
  1274c8:	10006215 	stw	zero,392(r2)
  1274cc:	10006315 	stw	zero,396(r2)
  1274d0:	0007883a 	mov	r3,zero
  1274d4:	883fdf26 	beq	r17,zero,127454 <__alt_data_end+0xffff3bd4>
  1274d8:	18d1883a 	add	r8,r3,r3
  1274dc:	4211883a 	add	r8,r8,r8
  1274e0:	1211883a 	add	r8,r2,r8
  1274e4:	41802215 	stw	r6,136(r8)
  1274e8:	01000044 	movi	r4,1
  1274ec:	11806217 	ldw	r6,392(r2)
  1274f0:	20c8983a 	sll	r4,r4,r3
  1274f4:	310cb03a 	or	r6,r6,r4
  1274f8:	11806215 	stw	r6,392(r2)
  1274fc:	41c04215 	stw	r7,264(r8)
  127500:	01800084 	movi	r6,2
  127504:	89bfd31e 	bne	r17,r6,127454 <__alt_data_end+0xffff3bd4>
  127508:	11806317 	ldw	r6,396(r2)
  12750c:	3108b03a 	or	r4,r6,r4
  127510:	11006315 	stw	r4,396(r2)
  127514:	003fcf06 	br	127454 <__alt_data_end+0xffff3bd4>
  127518:	80805304 	addi	r2,r16,332
  12751c:	80805215 	stw	r2,328(r16)
  127520:	003fc706 	br	127440 <__alt_data_end+0xffff3bc0>
  127524:	00bfffc4 	movi	r2,-1
  127528:	003fd106 	br	127470 <__alt_data_end+0xffff3bf0>

0012752c <__call_exitprocs>:
  12752c:	008004f4 	movhi	r2,19
  127530:	10a4e904 	addi	r2,r2,-27740
  127534:	10800017 	ldw	r2,0(r2)
  127538:	defff404 	addi	sp,sp,-48
  12753c:	dd800815 	stw	r22,32(sp)
  127540:	d8800015 	stw	r2,0(sp)
  127544:	10805204 	addi	r2,r2,328
  127548:	dd000615 	stw	r20,24(sp)
  12754c:	dc800415 	stw	r18,16(sp)
  127550:	dfc00b15 	stw	ra,44(sp)
  127554:	df000a15 	stw	fp,40(sp)
  127558:	ddc00915 	stw	r23,36(sp)
  12755c:	dd400715 	stw	r21,28(sp)
  127560:	dcc00515 	stw	r19,20(sp)
  127564:	dc400315 	stw	r17,12(sp)
  127568:	dc000215 	stw	r16,8(sp)
  12756c:	2025883a 	mov	r18,r4
  127570:	2829883a 	mov	r20,r5
  127574:	d8800115 	stw	r2,4(sp)
  127578:	05bfffc4 	movi	r22,-1
  12757c:	d8800017 	ldw	r2,0(sp)
  127580:	14c05217 	ldw	r19,328(r2)
  127584:	98001d26 	beq	r19,zero,1275fc <__call_exitprocs+0xd0>
  127588:	dd400117 	ldw	r21,4(sp)
  12758c:	98800117 	ldw	r2,4(r19)
  127590:	173fffc4 	addi	fp,r2,-1
  127594:	e0000d16 	blt	fp,zero,1275cc <__call_exitprocs+0xa0>
  127598:	14000044 	addi	r16,r2,1
  12759c:	8421883a 	add	r16,r16,r16
  1275a0:	8421883a 	add	r16,r16,r16
  1275a4:	84402004 	addi	r17,r16,128
  1275a8:	9c63883a 	add	r17,r19,r17
  1275ac:	9c21883a 	add	r16,r19,r16
  1275b0:	a0001e26 	beq	r20,zero,12762c <__call_exitprocs+0x100>
  1275b4:	80804017 	ldw	r2,256(r16)
  1275b8:	15001c26 	beq	r2,r20,12762c <__call_exitprocs+0x100>
  1275bc:	e73fffc4 	addi	fp,fp,-1
  1275c0:	843fff04 	addi	r16,r16,-4
  1275c4:	8c7fff04 	addi	r17,r17,-4
  1275c8:	e5bff91e 	bne	fp,r22,1275b0 <__alt_data_end+0xffff3d30>
  1275cc:	00800034 	movhi	r2,0
  1275d0:	10800004 	addi	r2,r2,0
  1275d4:	10000926 	beq	r2,zero,1275fc <__call_exitprocs+0xd0>
  1275d8:	98800117 	ldw	r2,4(r19)
  1275dc:	1000311e 	bne	r2,zero,1276a4 <__call_exitprocs+0x178>
  1275e0:	98800017 	ldw	r2,0(r19)
  1275e4:	10003426 	beq	r2,zero,1276b8 <__call_exitprocs+0x18c>
  1275e8:	9809883a 	mov	r4,r19
  1275ec:	a8800015 	stw	r2,0(r21)
  1275f0:	00000000 	call	0 <__reset-0x120000>
  1275f4:	acc00017 	ldw	r19,0(r21)
  1275f8:	983fe41e 	bne	r19,zero,12758c <__alt_data_end+0xffff3d0c>
  1275fc:	dfc00b17 	ldw	ra,44(sp)
  127600:	df000a17 	ldw	fp,40(sp)
  127604:	ddc00917 	ldw	r23,36(sp)
  127608:	dd800817 	ldw	r22,32(sp)
  12760c:	dd400717 	ldw	r21,28(sp)
  127610:	dd000617 	ldw	r20,24(sp)
  127614:	dcc00517 	ldw	r19,20(sp)
  127618:	dc800417 	ldw	r18,16(sp)
  12761c:	dc400317 	ldw	r17,12(sp)
  127620:	dc000217 	ldw	r16,8(sp)
  127624:	dec00c04 	addi	sp,sp,48
  127628:	f800283a 	ret
  12762c:	98800117 	ldw	r2,4(r19)
  127630:	80c00017 	ldw	r3,0(r16)
  127634:	10bfffc4 	addi	r2,r2,-1
  127638:	17001526 	beq	r2,fp,127690 <__call_exitprocs+0x164>
  12763c:	80000015 	stw	zero,0(r16)
  127640:	183fde26 	beq	r3,zero,1275bc <__alt_data_end+0xffff3d3c>
  127644:	00800044 	movi	r2,1
  127648:	1708983a 	sll	r4,r2,fp
  12764c:	98806217 	ldw	r2,392(r19)
  127650:	9dc00117 	ldw	r23,4(r19)
  127654:	2084703a 	and	r2,r4,r2
  127658:	1000061e 	bne	r2,zero,127674 <__call_exitprocs+0x148>
  12765c:	183ee83a 	callr	r3
  127660:	98800117 	ldw	r2,4(r19)
  127664:	15ffc51e 	bne	r2,r23,12757c <__alt_data_end+0xffff3cfc>
  127668:	a8800017 	ldw	r2,0(r21)
  12766c:	14ffd326 	beq	r2,r19,1275bc <__alt_data_end+0xffff3d3c>
  127670:	003fc206 	br	12757c <__alt_data_end+0xffff3cfc>
  127674:	98806317 	ldw	r2,396(r19)
  127678:	2084703a 	and	r2,r4,r2
  12767c:	1000061e 	bne	r2,zero,127698 <__call_exitprocs+0x16c>
  127680:	89400017 	ldw	r5,0(r17)
  127684:	9009883a 	mov	r4,r18
  127688:	183ee83a 	callr	r3
  12768c:	003ff406 	br	127660 <__alt_data_end+0xffff3de0>
  127690:	9f000115 	stw	fp,4(r19)
  127694:	003fea06 	br	127640 <__alt_data_end+0xffff3dc0>
  127698:	89000017 	ldw	r4,0(r17)
  12769c:	183ee83a 	callr	r3
  1276a0:	003fef06 	br	127660 <__alt_data_end+0xffff3de0>
  1276a4:	98800017 	ldw	r2,0(r19)
  1276a8:	982b883a 	mov	r21,r19
  1276ac:	1027883a 	mov	r19,r2
  1276b0:	983fb61e 	bne	r19,zero,12758c <__alt_data_end+0xffff3d0c>
  1276b4:	003fd106 	br	1275fc <__alt_data_end+0xffff3d7c>
  1276b8:	0005883a 	mov	r2,zero
  1276bc:	003ffa06 	br	1276a8 <__alt_data_end+0xffff3e28>

001276c0 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
  1276c0:	defffd04 	addi	sp,sp,-12
  1276c4:	df000215 	stw	fp,8(sp)
  1276c8:	df000204 	addi	fp,sp,8
  1276cc:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
  1276d0:	0001883a 	nop
  1276d4:	e0bfff17 	ldw	r2,-4(fp)
  1276d8:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
  1276dc:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
  1276e0:	10000226 	beq	r2,zero,1276ec <_exit+0x2c>
    ALT_SIM_FAIL();
  1276e4:	002af070 	cmpltui	zero,zero,43969
  1276e8:	00000106 	br	1276f0 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
  1276ec:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
  1276f0:	003fff06 	br	1276f0 <__alt_data_end+0xffff3e70>


Slave2.elf:     file format elf32-littlenios2
Slave2.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00220240

Program Header:
    LOAD off    0x00001000 vaddr 0x00220000 paddr 0x00220000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00220020 paddr 0x00220020 align 2**12
         filesz 0x00006fdc memsz 0x00006fdc flags r-x
    LOAD off    0x00007ffc vaddr 0x00226ffc paddr 0x00228b8c align 2**12
         filesz 0x00001b90 memsz 0x00001b90 flags rw-
    LOAD off    0x0000a71c vaddr 0x0022a71c paddr 0x0022a71c align 2**12
         filesz 0x00000000 memsz 0x00000154 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00220000  00220000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000220  00220020  00220020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00006c68  00220240  00220240  00001240  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000154  00226ea8  00226ea8  00007ea8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001b90  00226ffc  00228b8c  00007ffc  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000154  0022a71c  0022a71c  0000a71c  2**2
                  ALLOC, SMALL_DATA
  6 .MEMSlave2    00000000  0022a870  0022a870  00009b8c  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  00009b8c  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000ab8  00000000  00000000  00009bb0  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   000199dd  00000000  00000000  0000a668  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00006e66  00000000  00000000  00024045  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   000077cc  00000000  00000000  0002aeab  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00001ab8  00000000  00000000  00032678  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00002aee  00000000  00000000  00034130  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    000047d0  00000000  00000000  00036c1e  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000030  00000000  00000000  0003b3f0  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000328  00000000  00000000  0003b420  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  0003e2a2  2**0
                  CONTENTS, READONLY
 18 .cpu          00000009  00000000  00000000  0003e2a5  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  0003e2ae  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  0003e2af  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   0000000a  00000000  00000000  0003e2b0  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    0000000a  00000000  00000000  0003e2ba  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   0000000a  00000000  00000000  0003e2c4  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 00000008  00000000  00000000  0003e2ce  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 0000002d  00000000  00000000  0003e2d6  2**0
                  CONTENTS, READONLY
 26 .jdi          0000c3ff  00000000  00000000  0003e303  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     000bcd72  00000000  00000000  0004a702  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00220000 l    d  .entry	00000000 .entry
00220020 l    d  .exceptions	00000000 .exceptions
00220240 l    d  .text	00000000 .text
00226ea8 l    d  .rodata	00000000 .rodata
00226ffc l    d  .rwdata	00000000 .rwdata
0022a71c l    d  .bss	00000000 .bss
0022a870 l    d  .MEMSlave2	00000000 .MEMSlave2
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Slave2_bsp//obj/HAL/src/crt0.o
00220288 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 hello_world.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 impure.c
00226ffc l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
002220b0 l     F .text	00000008 __fp_lock
002220b8 l     F .text	00000008 __fp_unlock
002220cc l     F .text	000001a0 __sinit.part.1
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 alt_close.c
00223114 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
00223234 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
00223260 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
00223360 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
00223454 l     F .text	00000064 alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
00223538 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_read.c
00223980 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
00228b74 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_write.c
00223bdc l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
00223d24 l     F .text	00000038 alt_dev_reg
00223d5c l     F .text	00000050 alt_get_errno
00223dac l     F .text	0000006c alt_avalon_mutex_reg
002279d0 l     O .rwdata	00001060 JTAGSlave2
00228a30 l     O .rwdata	00000010 mutex_0
00228a40 l     O .rwdata	000000c4 uart_0
00228b04 l     O .rwdata	00000048 video_character_buffer_with_dma_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0022419c l     F .text	00000204 altera_avalon_jtag_uart_irq
002243a0 l     F .text	000000a8 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_mutex.c
002249c0 l     F .text	00000050 alt_get_errno
00224a10 l     F .text	0000007c alt_mutex_trylock
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
00224e50 l     F .text	00000098 altera_avalon_uart_irq
00224ee8 l     F .text	000000e0 altera_avalon_uart_rxirq
00224fc8 l     F .text	00000144 altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
00225160 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
0022538c l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 altera_up_avalon_video_character_buffer_with_dma.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
002259f4 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
00225f30 l     F .text	000000c0 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
00226068 l     F .text	00000050 alt_get_errno
002260b8 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
0022a744 g     O .bss	00000004 alt_instruction_exception_handler
00223008 g     F .text	00000054 _isatty_r
0022365c g     F .text	00000078 alt_main
00220608 g     F .text	000000b8 _puts_r
0022a770 g     O .bss	00000100 alt_irq
0022305c g     F .text	0000005c _lseek_r
00228b8c g       *ABS*	00000000 __flash_rwdata_start
0022a870 g       *ABS*	00000000 __alt_heap_start
00222d88 g     F .text	0000005c __sseek
00222400 g     F .text	00000010 __sinit
00226a5c g     F .text	00000154 __swbuf_r
00225714 g     F .text	00000100 alt_up_char_buffer_string
0022226c g     F .text	00000064 __sfmoreglue
002236f4 g     F .text	00000020 __malloc_unlock
00225648 g     F .text	000000cc alt_up_char_buffer_draw
002215d8 g     F .text	0000015c memmove
002223e8 g     F .text	00000018 _cleanup
00224b44 g     F .text	00000040 altera_avalon_mutex_trylock
00226478 g     F .text	00000020 altera_nios2_gen2_irq_init
00000000  w      *UND*	00000000 __errno
00220000 g     F .entry	0000001c __reset
00224bd4 g     F .text	00000074 altera_avalon_mutex_is_mine
00220020 g       *ABS*	00000000 __flash_exceptions_start
00222fb0 g     F .text	00000058 _fstat_r
0022a728 g     O .bss	00000004 errno
00222d04 g     F .text	00000008 __seofread
0022a730 g     O .bss	00000004 alt_argv
00230b4c g       *ABS*	00000000 _gp
00227850 g     O .rwdata	00000180 alt_fd_list
002205b0 g     F .text	00000058 delay10ms
00225ba0 g     F .text	00000090 alt_find_dev
002214a0 g     F .text	00000138 memcpy
00225814 g     F .text	0000005c alt_up_char_buffer_clear
002220c0 g     F .text	0000000c _cleanup_r
00225ff0 g     F .text	00000078 alt_io_redirect
00226ea8 g       *ABS*	00000000 __DTOR_END__
002206c0 g     F .text	00000014 puts
002266ec g     F .text	0000009c alt_exception_cause_generated_bad_addr
0022459c g     F .text	0000020c altera_avalon_jtag_uart_read
00000000  w      *UND*	00000000 malloc
002233b0 g     F .text	000000a4 isatty
00226660 g     F .text	0000008c alt_icache_flush
0022a724 g     O .bss	00000004 __malloc_top_pad
0022076c g     F .text	000004a4 __sfvwrite_r
00221cd4 g     F .text	00000054 _sbrk_r
002230b8 g     F .text	0000005c _read_r
00228b6c g     O .rwdata	00000004 alt_max_fd
00222e9c g     F .text	00000100 _fclose_r
00222080 g     F .text	00000030 fflush
0022a720 g     O .bss	00000004 __malloc_max_sbrked_mem
00223588 g     F .text	000000d4 lseek
00224c48 g     F .text	00000050 altera_avalon_mutex_first_lock
00228b4c g     O .rwdata	00000004 _global_impure_ptr
00221734 g     F .text	000005a0 _realloc_r
0022a870 g       *ABS*	00000000 __bss_end
00225e40 g     F .text	000000f0 alt_iic_isr_register
00226374 g     F .text	00000104 alt_tick
00224da8 g     F .text	000000a8 altera_avalon_uart_init
00222420 g     F .text	00000018 __fp_lock_all
00225df4 g     F .text	0000004c alt_ic_irq_enabled
002262dc g     F .text	00000098 alt_alarm_stop
0022a738 g     O .bss	00000004 alt_irq_active
002200fc g     F .exceptions	000000d0 alt_irq_handler
00227828 g     O .rwdata	00000028 alt_dev_null
00224a8c g     F .text	00000054 altera_avalon_mutex_open
002259b0 g     F .text	00000044 alt_dcache_flush_all
00228b8c g       *ABS*	00000000 __ram_rwdata_end
00228b64 g     O .rwdata	00000008 alt_dev_list
00223c2c g     F .text	000000f8 write
00226850 g     F .text	000000a0 _putc_r
00228b78 g     O .rwdata	00000008 alt_mutex_list
00226ffc g       *ABS*	00000000 __ram_rodata_end
002232b0 g     F .text	000000b0 fstat
0022a870 g       *ABS*	00000000 end
00225588 g     F .text	00000080 alt_up_char_buffer_init
002253dc g     F .text	000001ac altera_avalon_uart_write
002240d8 g     F .text	000000c4 altera_avalon_jtag_uart_init
002201cc g     F .exceptions	00000074 alt_instruction_exception_entry
00226ea8 g       *ABS*	00000000 __CTOR_LIST__
00233880 g       *ABS*	00000000 __alt_stack_pointer
00224cf8 g     F .text	00000060 altera_avalon_uart_write_fd
00224d58 g     F .text	00000050 altera_avalon_uart_close_fd
002247a8 g     F .text	00000218 altera_avalon_jtag_uart_write
00222410 g     F .text	00000004 __sfp_lock_acquire
002213b8 g     F .text	000000e8 memchr
00222574 g     F .text	000002f0 _free_r
00223714 g     F .text	00000228 alt_printf
00226ce0 g     F .text	00000194 __call_exitprocs
00228b54 g     O .rwdata	00000004 __malloc_sbrk_base
00220240 g     F .text	0000004c _start
0022a73c g     O .bss	00000004 _alt_tick_rate
0022a740 g     O .bss	00000004 _alt_nticks
002239d0 g     F .text	000000fc read
00223e4c g     F .text	00000128 alt_sys_init
00226bcc g     F .text	00000114 __register_exitproc
00224b84 g     F .text	00000050 altera_avalon_mutex_unlock
00224448 g     F .text	00000068 altera_avalon_jtag_uart_close
00226ffc g       *ABS*	00000000 __ram_rwdata_start
00226ea8 g       *ABS*	00000000 __ram_rodata_start
0022a748 g     O .bss	00000028 __malloc_current_mallinfo
00223f74 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
002265ac g     F .text	000000b4 alt_get_fd
00222e48 g     F .text	00000054 _close_r
002267d4 g     F .text	0000007c memcmp
00224034 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0022a870 g       *ABS*	00000000 __alt_stack_base
00224084 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
00221d28 g     F .text	00000130 __swsetup_r
002222d0 g     F .text	00000118 __sfp
00227420 g     O .rwdata	00000408 __malloc_av_
0022241c g     F .text	00000004 __sinit_lock_release
00222cb0 g     F .text	00000054 __sread
00226498 g     F .text	00000114 alt_find_file
00225a44 g     F .text	000000a4 alt_dev_llist_insert
002236d4 g     F .text	00000020 __malloc_lock
00223b2c g     F .text	000000b0 sbrk
00221e58 g     F .text	00000228 _fflush_r
0022a71c g       *ABS*	00000000 __bss_start
00222b8c g     F .text	00000124 memset
00220000 g       *ABS*	00000000 __alt_mem_MEMSlave2
0022028c g     F .text	00000324 main
0022a734 g     O .bss	00000004 alt_envp
0022a71c g     O .bss	00000004 __malloc_max_total_mem
00225608 g     F .text	00000040 alt_up_char_buffer_open_dev
00223fd4 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
00226bb0 g     F .text	0000001c __swbuf
00222de4 g     F .text	00000008 __sclose
00233880 g       *ABS*	00000000 __alt_heap_limit
00222f9c g     F .text	00000014 fclose
00224b04 g     F .text	00000040 altera_avalon_mutex_lock
00220c10 g     F .text	000007a8 _malloc_r
00228b70 g     O .rwdata	00000004 alt_errno
00222864 g     F .text	000000b8 _fwalk
002268f0 g     F .text	000000c8 putc
00222450 g     F .text	00000124 _malloc_trim_r
00226ea8 g       *ABS*	00000000 __CTOR_END__
002269b8 g     F .text	000000a4 strcmp
00226ea8 g       *ABS*	00000000 __flash_rodata_start
00226ea8 g       *ABS*	00000000 __DTOR_LIST__
00223e18 g     F .text	00000034 alt_irq_init
00223acc g     F .text	00000060 alt_release_fd
00226788 g     F .text	00000014 atexit
00222dec g     F .text	0000005c _write_r
00228b50 g     O .rwdata	00000004 _impure_ptr
0022a72c g     O .bss	00000004 alt_argc
00225b44 g     F .text	0000005c _do_dtors
00220020 g       .exceptions	00000000 alt_irq_entry
00222438 g     F .text	00000018 __fp_unlock_all
00228b5c g     O .rwdata	00000008 alt_fs_list
00220020 g       *ABS*	00000000 __ram_exceptions_start
00225c60 g     F .text	00000050 alt_ic_isr_register
00228b8c g       *ABS*	00000000 _edata
00224c98 g     F .text	00000060 altera_avalon_uart_read_fd
0022a870 g       *ABS*	00000000 _end
00220240 g       *ABS*	00000000 __ram_exceptions_end
002244b0 g     F .text	000000ec altera_avalon_jtag_uart_ioctl
00225d50 g     F .text	000000a4 alt_ic_irq_disable
00222d0c g     F .text	0000007c __swrite
00228b58 g     O .rwdata	00000004 __malloc_trim_threshold
0022679c g     F .text	00000038 exit
0022291c g     F .text	000000b8 _fwalk_reent
00233880 g       *ABS*	00000000 __alt_data_end
00220020 g     F .exceptions	00000000 alt_exception
00222414 g     F .text	00000004 __sfp_lock_release
0022510c g     F .text	00000054 altera_avalon_uart_close
00226e74 g     F .text	00000034 _exit
00225870 g     F .text	00000140 alt_alarm_start
002229d4 g     F .text	000001b8 __smakebuf_r
002206d4 g     F .text	00000098 strlen
00226184 g     F .text	00000158 open
0022393c g     F .text	00000044 alt_putchar
00225c30 g     F .text	00000030 alt_icache_flush_all
00228b80 g     O .rwdata	00000004 alt_priority_mask
00225cb0 g     F .text	000000a0 alt_ic_irq_enable
00224ae0 g     F .text	00000024 altera_avalon_mutex_close
002251b0 g     F .text	000001dc altera_avalon_uart_read
00228b84 g     O .rwdata	00000008 alt_alarm_list
00225ae8 g     F .text	0000005c _do_ctors
00223164 g     F .text	000000d0 close
002234b8 g     F .text	00000080 alt_load
00000000  w      *UND*	00000000 free
00222418 g     F .text	00000004 __sinit_lock_acquire



Disassembly of section .entry:

00220000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
  220000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
  220004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
  220008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
  22000c:	00bffd16 	blt	zero,r2,220004 <__alt_data_end+0xfffec784>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
  220010:	004008b4 	movhi	at,34
    ori r1, r1, %lo(_start)
  220014:	08409014 	ori	at,at,576
    jmp r1
  220018:	0800683a 	jmp	at
  22001c:	00000000 	call	0 <__reset-0x220000>

Disassembly of section .exceptions:

00220020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
  220020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
  220024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
  220028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  22002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  220030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  220034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  220038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  22003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  220040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
  220044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
  220048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  22004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  220050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  220054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  220058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  22005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  220060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  220064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  220068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  22006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  220070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  220074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  220078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  22007c:	10000326 	beq	r2,zero,22008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
  220080:	20000226 	beq	r4,zero,22008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  220084:	02200fc0 	call	2200fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  220088:	00000706 	br	2200a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
  22008c:	df401215 	stw	ea,72(sp)
        ldhu.n  r2, 0(r4)
        ldhu.n  r3, 2(r4)
        slli.n  r3, r3, 16
        or.n    r2, r2, r3 /* Instruction that caused exception */
#else
        ldw   r2, -4(ea)   /* Instruction that caused exception */
  220090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
  220094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
  220098:	02201cc0 	call	2201cc <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
  22009c:	1000021e 	bne	r2,zero,2200a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
  2200a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  2200a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
  2200a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  2200ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  2200b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  2200b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  2200b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  2200bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  2200c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  2200c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  2200c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  2200cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  2200d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
  2200d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  2200d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  2200dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  2200e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  2200e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  2200e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  2200ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  2200f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
  2200f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
  2200f8:	ef80083a 	eret

002200fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  2200fc:	defff904 	addi	sp,sp,-28
  220100:	dfc00615 	stw	ra,24(sp)
  220104:	df000515 	stw	fp,20(sp)
  220108:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
  22010c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  220110:	0005313a 	rdctl	r2,ipending
  220114:	e0bffe15 	stw	r2,-8(fp)

  return active;
  220118:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
  22011c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
  220120:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
  220124:	00800044 	movi	r2,1
  220128:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  22012c:	e0fffb17 	ldw	r3,-20(fp)
  220130:	e0bffc17 	ldw	r2,-16(fp)
  220134:	1884703a 	and	r2,r3,r2
  220138:	10001426 	beq	r2,zero,22018c <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
  22013c:	008008f4 	movhi	r2,35
  220140:	10a9dc04 	addi	r2,r2,-22672
  220144:	e0fffd17 	ldw	r3,-12(fp)
  220148:	180690fa 	slli	r3,r3,3
  22014c:	10c5883a 	add	r2,r2,r3
  220150:	10c00017 	ldw	r3,0(r2)
  220154:	008008f4 	movhi	r2,35
  220158:	10a9dc04 	addi	r2,r2,-22672
  22015c:	e13ffd17 	ldw	r4,-12(fp)
  220160:	200890fa 	slli	r4,r4,3
  220164:	1105883a 	add	r2,r2,r4
  220168:	10800104 	addi	r2,r2,4
  22016c:	10800017 	ldw	r2,0(r2)
  220170:	1009883a 	mov	r4,r2
  220174:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
  220178:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  22017c:	0005313a 	rdctl	r2,ipending
  220180:	e0bfff15 	stw	r2,-4(fp)

  return active;
  220184:	e0bfff17 	ldw	r2,-4(fp)
  220188:	00000706 	br	2201a8 <alt_irq_handler+0xac>
      }
      mask <<= 1;
  22018c:	e0bffc17 	ldw	r2,-16(fp)
  220190:	1085883a 	add	r2,r2,r2
  220194:	e0bffc15 	stw	r2,-16(fp)
      i++;
  220198:	e0bffd17 	ldw	r2,-12(fp)
  22019c:	10800044 	addi	r2,r2,1
  2201a0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
  2201a4:	003fe106 	br	22012c <__alt_data_end+0xfffec8ac>

    active = alt_irq_pending ();
  2201a8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
  2201ac:	e0bffb17 	ldw	r2,-20(fp)
  2201b0:	103fdb1e 	bne	r2,zero,220120 <__alt_data_end+0xfffec8a0>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
  2201b4:	0001883a 	nop
}
  2201b8:	e037883a 	mov	sp,fp
  2201bc:	dfc00117 	ldw	ra,4(sp)
  2201c0:	df000017 	ldw	fp,0(sp)
  2201c4:	dec00204 	addi	sp,sp,8
  2201c8:	f800283a 	ret

002201cc <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
  2201cc:	defffb04 	addi	sp,sp,-20
  2201d0:	dfc00415 	stw	ra,16(sp)
  2201d4:	df000315 	stw	fp,12(sp)
  2201d8:	df000304 	addi	fp,sp,12
  2201dc:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
  2201e0:	000531fa 	rdctl	r2,exception
  2201e4:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
  2201e8:	e0bffd17 	ldw	r2,-12(fp)
  2201ec:	10801f0c 	andi	r2,r2,124
  2201f0:	1004d0ba 	srli	r2,r2,2
  2201f4:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
  2201f8:	0005333a 	rdctl	r2,badaddr
  2201fc:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
  220200:	d0a6fe17 	ldw	r2,-25608(gp)
  220204:	10000726 	beq	r2,zero,220224 <alt_instruction_exception_entry+0x58>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
  220208:	d0a6fe17 	ldw	r2,-25608(gp)
  22020c:	e0fffd17 	ldw	r3,-12(fp)
  220210:	1809883a 	mov	r4,r3
  220214:	e17fff17 	ldw	r5,-4(fp)
  220218:	e1bffe17 	ldw	r6,-8(fp)
  22021c:	103ee83a 	callr	r2
  220220:	00000206 	br	22022c <alt_instruction_exception_entry+0x60>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
  220224:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
  220228:	0005883a 	mov	r2,zero
}
  22022c:	e037883a 	mov	sp,fp
  220230:	dfc00117 	ldw	ra,4(sp)
  220234:	df000017 	ldw	fp,0(sp)
  220238:	dec00204 	addi	sp,sp,8
  22023c:	f800283a 	ret

Disassembly of section .text:

00220240 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
  220240:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
  220244:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
  220248:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
  22024c:	00bffd16 	blt	zero,r2,220244 <__alt_data_end+0xfffec9c4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
  220250:	06c008f4 	movhi	sp,35
    ori sp, sp, %lo(__alt_stack_pointer)
  220254:	dece2014 	ori	sp,sp,14464
    movhi gp, %hi(_gp)
  220258:	068008f4 	movhi	gp,35
    ori gp, gp, %lo(_gp)
  22025c:	d682d314 	ori	gp,gp,2892
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
  220260:	008008b4 	movhi	r2,34
    ori r2, r2, %lo(__bss_start)
  220264:	10a9c714 	ori	r2,r2,42780

    movhi r3, %hi(__bss_end)
  220268:	00c008b4 	movhi	r3,34
    ori r3, r3, %lo(__bss_end)
  22026c:	18ea1c14 	ori	r3,r3,43120

    beq r2, r3, 1f
  220270:	10c00326 	beq	r2,r3,220280 <_start+0x40>

0:
    stw zero, (r2)
  220274:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
  220278:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
  22027c:	10fffd36 	bltu	r2,r3,220274 <__alt_data_end+0xfffec9f4>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
  220280:	02234b80 	call	2234b8 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
  220284:	022365c0 	call	22365c <alt_main>

00220288 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
  220288:	003fff06 	br	220288 <__alt_data_end+0xfffeca08>

0022028c <main>:
#include "altera_avalon_uart.h"
#include "altera_avalon_uart_regs.h"
#include "altera_up_avalon_video_character_buffer_with_dma.h"

int main()
{
  22028c:	deffed04 	addi	sp,sp,-76
  220290:	dfc01215 	stw	ra,72(sp)
  220294:	df001115 	stw	fp,68(sp)
  220298:	df001104 	addi	fp,sp,68
	char str2[]={"SLAVE2 (Green ON)"};
  22029c:	00959074 	movhi	r2,22081
  2202a0:	109314c4 	addi	r2,r2,19539
  2202a4:	e0bff415 	stw	r2,-48(fp)
  2202a8:	008a0834 	movhi	r2,10272
  2202ac:	108c9144 	addi	r2,r2,12869
  2202b0:	e0bff515 	stw	r2,-44(fp)
  2202b4:	00995974 	movhi	r2,25957
  2202b8:	109c91c4 	addi	r2,r2,29255
  2202bc:	e0bff615 	stw	r2,-40(fp)
  2202c0:	009393f4 	movhi	r2,20047
  2202c4:	10881b84 	addi	r2,r2,8302
  2202c8:	e0bff715 	stw	r2,-36(fp)
  2202cc:	00800a44 	movi	r2,41
  2202d0:	e0bff80d 	sth	r2,-32(fp)
	char str1[]={"SLAVE2 (Red ON)"};
  2202d4:	009314c4 	movi	r2,19539
  2202d8:	e0bff88d 	sth	r2,-30(fp)
  2202dc:	00959044 	movi	r2,22081
  2202e0:	e0bff90d 	sth	r2,-28(fp)
  2202e4:	008c9144 	movi	r2,12869
  2202e8:	e0bff98d 	sth	r2,-26(fp)
  2202ec:	008a0804 	movi	r2,10272
  2202f0:	e0bffa0d 	sth	r2,-24(fp)
  2202f4:	00995484 	movi	r2,25938
  2202f8:	e0bffa8d 	sth	r2,-22(fp)
  2202fc:	00881904 	movi	r2,8292
  220300:	e0bffb0d 	sth	r2,-20(fp)
  220304:	009393c4 	movi	r2,20047
  220308:	e0bffb8d 	sth	r2,-18(fp)
  22030c:	00800a44 	movi	r2,41
  220310:	e0bffc0d 	sth	r2,-16(fp)
	char str3[]={"SLAVE2 (OFF)"};
  220314:	009314c4 	movi	r2,19539
  220318:	e0bffc8d 	sth	r2,-14(fp)
  22031c:	00959044 	movi	r2,22081
  220320:	e0bffd0d 	sth	r2,-12(fp)
  220324:	008c9144 	movi	r2,12869
  220328:	e0bffd8d 	sth	r2,-10(fp)
  22032c:	008a0804 	movi	r2,10272
  220330:	e0bffe0d 	sth	r2,-8(fp)
  220334:	009193c4 	movi	r2,17999
  220338:	e0bffe8d 	sth	r2,-6(fp)
  22033c:	008a5184 	movi	r2,10566
  220340:	e0bfff0d 	sth	r2,-4(fp)
  220344:	e03fff85 	stb	zero,-2(fp)
	 alt_mutex_dev *Mymutex;
		 Mymutex=altera_avalon_mutex_open("/dev/mutex_0");
  220348:	010008b4 	movhi	r4,34
  22034c:	211baa04 	addi	r4,r4,28328
  220350:	0224a8c0 	call	224a8c <altera_avalon_mutex_open>
  220354:	e0bff115 	stw	r2,-60(fp)
  printf("Hello from Nios II#2!\n");
  220358:	010008b4 	movhi	r4,34
  22035c:	211bae04 	addi	r4,r4,28344
  220360:	02206c00 	call	2206c0 <puts>
  int y=0;
  220364:	e03fef15 	stw	zero,-68(fp)

  while(altera_avalon_mutex_trylock(Mymutex,ALT_CPU_CPU_ID_VALUE ))
  220368:	0001883a 	nop
  22036c:	e13ff117 	ldw	r4,-60(fp)
  220370:	000b883a 	mov	r5,zero
  220374:	0224b440 	call	224b44 <altera_avalon_mutex_trylock>
  220378:	103ffc1e 	bne	r2,zero,22036c <__alt_data_end+0xfffecaec>
    	 {}
   // FILE *fp;

    	 alt_up_char_buffer_dev * vga_dev;
    	 	// open the VGA port
    	 	vga_dev = alt_up_char_buffer_open_dev("/dev/video_character_buffer_with_dma_0");
  22037c:	010008b4 	movhi	r4,34
  220380:	211bb404 	addi	r4,r4,28368
  220384:	02256080 	call	225608 <alt_up_char_buffer_open_dev>
  220388:	e0bff215 	stw	r2,-56(fp)

    	 	if (vga_dev == NULL)
  22038c:	e0bff217 	ldw	r2,-56(fp)
  220390:	1000041e 	bne	r2,zero,2203a4 <main+0x118>
    	 	    	alt_printf ("Error: could not open VGA device \n");
  220394:	010008b4 	movhi	r4,34
  220398:	211bbe04 	addi	r4,r4,28408
  22039c:	02237140 	call	223714 <alt_printf>
  2203a0:	00000306 	br	2203b0 <main+0x124>
    	 	    	else
    	 	    	alt_printf ("Opened VGA device \n");
  2203a4:	010008b4 	movhi	r4,34
  2203a8:	211bc704 	addi	r4,r4,28444
  2203ac:	02237140 	call	223714 <alt_printf>
      altera_avalon_mutex_unlock (Mymutex);
  2203b0:	e13ff117 	ldw	r4,-60(fp)
  2203b4:	0224b840 	call	224b84 <altera_avalon_mutex_unlock>


  while(1){
	  //int x=IORD_ALTERA_AVALON_PIO_DATA(PIOSLAVE1_BASE);
	  while(altera_avalon_mutex_trylock(Mymutex,ALT_CPU_CPU_ID_VALUE ))
  2203b8:	0001883a 	nop
  2203bc:	e13ff117 	ldw	r4,-60(fp)
  2203c0:	000b883a 	mov	r5,zero
  2203c4:	0224b440 	call	224b44 <altera_avalon_mutex_trylock>
  2203c8:	103ffc1e 	bne	r2,zero,2203bc <__alt_data_end+0xfffecb3c>
	  	 {}
	  int y0=IORD_ALTERA_AVALON_UART_RXDATA(UART_0_BASE);
  2203cc:	00804034 	movhi	r2,256
  2203d0:	10800037 	ldwio	r2,0(r2)
  2203d4:	e0bff315 	stw	r2,-52(fp)
	  alt_printf("%d",y);
  2203d8:	010008b4 	movhi	r4,34
  2203dc:	211bcc04 	addi	r4,r4,28464
  2203e0:	e17fef17 	ldw	r5,-68(fp)
  2203e4:	02237140 	call	223714 <alt_printf>
	  int x=IORD_16DIRECT(0x41008,0);
  2203e8:	00800134 	movhi	r2,4
  2203ec:	10840204 	addi	r2,r2,4104
  2203f0:	1080002b 	ldhuio	r2,0(r2)
  2203f4:	10bfffcc 	andi	r2,r2,65535
  2203f8:	e0bff015 	stw	r2,-64(fp)
	  if((y==0xF0)||(y==0xFF)) x=0;
  2203fc:	e0bfef17 	ldw	r2,-68(fp)
  220400:	10803c20 	cmpeqi	r2,r2,240
  220404:	1000031e 	bne	r2,zero,220414 <main+0x188>
  220408:	e0bfef17 	ldw	r2,-68(fp)
  22040c:	10803fd8 	cmpnei	r2,r2,255
  220410:	1000011e 	bne	r2,zero,220418 <main+0x18c>
  220414:	e03ff015 	stw	zero,-64(fp)

	  altera_avalon_mutex_unlock (Mymutex);
  220418:	e13ff117 	ldw	r4,-60(fp)
  22041c:	0224b840 	call	224b84 <altera_avalon_mutex_unlock>

	  if(x==255) {
  220420:	e0bff017 	ldw	r2,-64(fp)
  220424:	10803fd8 	cmpnei	r2,r2,255
  220428:	1000211e 	bne	r2,zero,2204b0 <main+0x224>
		  printf("RedON\n");
  22042c:	010008b4 	movhi	r4,34
  220430:	211bcd04 	addi	r4,r4,28468
  220434:	02206c00 	call	2206c0 <puts>
		  if(y==256)y=0;
  220438:	e0bfef17 	ldw	r2,-68(fp)
  22043c:	10804018 	cmpnei	r2,r2,256
  220440:	1000011e 	bne	r2,zero,220448 <main+0x1bc>
  220444:	e03fef15 	stw	zero,-68(fp)
		  while(altera_avalon_mutex_trylock(Mymutex,ALT_CPU_CPU_ID_VALUE ))
  220448:	0001883a 	nop
  22044c:	e13ff117 	ldw	r4,-60(fp)
  220450:	000b883a 	mov	r5,zero
  220454:	0224b440 	call	224b44 <altera_avalon_mutex_trylock>
  220458:	103ffc1e 	bne	r2,zero,22044c <__alt_data_end+0xfffecbcc>
		  	  	  		  	  	 {}
		  alt_up_char_buffer_string(vga_dev, str1, 1, 3);
  22045c:	e0bff884 	addi	r2,fp,-30
  220460:	e13ff217 	ldw	r4,-56(fp)
  220464:	100b883a 	mov	r5,r2
  220468:	01800044 	movi	r6,1
  22046c:	01c000c4 	movi	r7,3
  220470:	02257140 	call	225714 <alt_up_char_buffer_string>
		  IOWR_ALTERA_AVALON_PIO_DATA(LEDRSLAVE2_BASE, y);
  220474:	00800934 	movhi	r2,36
  220478:	10840004 	addi	r2,r2,4096
  22047c:	e0ffef17 	ldw	r3,-68(fp)
  220480:	10c00035 	stwio	r3,0(r2)
		  altera_avalon_mutex_unlock (Mymutex);
  220484:	e13ff117 	ldw	r4,-60(fp)
  220488:	0224b840 	call	224b84 <altera_avalon_mutex_unlock>
		  y=y*2;
  22048c:	e0bfef17 	ldw	r2,-68(fp)
  220490:	1085883a 	add	r2,r2,r2
  220494:	e0bfef15 	stw	r2,-68(fp)
		  if(y==0)y=1;
  220498:	e0bfef17 	ldw	r2,-68(fp)
  22049c:	1000021e 	bne	r2,zero,2204a8 <main+0x21c>
  2204a0:	00800044 	movi	r2,1
  2204a4:	e0bfef15 	stw	r2,-68(fp)
		  delay10ms(20);
  2204a8:	01000504 	movi	r4,20
  2204ac:	02205b00 	call	2205b0 <delay10ms>
	  }
	  if(x==15) {
  2204b0:	e0bff017 	ldw	r2,-64(fp)
  2204b4:	108003d8 	cmpnei	r2,r2,15
  2204b8:	1000211e 	bne	r2,zero,220540 <main+0x2b4>
	  	  		  printf("greenON\n");
  2204bc:	010008b4 	movhi	r4,34
  2204c0:	211bcf04 	addi	r4,r4,28476
  2204c4:	02206c00 	call	2206c0 <puts>
	  	  		  if(y==256)y=0;
  2204c8:	e0bfef17 	ldw	r2,-68(fp)
  2204cc:	10804018 	cmpnei	r2,r2,256
  2204d0:	1000011e 	bne	r2,zero,2204d8 <main+0x24c>
  2204d4:	e03fef15 	stw	zero,-68(fp)
	  	  		  while(altera_avalon_mutex_trylock(Mymutex,ALT_CPU_CPU_ID_VALUE ))
  2204d8:	0001883a 	nop
  2204dc:	e13ff117 	ldw	r4,-60(fp)
  2204e0:	000b883a 	mov	r5,zero
  2204e4:	0224b440 	call	224b44 <altera_avalon_mutex_trylock>
  2204e8:	103ffc1e 	bne	r2,zero,2204dc <__alt_data_end+0xfffecc5c>
	  	  		  	  	 {}
	  	  		 alt_up_char_buffer_string(vga_dev, str2, 1, 3);
  2204ec:	e0bff404 	addi	r2,fp,-48
  2204f0:	e13ff217 	ldw	r4,-56(fp)
  2204f4:	100b883a 	mov	r5,r2
  2204f8:	01800044 	movi	r6,1
  2204fc:	01c000c4 	movi	r7,3
  220500:	02257140 	call	225714 <alt_up_char_buffer_string>
	  	  		  IOWR_ALTERA_AVALON_PIO_DATA(0x141000, y);
  220504:	00800534 	movhi	r2,20
  220508:	10840004 	addi	r2,r2,4096
  22050c:	e0ffef17 	ldw	r3,-68(fp)
  220510:	10c00035 	stwio	r3,0(r2)
	  	  		  altera_avalon_mutex_unlock (Mymutex);
  220514:	e13ff117 	ldw	r4,-60(fp)
  220518:	0224b840 	call	224b84 <altera_avalon_mutex_unlock>
	  	  		  y=y*2;
  22051c:	e0bfef17 	ldw	r2,-68(fp)
  220520:	1085883a 	add	r2,r2,r2
  220524:	e0bfef15 	stw	r2,-68(fp)
	  	  		  if(y==0)y=1;
  220528:	e0bfef17 	ldw	r2,-68(fp)
  22052c:	1000021e 	bne	r2,zero,220538 <main+0x2ac>
  220530:	00800044 	movi	r2,1
  220534:	e0bfef15 	stw	r2,-68(fp)
	  	  		  delay10ms(20);
  220538:	01000504 	movi	r4,20
  22053c:	02205b00 	call	2205b0 <delay10ms>
	  	  	  }
	  if(x==0){
  220540:	e0bff017 	ldw	r2,-64(fp)
  220544:	1000191e 	bne	r2,zero,2205ac <main+0x320>
		  printf("redgreenOFF\n");
  220548:	010008b4 	movhi	r4,34
  22054c:	211bd104 	addi	r4,r4,28484
  220550:	02206c00 	call	2206c0 <puts>
		  while(altera_avalon_mutex_trylock(Mymutex,ALT_CPU_CPU_ID_VALUE ))
  220554:	0001883a 	nop
  220558:	e13ff117 	ldw	r4,-60(fp)
  22055c:	000b883a 	mov	r5,zero
  220560:	0224b440 	call	224b44 <altera_avalon_mutex_trylock>
  220564:	103ffc1e 	bne	r2,zero,220558 <__alt_data_end+0xfffeccd8>
		  	  	  		  	  	 {}
		  alt_up_char_buffer_string(vga_dev, str3, 1, 3);
  220568:	e0bffc84 	addi	r2,fp,-14
  22056c:	e13ff217 	ldw	r4,-56(fp)
  220570:	100b883a 	mov	r5,r2
  220574:	01800044 	movi	r6,1
  220578:	01c000c4 	movi	r7,3
  22057c:	02257140 	call	225714 <alt_up_char_buffer_string>
		  IOWR_ALTERA_AVALON_PIO_DATA(LEDRSLAVE2_BASE, 0);
  220580:	0007883a 	mov	r3,zero
  220584:	00800934 	movhi	r2,36
  220588:	10840004 	addi	r2,r2,4096
  22058c:	10c00035 	stwio	r3,0(r2)
		  IOWR_ALTERA_AVALON_PIO_DATA(0x141000, 0);
  220590:	0007883a 	mov	r3,zero
  220594:	00800534 	movhi	r2,20
  220598:	10840004 	addi	r2,r2,4096
  22059c:	10c00035 	stwio	r3,0(r2)
		  altera_avalon_mutex_unlock (Mymutex);
  2205a0:	e13ff117 	ldw	r4,-60(fp)
  2205a4:	0224b840 	call	224b84 <altera_avalon_mutex_unlock>
		  y=0;
  2205a8:	e03fef15 	stw	zero,-68(fp)
	  }


  }
  2205ac:	003f8206 	br	2203b8 <__alt_data_end+0xfffecb38>

002205b0 <delay10ms>:
  return 0;
}


void delay10ms(unsigned long time)
{
  2205b0:	defffd04 	addi	sp,sp,-12
  2205b4:	df000215 	stw	fp,8(sp)
  2205b8:	df000204 	addi	fp,sp,8
  2205bc:	e13fff15 	stw	r4,-4(fp)
	while(time>0)
  2205c0:	00000b06 	br	2205f0 <delay10ms+0x40>
	{
		int i=13333;
  2205c4:	008d0544 	movi	r2,13333
  2205c8:	e0bffe15 	stw	r2,-8(fp)
		while(i>0)
  2205cc:	00000306 	br	2205dc <delay10ms+0x2c>
		i--;
  2205d0:	e0bffe17 	ldw	r2,-8(fp)
  2205d4:	10bfffc4 	addi	r2,r2,-1
  2205d8:	e0bffe15 	stw	r2,-8(fp)
void delay10ms(unsigned long time)
{
	while(time>0)
	{
		int i=13333;
		while(i>0)
  2205dc:	e0bffe17 	ldw	r2,-8(fp)
  2205e0:	00bffb16 	blt	zero,r2,2205d0 <__alt_data_end+0xfffecd50>
		i--;
		time--;
  2205e4:	e0bfff17 	ldw	r2,-4(fp)
  2205e8:	10bfffc4 	addi	r2,r2,-1
  2205ec:	e0bfff15 	stw	r2,-4(fp)
}


void delay10ms(unsigned long time)
{
	while(time>0)
  2205f0:	e0bfff17 	ldw	r2,-4(fp)
  2205f4:	103ff31e 	bne	r2,zero,2205c4 <__alt_data_end+0xfffecd44>
		int i=13333;
		while(i>0)
		i--;
		time--;
	}
}
  2205f8:	e037883a 	mov	sp,fp
  2205fc:	df000017 	ldw	fp,0(sp)
  220600:	dec00104 	addi	sp,sp,4
  220604:	f800283a 	ret

00220608 <_puts_r>:
  220608:	defff604 	addi	sp,sp,-40
  22060c:	dc000715 	stw	r16,28(sp)
  220610:	2021883a 	mov	r16,r4
  220614:	2809883a 	mov	r4,r5
  220618:	dc400815 	stw	r17,32(sp)
  22061c:	dfc00915 	stw	ra,36(sp)
  220620:	2823883a 	mov	r17,r5
  220624:	02206d40 	call	2206d4 <strlen>
  220628:	00c008f4 	movhi	r3,35
  22062c:	18e2d404 	addi	r3,r3,-29872
  220630:	18c00017 	ldw	r3,0(r3)
  220634:	11000044 	addi	r4,r2,1
  220638:	d8800115 	stw	r2,4(sp)
  22063c:	18c00217 	ldw	r3,8(r3)
  220640:	014008b4 	movhi	r5,34
  220644:	295bd404 	addi	r5,r5,28496
  220648:	1880030b 	ldhu	r2,12(r3)
  22064c:	d9400215 	stw	r5,8(sp)
  220650:	d9000615 	stw	r4,24(sp)
  220654:	01400044 	movi	r5,1
  220658:	01000084 	movi	r4,2
  22065c:	d9000515 	stw	r4,20(sp)
  220660:	dc400015 	stw	r17,0(sp)
  220664:	d9400315 	stw	r5,12(sp)
  220668:	dec00415 	stw	sp,16(sp)
  22066c:	1108000c 	andi	r4,r2,8192
  220670:	2000061e 	bne	r4,zero,22068c <_puts_r+0x84>
  220674:	19401917 	ldw	r5,100(r3)
  220678:	0137ffc4 	movi	r4,-8193
  22067c:	10880014 	ori	r2,r2,8192
  220680:	2908703a 	and	r4,r5,r4
  220684:	1880030d 	sth	r2,12(r3)
  220688:	19001915 	stw	r4,100(r3)
  22068c:	81400217 	ldw	r5,8(r16)
  220690:	8009883a 	mov	r4,r16
  220694:	d9800404 	addi	r6,sp,16
  220698:	022076c0 	call	22076c <__sfvwrite_r>
  22069c:	1000061e 	bne	r2,zero,2206b8 <_puts_r+0xb0>
  2206a0:	00800284 	movi	r2,10
  2206a4:	dfc00917 	ldw	ra,36(sp)
  2206a8:	dc400817 	ldw	r17,32(sp)
  2206ac:	dc000717 	ldw	r16,28(sp)
  2206b0:	dec00a04 	addi	sp,sp,40
  2206b4:	f800283a 	ret
  2206b8:	00bfffc4 	movi	r2,-1
  2206bc:	003ff906 	br	2206a4 <__alt_data_end+0xfffece24>

002206c0 <puts>:
  2206c0:	008008f4 	movhi	r2,35
  2206c4:	10a2d404 	addi	r2,r2,-29872
  2206c8:	200b883a 	mov	r5,r4
  2206cc:	11000017 	ldw	r4,0(r2)
  2206d0:	02206081 	jmpi	220608 <_puts_r>

002206d4 <strlen>:
  2206d4:	208000cc 	andi	r2,r4,3
  2206d8:	10002026 	beq	r2,zero,22075c <strlen+0x88>
  2206dc:	20800007 	ldb	r2,0(r4)
  2206e0:	10002026 	beq	r2,zero,220764 <strlen+0x90>
  2206e4:	2005883a 	mov	r2,r4
  2206e8:	00000206 	br	2206f4 <strlen+0x20>
  2206ec:	10c00007 	ldb	r3,0(r2)
  2206f0:	18001826 	beq	r3,zero,220754 <strlen+0x80>
  2206f4:	10800044 	addi	r2,r2,1
  2206f8:	10c000cc 	andi	r3,r2,3
  2206fc:	183ffb1e 	bne	r3,zero,2206ec <__alt_data_end+0xfffece6c>
  220700:	10c00017 	ldw	r3,0(r2)
  220704:	01ffbff4 	movhi	r7,65279
  220708:	39ffbfc4 	addi	r7,r7,-257
  22070c:	00ca303a 	nor	r5,zero,r3
  220710:	01a02074 	movhi	r6,32897
  220714:	19c7883a 	add	r3,r3,r7
  220718:	31a02004 	addi	r6,r6,-32640
  22071c:	1946703a 	and	r3,r3,r5
  220720:	1986703a 	and	r3,r3,r6
  220724:	1800091e 	bne	r3,zero,22074c <strlen+0x78>
  220728:	10800104 	addi	r2,r2,4
  22072c:	10c00017 	ldw	r3,0(r2)
  220730:	19cb883a 	add	r5,r3,r7
  220734:	00c6303a 	nor	r3,zero,r3
  220738:	28c6703a 	and	r3,r5,r3
  22073c:	1986703a 	and	r3,r3,r6
  220740:	183ff926 	beq	r3,zero,220728 <__alt_data_end+0xfffecea8>
  220744:	00000106 	br	22074c <strlen+0x78>
  220748:	10800044 	addi	r2,r2,1
  22074c:	10c00007 	ldb	r3,0(r2)
  220750:	183ffd1e 	bne	r3,zero,220748 <__alt_data_end+0xfffecec8>
  220754:	1105c83a 	sub	r2,r2,r4
  220758:	f800283a 	ret
  22075c:	2005883a 	mov	r2,r4
  220760:	003fe706 	br	220700 <__alt_data_end+0xfffece80>
  220764:	0005883a 	mov	r2,zero
  220768:	f800283a 	ret

0022076c <__sfvwrite_r>:
  22076c:	30800217 	ldw	r2,8(r6)
  220770:	10004526 	beq	r2,zero,220888 <__sfvwrite_r+0x11c>
  220774:	28c0030b 	ldhu	r3,12(r5)
  220778:	defff404 	addi	sp,sp,-48
  22077c:	dd400715 	stw	r21,28(sp)
  220780:	dcc00515 	stw	r19,20(sp)
  220784:	dc000215 	stw	r16,8(sp)
  220788:	dfc00b15 	stw	ra,44(sp)
  22078c:	df000a15 	stw	fp,40(sp)
  220790:	ddc00915 	stw	r23,36(sp)
  220794:	dd800815 	stw	r22,32(sp)
  220798:	dd000615 	stw	r20,24(sp)
  22079c:	dc800415 	stw	r18,16(sp)
  2207a0:	dc400315 	stw	r17,12(sp)
  2207a4:	1880020c 	andi	r2,r3,8
  2207a8:	2821883a 	mov	r16,r5
  2207ac:	202b883a 	mov	r21,r4
  2207b0:	3027883a 	mov	r19,r6
  2207b4:	10002526 	beq	r2,zero,22084c <__sfvwrite_r+0xe0>
  2207b8:	28800417 	ldw	r2,16(r5)
  2207bc:	10002326 	beq	r2,zero,22084c <__sfvwrite_r+0xe0>
  2207c0:	1880008c 	andi	r2,r3,2
  2207c4:	9c400017 	ldw	r17,0(r19)
  2207c8:	10003126 	beq	r2,zero,220890 <__sfvwrite_r+0x124>
  2207cc:	0029883a 	mov	r20,zero
  2207d0:	0025883a 	mov	r18,zero
  2207d4:	05810004 	movi	r22,1024
  2207d8:	a00d883a 	mov	r6,r20
  2207dc:	a809883a 	mov	r4,r21
  2207e0:	90002526 	beq	r18,zero,220878 <__sfvwrite_r+0x10c>
  2207e4:	900f883a 	mov	r7,r18
  2207e8:	81400717 	ldw	r5,28(r16)
  2207ec:	b480012e 	bgeu	r22,r18,2207f4 <__sfvwrite_r+0x88>
  2207f0:	01c10004 	movi	r7,1024
  2207f4:	80800917 	ldw	r2,36(r16)
  2207f8:	103ee83a 	callr	r2
  2207fc:	0080510e 	bge	zero,r2,220944 <__sfvwrite_r+0x1d8>
  220800:	98c00217 	ldw	r3,8(r19)
  220804:	a0a9883a 	add	r20,r20,r2
  220808:	90a5c83a 	sub	r18,r18,r2
  22080c:	1885c83a 	sub	r2,r3,r2
  220810:	98800215 	stw	r2,8(r19)
  220814:	103ff01e 	bne	r2,zero,2207d8 <__alt_data_end+0xfffecf58>
  220818:	0005883a 	mov	r2,zero
  22081c:	dfc00b17 	ldw	ra,44(sp)
  220820:	df000a17 	ldw	fp,40(sp)
  220824:	ddc00917 	ldw	r23,36(sp)
  220828:	dd800817 	ldw	r22,32(sp)
  22082c:	dd400717 	ldw	r21,28(sp)
  220830:	dd000617 	ldw	r20,24(sp)
  220834:	dcc00517 	ldw	r19,20(sp)
  220838:	dc800417 	ldw	r18,16(sp)
  22083c:	dc400317 	ldw	r17,12(sp)
  220840:	dc000217 	ldw	r16,8(sp)
  220844:	dec00c04 	addi	sp,sp,48
  220848:	f800283a 	ret
  22084c:	a809883a 	mov	r4,r21
  220850:	800b883a 	mov	r5,r16
  220854:	0221d280 	call	221d28 <__swsetup_r>
  220858:	80c0030b 	ldhu	r3,12(r16)
  22085c:	103fd826 	beq	r2,zero,2207c0 <__alt_data_end+0xfffecf40>
  220860:	18c01014 	ori	r3,r3,64
  220864:	80c0030d 	sth	r3,12(r16)
  220868:	00c00244 	movi	r3,9
  22086c:	00bfffc4 	movi	r2,-1
  220870:	a8c00015 	stw	r3,0(r21)
  220874:	003fe906 	br	22081c <__alt_data_end+0xfffecf9c>
  220878:	8d000017 	ldw	r20,0(r17)
  22087c:	8c800117 	ldw	r18,4(r17)
  220880:	8c400204 	addi	r17,r17,8
  220884:	003fd406 	br	2207d8 <__alt_data_end+0xfffecf58>
  220888:	0005883a 	mov	r2,zero
  22088c:	f800283a 	ret
  220890:	1880004c 	andi	r2,r3,1
  220894:	1000301e 	bne	r2,zero,220958 <__sfvwrite_r+0x1ec>
  220898:	002f883a 	mov	r23,zero
  22089c:	0025883a 	mov	r18,zero
  2208a0:	90001c26 	beq	r18,zero,220914 <__sfvwrite_r+0x1a8>
  2208a4:	1880800c 	andi	r2,r3,512
  2208a8:	85000217 	ldw	r20,8(r16)
  2208ac:	10006c26 	beq	r2,zero,220a60 <__sfvwrite_r+0x2f4>
  2208b0:	a02d883a 	mov	r22,r20
  2208b4:	95008536 	bltu	r18,r20,220acc <__sfvwrite_r+0x360>
  2208b8:	1881200c 	andi	r2,r3,1152
  2208bc:	10009d1e 	bne	r2,zero,220b34 <__sfvwrite_r+0x3c8>
  2208c0:	81000017 	ldw	r4,0(r16)
  2208c4:	a039883a 	mov	fp,r20
  2208c8:	9029883a 	mov	r20,r18
  2208cc:	b80b883a 	mov	r5,r23
  2208d0:	b00d883a 	mov	r6,r22
  2208d4:	02215d80 	call	2215d8 <memmove>
  2208d8:	80c00217 	ldw	r3,8(r16)
  2208dc:	81000017 	ldw	r4,0(r16)
  2208e0:	9005883a 	mov	r2,r18
  2208e4:	1f39c83a 	sub	fp,r3,fp
  2208e8:	258f883a 	add	r7,r4,r22
  2208ec:	87000215 	stw	fp,8(r16)
  2208f0:	81c00015 	stw	r7,0(r16)
  2208f4:	98c00217 	ldw	r3,8(r19)
  2208f8:	b8af883a 	add	r23,r23,r2
  2208fc:	90a5c83a 	sub	r18,r18,r2
  220900:	1d05c83a 	sub	r2,r3,r20
  220904:	98800215 	stw	r2,8(r19)
  220908:	103fc326 	beq	r2,zero,220818 <__alt_data_end+0xfffecf98>
  22090c:	80c0030b 	ldhu	r3,12(r16)
  220910:	903fe41e 	bne	r18,zero,2208a4 <__alt_data_end+0xfffed024>
  220914:	8dc00017 	ldw	r23,0(r17)
  220918:	8c800117 	ldw	r18,4(r17)
  22091c:	8c400204 	addi	r17,r17,8
  220920:	003fdf06 	br	2208a0 <__alt_data_end+0xfffed020>
  220924:	02217340 	call	221734 <_realloc_r>
  220928:	102d883a 	mov	r22,r2
  22092c:	1000a01e 	bne	r2,zero,220bb0 <__sfvwrite_r+0x444>
  220930:	81400417 	ldw	r5,16(r16)
  220934:	a809883a 	mov	r4,r21
  220938:	02225740 	call	222574 <_free_r>
  22093c:	00800304 	movi	r2,12
  220940:	a8800015 	stw	r2,0(r21)
  220944:	80c0030b 	ldhu	r3,12(r16)
  220948:	00bfffc4 	movi	r2,-1
  22094c:	18c01014 	ori	r3,r3,64
  220950:	80c0030d 	sth	r3,12(r16)
  220954:	003fb106 	br	22081c <__alt_data_end+0xfffecf9c>
  220958:	0029883a 	mov	r20,zero
  22095c:	0011883a 	mov	r8,zero
  220960:	0039883a 	mov	fp,zero
  220964:	0025883a 	mov	r18,zero
  220968:	90001f26 	beq	r18,zero,2209e8 <__sfvwrite_r+0x27c>
  22096c:	40006826 	beq	r8,zero,220b10 <__sfvwrite_r+0x3a4>
  220970:	a02f883a 	mov	r23,r20
  220974:	9500012e 	bgeu	r18,r20,22097c <__sfvwrite_r+0x210>
  220978:	902f883a 	mov	r23,r18
  22097c:	81000017 	ldw	r4,0(r16)
  220980:	80800417 	ldw	r2,16(r16)
  220984:	b82d883a 	mov	r22,r23
  220988:	81800217 	ldw	r6,8(r16)
  22098c:	81c00517 	ldw	r7,20(r16)
  220990:	1100022e 	bgeu	r2,r4,22099c <__sfvwrite_r+0x230>
  220994:	31c7883a 	add	r3,r6,r7
  220998:	1dc01816 	blt	r3,r23,2209fc <__sfvwrite_r+0x290>
  22099c:	b9c03f16 	blt	r23,r7,220a9c <__sfvwrite_r+0x330>
  2209a0:	80800917 	ldw	r2,36(r16)
  2209a4:	81400717 	ldw	r5,28(r16)
  2209a8:	a809883a 	mov	r4,r21
  2209ac:	da000115 	stw	r8,4(sp)
  2209b0:	e00d883a 	mov	r6,fp
  2209b4:	103ee83a 	callr	r2
  2209b8:	102d883a 	mov	r22,r2
  2209bc:	da000117 	ldw	r8,4(sp)
  2209c0:	00bfe00e 	bge	zero,r2,220944 <__alt_data_end+0xfffed0c4>
  2209c4:	a5a9c83a 	sub	r20,r20,r22
  2209c8:	a0001f26 	beq	r20,zero,220a48 <__sfvwrite_r+0x2dc>
  2209cc:	98800217 	ldw	r2,8(r19)
  2209d0:	e5b9883a 	add	fp,fp,r22
  2209d4:	95a5c83a 	sub	r18,r18,r22
  2209d8:	15adc83a 	sub	r22,r2,r22
  2209dc:	9d800215 	stw	r22,8(r19)
  2209e0:	b03f8d26 	beq	r22,zero,220818 <__alt_data_end+0xfffecf98>
  2209e4:	903fe11e 	bne	r18,zero,22096c <__alt_data_end+0xfffed0ec>
  2209e8:	8f000017 	ldw	fp,0(r17)
  2209ec:	8c800117 	ldw	r18,4(r17)
  2209f0:	0011883a 	mov	r8,zero
  2209f4:	8c400204 	addi	r17,r17,8
  2209f8:	003fdb06 	br	220968 <__alt_data_end+0xfffed0e8>
  2209fc:	180d883a 	mov	r6,r3
  220a00:	e00b883a 	mov	r5,fp
  220a04:	da000115 	stw	r8,4(sp)
  220a08:	d8c00015 	stw	r3,0(sp)
  220a0c:	02215d80 	call	2215d8 <memmove>
  220a10:	d8c00017 	ldw	r3,0(sp)
  220a14:	80800017 	ldw	r2,0(r16)
  220a18:	a809883a 	mov	r4,r21
  220a1c:	800b883a 	mov	r5,r16
  220a20:	10c5883a 	add	r2,r2,r3
  220a24:	80800015 	stw	r2,0(r16)
  220a28:	d8c00015 	stw	r3,0(sp)
  220a2c:	0221e580 	call	221e58 <_fflush_r>
  220a30:	d8c00017 	ldw	r3,0(sp)
  220a34:	da000117 	ldw	r8,4(sp)
  220a38:	103fc21e 	bne	r2,zero,220944 <__alt_data_end+0xfffed0c4>
  220a3c:	182d883a 	mov	r22,r3
  220a40:	a5a9c83a 	sub	r20,r20,r22
  220a44:	a03fe11e 	bne	r20,zero,2209cc <__alt_data_end+0xfffed14c>
  220a48:	a809883a 	mov	r4,r21
  220a4c:	800b883a 	mov	r5,r16
  220a50:	0221e580 	call	221e58 <_fflush_r>
  220a54:	103fbb1e 	bne	r2,zero,220944 <__alt_data_end+0xfffed0c4>
  220a58:	0011883a 	mov	r8,zero
  220a5c:	003fdb06 	br	2209cc <__alt_data_end+0xfffed14c>
  220a60:	81000017 	ldw	r4,0(r16)
  220a64:	80800417 	ldw	r2,16(r16)
  220a68:	1100012e 	bgeu	r2,r4,220a70 <__sfvwrite_r+0x304>
  220a6c:	a4805a36 	bltu	r20,r18,220bd8 <__sfvwrite_r+0x46c>
  220a70:	81c00517 	ldw	r7,20(r16)
  220a74:	91c01a36 	bltu	r18,r7,220ae0 <__sfvwrite_r+0x374>
  220a78:	80800917 	ldw	r2,36(r16)
  220a7c:	81400717 	ldw	r5,28(r16)
  220a80:	a809883a 	mov	r4,r21
  220a84:	b80d883a 	mov	r6,r23
  220a88:	103ee83a 	callr	r2
  220a8c:	1029883a 	mov	r20,r2
  220a90:	00bfac0e 	bge	zero,r2,220944 <__alt_data_end+0xfffed0c4>
  220a94:	a005883a 	mov	r2,r20
  220a98:	003f9606 	br	2208f4 <__alt_data_end+0xfffed074>
  220a9c:	b80d883a 	mov	r6,r23
  220aa0:	e00b883a 	mov	r5,fp
  220aa4:	da000115 	stw	r8,4(sp)
  220aa8:	02215d80 	call	2215d8 <memmove>
  220aac:	80800217 	ldw	r2,8(r16)
  220ab0:	80c00017 	ldw	r3,0(r16)
  220ab4:	da000117 	ldw	r8,4(sp)
  220ab8:	15c5c83a 	sub	r2,r2,r23
  220abc:	1def883a 	add	r23,r3,r23
  220ac0:	80800215 	stw	r2,8(r16)
  220ac4:	85c00015 	stw	r23,0(r16)
  220ac8:	003fbe06 	br	2209c4 <__alt_data_end+0xfffed144>
  220acc:	81000017 	ldw	r4,0(r16)
  220ad0:	9039883a 	mov	fp,r18
  220ad4:	9029883a 	mov	r20,r18
  220ad8:	902d883a 	mov	r22,r18
  220adc:	003f7b06 	br	2208cc <__alt_data_end+0xfffed04c>
  220ae0:	b80b883a 	mov	r5,r23
  220ae4:	900d883a 	mov	r6,r18
  220ae8:	02215d80 	call	2215d8 <memmove>
  220aec:	80c00217 	ldw	r3,8(r16)
  220af0:	80800017 	ldw	r2,0(r16)
  220af4:	9029883a 	mov	r20,r18
  220af8:	1c87c83a 	sub	r3,r3,r18
  220afc:	1485883a 	add	r2,r2,r18
  220b00:	80800015 	stw	r2,0(r16)
  220b04:	80c00215 	stw	r3,8(r16)
  220b08:	9005883a 	mov	r2,r18
  220b0c:	003f7906 	br	2208f4 <__alt_data_end+0xfffed074>
  220b10:	e009883a 	mov	r4,fp
  220b14:	01400284 	movi	r5,10
  220b18:	900d883a 	mov	r6,r18
  220b1c:	02213b80 	call	2213b8 <memchr>
  220b20:	10003826 	beq	r2,zero,220c04 <__sfvwrite_r+0x498>
  220b24:	10800044 	addi	r2,r2,1
  220b28:	1729c83a 	sub	r20,r2,fp
  220b2c:	02000044 	movi	r8,1
  220b30:	003f8f06 	br	220970 <__alt_data_end+0xfffed0f0>
  220b34:	80800517 	ldw	r2,20(r16)
  220b38:	81400417 	ldw	r5,16(r16)
  220b3c:	87000017 	ldw	fp,0(r16)
  220b40:	10a9883a 	add	r20,r2,r2
  220b44:	a085883a 	add	r2,r20,r2
  220b48:	1028d7fa 	srli	r20,r2,31
  220b4c:	e179c83a 	sub	fp,fp,r5
  220b50:	e1000044 	addi	r4,fp,1
  220b54:	a085883a 	add	r2,r20,r2
  220b58:	1029d07a 	srai	r20,r2,1
  220b5c:	2485883a 	add	r2,r4,r18
  220b60:	a00d883a 	mov	r6,r20
  220b64:	a080022e 	bgeu	r20,r2,220b70 <__sfvwrite_r+0x404>
  220b68:	1029883a 	mov	r20,r2
  220b6c:	100d883a 	mov	r6,r2
  220b70:	18c1000c 	andi	r3,r3,1024
  220b74:	a809883a 	mov	r4,r21
  220b78:	183f6a26 	beq	r3,zero,220924 <__alt_data_end+0xfffed0a4>
  220b7c:	300b883a 	mov	r5,r6
  220b80:	0220c100 	call	220c10 <_malloc_r>
  220b84:	102d883a 	mov	r22,r2
  220b88:	103f6c26 	beq	r2,zero,22093c <__alt_data_end+0xfffed0bc>
  220b8c:	81400417 	ldw	r5,16(r16)
  220b90:	1009883a 	mov	r4,r2
  220b94:	e00d883a 	mov	r6,fp
  220b98:	02214a00 	call	2214a0 <memcpy>
  220b9c:	8080030b 	ldhu	r2,12(r16)
  220ba0:	00fedfc4 	movi	r3,-1153
  220ba4:	10c4703a 	and	r2,r2,r3
  220ba8:	10802014 	ori	r2,r2,128
  220bac:	8080030d 	sth	r2,12(r16)
  220bb0:	b709883a 	add	r4,r22,fp
  220bb4:	a707c83a 	sub	r3,r20,fp
  220bb8:	85800415 	stw	r22,16(r16)
  220bbc:	85000515 	stw	r20,20(r16)
  220bc0:	81000015 	stw	r4,0(r16)
  220bc4:	9039883a 	mov	fp,r18
  220bc8:	80c00215 	stw	r3,8(r16)
  220bcc:	9029883a 	mov	r20,r18
  220bd0:	902d883a 	mov	r22,r18
  220bd4:	003f3d06 	br	2208cc <__alt_data_end+0xfffed04c>
  220bd8:	b80b883a 	mov	r5,r23
  220bdc:	a00d883a 	mov	r6,r20
  220be0:	02215d80 	call	2215d8 <memmove>
  220be4:	80800017 	ldw	r2,0(r16)
  220be8:	a809883a 	mov	r4,r21
  220bec:	800b883a 	mov	r5,r16
  220bf0:	1505883a 	add	r2,r2,r20
  220bf4:	80800015 	stw	r2,0(r16)
  220bf8:	0221e580 	call	221e58 <_fflush_r>
  220bfc:	103fa526 	beq	r2,zero,220a94 <__alt_data_end+0xfffed214>
  220c00:	003f5006 	br	220944 <__alt_data_end+0xfffed0c4>
  220c04:	95000044 	addi	r20,r18,1
  220c08:	02000044 	movi	r8,1
  220c0c:	003f5806 	br	220970 <__alt_data_end+0xfffed0f0>

00220c10 <_malloc_r>:
  220c10:	defff504 	addi	sp,sp,-44
  220c14:	dc800315 	stw	r18,12(sp)
  220c18:	dfc00a15 	stw	ra,40(sp)
  220c1c:	df000915 	stw	fp,36(sp)
  220c20:	ddc00815 	stw	r23,32(sp)
  220c24:	dd800715 	stw	r22,28(sp)
  220c28:	dd400615 	stw	r21,24(sp)
  220c2c:	dd000515 	stw	r20,20(sp)
  220c30:	dcc00415 	stw	r19,16(sp)
  220c34:	dc400215 	stw	r17,8(sp)
  220c38:	dc000115 	stw	r16,4(sp)
  220c3c:	288002c4 	addi	r2,r5,11
  220c40:	00c00584 	movi	r3,22
  220c44:	2025883a 	mov	r18,r4
  220c48:	18802a2e 	bgeu	r3,r2,220cf4 <_malloc_r+0xe4>
  220c4c:	047ffe04 	movi	r17,-8
  220c50:	1462703a 	and	r17,r2,r17
  220c54:	88009e16 	blt	r17,zero,220ed0 <_malloc_r+0x2c0>
  220c58:	89409d36 	bltu	r17,r5,220ed0 <_malloc_r+0x2c0>
  220c5c:	02236d40 	call	2236d4 <__malloc_lock>
  220c60:	00807dc4 	movi	r2,503
  220c64:	14402736 	bltu	r2,r17,220d04 <_malloc_r+0xf4>
  220c68:	8806d0fa 	srli	r3,r17,3
  220c6c:	04c008b4 	movhi	r19,34
  220c70:	9cdd0804 	addi	r19,r19,29728
  220c74:	18c5883a 	add	r2,r3,r3
  220c78:	1085883a 	add	r2,r2,r2
  220c7c:	1085883a 	add	r2,r2,r2
  220c80:	9885883a 	add	r2,r19,r2
  220c84:	14000317 	ldw	r16,12(r2)
  220c88:	80814a26 	beq	r16,r2,2211b4 <_malloc_r+0x5a4>
  220c8c:	80c00117 	ldw	r3,4(r16)
  220c90:	81000317 	ldw	r4,12(r16)
  220c94:	00bfff04 	movi	r2,-4
  220c98:	1884703a 	and	r2,r3,r2
  220c9c:	81400217 	ldw	r5,8(r16)
  220ca0:	8085883a 	add	r2,r16,r2
  220ca4:	10c00117 	ldw	r3,4(r2)
  220ca8:	29000315 	stw	r4,12(r5)
  220cac:	21400215 	stw	r5,8(r4)
  220cb0:	18c00054 	ori	r3,r3,1
  220cb4:	10c00115 	stw	r3,4(r2)
  220cb8:	9009883a 	mov	r4,r18
  220cbc:	02236f40 	call	2236f4 <__malloc_unlock>
  220cc0:	80800204 	addi	r2,r16,8
  220cc4:	dfc00a17 	ldw	ra,40(sp)
  220cc8:	df000917 	ldw	fp,36(sp)
  220ccc:	ddc00817 	ldw	r23,32(sp)
  220cd0:	dd800717 	ldw	r22,28(sp)
  220cd4:	dd400617 	ldw	r21,24(sp)
  220cd8:	dd000517 	ldw	r20,20(sp)
  220cdc:	dcc00417 	ldw	r19,16(sp)
  220ce0:	dc800317 	ldw	r18,12(sp)
  220ce4:	dc400217 	ldw	r17,8(sp)
  220ce8:	dc000117 	ldw	r16,4(sp)
  220cec:	dec00b04 	addi	sp,sp,44
  220cf0:	f800283a 	ret
  220cf4:	04400404 	movi	r17,16
  220cf8:	89407536 	bltu	r17,r5,220ed0 <_malloc_r+0x2c0>
  220cfc:	02236d40 	call	2236d4 <__malloc_lock>
  220d00:	003fd906 	br	220c68 <__alt_data_end+0xfffed3e8>
  220d04:	8806d27a 	srli	r3,r17,9
  220d08:	18007526 	beq	r3,zero,220ee0 <_malloc_r+0x2d0>
  220d0c:	00800104 	movi	r2,4
  220d10:	10c0ef36 	bltu	r2,r3,2210d0 <_malloc_r+0x4c0>
  220d14:	8806d1ba 	srli	r3,r17,6
  220d18:	19c00e04 	addi	r7,r3,56
  220d1c:	39cb883a 	add	r5,r7,r7
  220d20:	04c008b4 	movhi	r19,34
  220d24:	294b883a 	add	r5,r5,r5
  220d28:	9cdd0804 	addi	r19,r19,29728
  220d2c:	294b883a 	add	r5,r5,r5
  220d30:	994b883a 	add	r5,r19,r5
  220d34:	2c000317 	ldw	r16,12(r5)
  220d38:	2c000e26 	beq	r5,r16,220d74 <_malloc_r+0x164>
  220d3c:	80800117 	ldw	r2,4(r16)
  220d40:	01bfff04 	movi	r6,-4
  220d44:	010003c4 	movi	r4,15
  220d48:	1184703a 	and	r2,r2,r6
  220d4c:	1447c83a 	sub	r3,r2,r17
  220d50:	20c00716 	blt	r4,r3,220d70 <_malloc_r+0x160>
  220d54:	1800650e 	bge	r3,zero,220eec <_malloc_r+0x2dc>
  220d58:	84000317 	ldw	r16,12(r16)
  220d5c:	2c000526 	beq	r5,r16,220d74 <_malloc_r+0x164>
  220d60:	80800117 	ldw	r2,4(r16)
  220d64:	1184703a 	and	r2,r2,r6
  220d68:	1447c83a 	sub	r3,r2,r17
  220d6c:	20fff90e 	bge	r4,r3,220d54 <__alt_data_end+0xfffed4d4>
  220d70:	39ffffc4 	addi	r7,r7,-1
  220d74:	38c00044 	addi	r3,r7,1
  220d78:	018008b4 	movhi	r6,34
  220d7c:	9c000417 	ldw	r16,16(r19)
  220d80:	319d0804 	addi	r6,r6,29728
  220d84:	32400204 	addi	r9,r6,8
  220d88:	82410326 	beq	r16,r9,221198 <_malloc_r+0x588>
  220d8c:	81000117 	ldw	r4,4(r16)
  220d90:	00bfff04 	movi	r2,-4
  220d94:	208e703a 	and	r7,r4,r2
  220d98:	3c45c83a 	sub	r2,r7,r17
  220d9c:	010003c4 	movi	r4,15
  220da0:	2080ee16 	blt	r4,r2,22115c <_malloc_r+0x54c>
  220da4:	32400515 	stw	r9,20(r6)
  220da8:	32400415 	stw	r9,16(r6)
  220dac:	1000510e 	bge	r2,zero,220ef4 <_malloc_r+0x2e4>
  220db0:	00807fc4 	movi	r2,511
  220db4:	11c0ce36 	bltu	r2,r7,2210f0 <_malloc_r+0x4e0>
  220db8:	3808d0fa 	srli	r4,r7,3
  220dbc:	01c00044 	movi	r7,1
  220dc0:	30800117 	ldw	r2,4(r6)
  220dc4:	210b883a 	add	r5,r4,r4
  220dc8:	294b883a 	add	r5,r5,r5
  220dcc:	2009d0ba 	srai	r4,r4,2
  220dd0:	294b883a 	add	r5,r5,r5
  220dd4:	298b883a 	add	r5,r5,r6
  220dd8:	2a000217 	ldw	r8,8(r5)
  220ddc:	3908983a 	sll	r4,r7,r4
  220de0:	81400315 	stw	r5,12(r16)
  220de4:	82000215 	stw	r8,8(r16)
  220de8:	2088b03a 	or	r4,r4,r2
  220dec:	2c000215 	stw	r16,8(r5)
  220df0:	31000115 	stw	r4,4(r6)
  220df4:	44000315 	stw	r16,12(r8)
  220df8:	1805d0ba 	srai	r2,r3,2
  220dfc:	01400044 	movi	r5,1
  220e00:	288a983a 	sll	r5,r5,r2
  220e04:	21404336 	bltu	r4,r5,220f14 <_malloc_r+0x304>
  220e08:	2144703a 	and	r2,r4,r5
  220e0c:	10000a1e 	bne	r2,zero,220e38 <_malloc_r+0x228>
  220e10:	00bfff04 	movi	r2,-4
  220e14:	294b883a 	add	r5,r5,r5
  220e18:	1886703a 	and	r3,r3,r2
  220e1c:	2144703a 	and	r2,r4,r5
  220e20:	18c00104 	addi	r3,r3,4
  220e24:	1000041e 	bne	r2,zero,220e38 <_malloc_r+0x228>
  220e28:	294b883a 	add	r5,r5,r5
  220e2c:	2144703a 	and	r2,r4,r5
  220e30:	18c00104 	addi	r3,r3,4
  220e34:	103ffc26 	beq	r2,zero,220e28 <__alt_data_end+0xfffed5a8>
  220e38:	023fff04 	movi	r8,-4
  220e3c:	01c003c4 	movi	r7,15
  220e40:	18c5883a 	add	r2,r3,r3
  220e44:	1085883a 	add	r2,r2,r2
  220e48:	1085883a 	add	r2,r2,r2
  220e4c:	9895883a 	add	r10,r19,r2
  220e50:	52c00304 	addi	r11,r10,12
  220e54:	1819883a 	mov	r12,r3
  220e58:	5c000017 	ldw	r16,0(r11)
  220e5c:	59bffd04 	addi	r6,r11,-12
  220e60:	8180041e 	bne	r16,r6,220e74 <_malloc_r+0x264>
  220e64:	0000ce06 	br	2211a0 <_malloc_r+0x590>
  220e68:	2000d70e 	bge	r4,zero,2211c8 <_malloc_r+0x5b8>
  220e6c:	84000317 	ldw	r16,12(r16)
  220e70:	8180cb26 	beq	r16,r6,2211a0 <_malloc_r+0x590>
  220e74:	80800117 	ldw	r2,4(r16)
  220e78:	1204703a 	and	r2,r2,r8
  220e7c:	1449c83a 	sub	r4,r2,r17
  220e80:	393ff90e 	bge	r7,r4,220e68 <__alt_data_end+0xfffed5e8>
  220e84:	80800317 	ldw	r2,12(r16)
  220e88:	80c00217 	ldw	r3,8(r16)
  220e8c:	89400054 	ori	r5,r17,1
  220e90:	81400115 	stw	r5,4(r16)
  220e94:	18800315 	stw	r2,12(r3)
  220e98:	10c00215 	stw	r3,8(r2)
  220e9c:	8463883a 	add	r17,r16,r17
  220ea0:	9c400515 	stw	r17,20(r19)
  220ea4:	9c400415 	stw	r17,16(r19)
  220ea8:	20800054 	ori	r2,r4,1
  220eac:	88800115 	stw	r2,4(r17)
  220eb0:	8a400315 	stw	r9,12(r17)
  220eb4:	8a400215 	stw	r9,8(r17)
  220eb8:	8923883a 	add	r17,r17,r4
  220ebc:	89000015 	stw	r4,0(r17)
  220ec0:	9009883a 	mov	r4,r18
  220ec4:	02236f40 	call	2236f4 <__malloc_unlock>
  220ec8:	80800204 	addi	r2,r16,8
  220ecc:	003f7d06 	br	220cc4 <__alt_data_end+0xfffed444>
  220ed0:	00800304 	movi	r2,12
  220ed4:	90800015 	stw	r2,0(r18)
  220ed8:	0005883a 	mov	r2,zero
  220edc:	003f7906 	br	220cc4 <__alt_data_end+0xfffed444>
  220ee0:	01401f84 	movi	r5,126
  220ee4:	01c00fc4 	movi	r7,63
  220ee8:	003f8d06 	br	220d20 <__alt_data_end+0xfffed4a0>
  220eec:	81000317 	ldw	r4,12(r16)
  220ef0:	003f6a06 	br	220c9c <__alt_data_end+0xfffed41c>
  220ef4:	81c5883a 	add	r2,r16,r7
  220ef8:	10c00117 	ldw	r3,4(r2)
  220efc:	9009883a 	mov	r4,r18
  220f00:	18c00054 	ori	r3,r3,1
  220f04:	10c00115 	stw	r3,4(r2)
  220f08:	02236f40 	call	2236f4 <__malloc_unlock>
  220f0c:	80800204 	addi	r2,r16,8
  220f10:	003f6c06 	br	220cc4 <__alt_data_end+0xfffed444>
  220f14:	9c000217 	ldw	r16,8(r19)
  220f18:	00bfff04 	movi	r2,-4
  220f1c:	85800117 	ldw	r22,4(r16)
  220f20:	b0ac703a 	and	r22,r22,r2
  220f24:	b4400336 	bltu	r22,r17,220f34 <_malloc_r+0x324>
  220f28:	b445c83a 	sub	r2,r22,r17
  220f2c:	00c003c4 	movi	r3,15
  220f30:	18805d16 	blt	r3,r2,2210a8 <_malloc_r+0x498>
  220f34:	05c008f4 	movhi	r23,35
  220f38:	008008f4 	movhi	r2,35
  220f3c:	bde2d504 	addi	r23,r23,-29868
  220f40:	10a9c904 	addi	r2,r2,-22748
  220f44:	15400017 	ldw	r21,0(r2)
  220f48:	b9000017 	ldw	r4,0(r23)
  220f4c:	00ffffc4 	movi	r3,-1
  220f50:	858d883a 	add	r6,r16,r22
  220f54:	8d6b883a 	add	r21,r17,r21
  220f58:	20c0e426 	beq	r4,r3,2212ec <_malloc_r+0x6dc>
  220f5c:	ad4403c4 	addi	r21,r21,4111
  220f60:	00fc0004 	movi	r3,-4096
  220f64:	a8ea703a 	and	r21,r21,r3
  220f68:	9009883a 	mov	r4,r18
  220f6c:	a80b883a 	mov	r5,r21
  220f70:	d9800015 	stw	r6,0(sp)
  220f74:	0221cd40 	call	221cd4 <_sbrk_r>
  220f78:	00ffffc4 	movi	r3,-1
  220f7c:	1029883a 	mov	r20,r2
  220f80:	d9800017 	ldw	r6,0(sp)
  220f84:	10c0a426 	beq	r2,r3,221218 <_malloc_r+0x608>
  220f88:	1180a236 	bltu	r2,r6,221214 <_malloc_r+0x604>
  220f8c:	070008f4 	movhi	fp,35
  220f90:	e729d204 	addi	fp,fp,-22712
  220f94:	e0c00017 	ldw	r3,0(fp)
  220f98:	a8c7883a 	add	r3,r21,r3
  220f9c:	e0c00015 	stw	r3,0(fp)
  220fa0:	3500da26 	beq	r6,r20,22130c <_malloc_r+0x6fc>
  220fa4:	b9000017 	ldw	r4,0(r23)
  220fa8:	00bfffc4 	movi	r2,-1
  220fac:	2080e426 	beq	r4,r2,221340 <_malloc_r+0x730>
  220fb0:	a185c83a 	sub	r2,r20,r6
  220fb4:	1885883a 	add	r2,r3,r2
  220fb8:	e0800015 	stw	r2,0(fp)
  220fbc:	a0c001cc 	andi	r3,r20,7
  220fc0:	1800b526 	beq	r3,zero,221298 <_malloc_r+0x688>
  220fc4:	a0e9c83a 	sub	r20,r20,r3
  220fc8:	00840204 	movi	r2,4104
  220fcc:	a5000204 	addi	r20,r20,8
  220fd0:	10c7c83a 	sub	r3,r2,r3
  220fd4:	a545883a 	add	r2,r20,r21
  220fd8:	1083ffcc 	andi	r2,r2,4095
  220fdc:	18abc83a 	sub	r21,r3,r2
  220fe0:	9009883a 	mov	r4,r18
  220fe4:	a80b883a 	mov	r5,r21
  220fe8:	0221cd40 	call	221cd4 <_sbrk_r>
  220fec:	00ffffc4 	movi	r3,-1
  220ff0:	10c0d026 	beq	r2,r3,221334 <_malloc_r+0x724>
  220ff4:	1507c83a 	sub	r3,r2,r20
  220ff8:	a8c7883a 	add	r3,r21,r3
  220ffc:	18c00054 	ori	r3,r3,1
  221000:	e0800017 	ldw	r2,0(fp)
  221004:	9d000215 	stw	r20,8(r19)
  221008:	a0c00115 	stw	r3,4(r20)
  22100c:	a887883a 	add	r3,r21,r2
  221010:	e0c00015 	stw	r3,0(fp)
  221014:	84c00e26 	beq	r16,r19,221050 <_malloc_r+0x440>
  221018:	018003c4 	movi	r6,15
  22101c:	3580a02e 	bgeu	r6,r22,2212a0 <_malloc_r+0x690>
  221020:	81400117 	ldw	r5,4(r16)
  221024:	013ffe04 	movi	r4,-8
  221028:	b0bffd04 	addi	r2,r22,-12
  22102c:	1104703a 	and	r2,r2,r4
  221030:	2900004c 	andi	r4,r5,1
  221034:	1108b03a 	or	r4,r2,r4
  221038:	81000115 	stw	r4,4(r16)
  22103c:	01400144 	movi	r5,5
  221040:	8089883a 	add	r4,r16,r2
  221044:	21400115 	stw	r5,4(r4)
  221048:	21400215 	stw	r5,8(r4)
  22104c:	3080c036 	bltu	r6,r2,221350 <_malloc_r+0x740>
  221050:	008008f4 	movhi	r2,35
  221054:	10a9c804 	addi	r2,r2,-22752
  221058:	11000017 	ldw	r4,0(r2)
  22105c:	20c0012e 	bgeu	r4,r3,221064 <_malloc_r+0x454>
  221060:	10c00015 	stw	r3,0(r2)
  221064:	008008f4 	movhi	r2,35
  221068:	10a9c704 	addi	r2,r2,-22756
  22106c:	11000017 	ldw	r4,0(r2)
  221070:	9c000217 	ldw	r16,8(r19)
  221074:	20c0012e 	bgeu	r4,r3,22107c <_malloc_r+0x46c>
  221078:	10c00015 	stw	r3,0(r2)
  22107c:	80c00117 	ldw	r3,4(r16)
  221080:	00bfff04 	movi	r2,-4
  221084:	1886703a 	and	r3,r3,r2
  221088:	1c45c83a 	sub	r2,r3,r17
  22108c:	1c400236 	bltu	r3,r17,221098 <_malloc_r+0x488>
  221090:	00c003c4 	movi	r3,15
  221094:	18800416 	blt	r3,r2,2210a8 <_malloc_r+0x498>
  221098:	9009883a 	mov	r4,r18
  22109c:	02236f40 	call	2236f4 <__malloc_unlock>
  2210a0:	0005883a 	mov	r2,zero
  2210a4:	003f0706 	br	220cc4 <__alt_data_end+0xfffed444>
  2210a8:	88c00054 	ori	r3,r17,1
  2210ac:	80c00115 	stw	r3,4(r16)
  2210b0:	8463883a 	add	r17,r16,r17
  2210b4:	10800054 	ori	r2,r2,1
  2210b8:	9c400215 	stw	r17,8(r19)
  2210bc:	88800115 	stw	r2,4(r17)
  2210c0:	9009883a 	mov	r4,r18
  2210c4:	02236f40 	call	2236f4 <__malloc_unlock>
  2210c8:	80800204 	addi	r2,r16,8
  2210cc:	003efd06 	br	220cc4 <__alt_data_end+0xfffed444>
  2210d0:	00800504 	movi	r2,20
  2210d4:	10c0482e 	bgeu	r2,r3,2211f8 <_malloc_r+0x5e8>
  2210d8:	00801504 	movi	r2,84
  2210dc:	10c06836 	bltu	r2,r3,221280 <_malloc_r+0x670>
  2210e0:	8806d33a 	srli	r3,r17,12
  2210e4:	19c01b84 	addi	r7,r3,110
  2210e8:	39cb883a 	add	r5,r7,r7
  2210ec:	003f0c06 	br	220d20 <__alt_data_end+0xfffed4a0>
  2210f0:	3804d27a 	srli	r2,r7,9
  2210f4:	01000104 	movi	r4,4
  2210f8:	2080422e 	bgeu	r4,r2,221204 <_malloc_r+0x5f4>
  2210fc:	01000504 	movi	r4,20
  221100:	20807c36 	bltu	r4,r2,2212f4 <_malloc_r+0x6e4>
  221104:	110016c4 	addi	r4,r2,91
  221108:	210b883a 	add	r5,r4,r4
  22110c:	294b883a 	add	r5,r5,r5
  221110:	294b883a 	add	r5,r5,r5
  221114:	994b883a 	add	r5,r19,r5
  221118:	28800217 	ldw	r2,8(r5)
  22111c:	020008b4 	movhi	r8,34
  221120:	421d0804 	addi	r8,r8,29728
  221124:	11406326 	beq	r2,r5,2212b4 <_malloc_r+0x6a4>
  221128:	01bfff04 	movi	r6,-4
  22112c:	11000117 	ldw	r4,4(r2)
  221130:	2188703a 	and	r4,r4,r6
  221134:	3900022e 	bgeu	r7,r4,221140 <_malloc_r+0x530>
  221138:	10800217 	ldw	r2,8(r2)
  22113c:	28bffb1e 	bne	r5,r2,22112c <__alt_data_end+0xfffed8ac>
  221140:	11800317 	ldw	r6,12(r2)
  221144:	99000117 	ldw	r4,4(r19)
  221148:	81800315 	stw	r6,12(r16)
  22114c:	80800215 	stw	r2,8(r16)
  221150:	34000215 	stw	r16,8(r6)
  221154:	14000315 	stw	r16,12(r2)
  221158:	003f2706 	br	220df8 <__alt_data_end+0xfffed578>
  22115c:	88c00054 	ori	r3,r17,1
  221160:	80c00115 	stw	r3,4(r16)
  221164:	8463883a 	add	r17,r16,r17
  221168:	34400515 	stw	r17,20(r6)
  22116c:	34400415 	stw	r17,16(r6)
  221170:	10c00054 	ori	r3,r2,1
  221174:	8a400315 	stw	r9,12(r17)
  221178:	8a400215 	stw	r9,8(r17)
  22117c:	88c00115 	stw	r3,4(r17)
  221180:	88a3883a 	add	r17,r17,r2
  221184:	88800015 	stw	r2,0(r17)
  221188:	9009883a 	mov	r4,r18
  22118c:	02236f40 	call	2236f4 <__malloc_unlock>
  221190:	80800204 	addi	r2,r16,8
  221194:	003ecb06 	br	220cc4 <__alt_data_end+0xfffed444>
  221198:	31000117 	ldw	r4,4(r6)
  22119c:	003f1606 	br	220df8 <__alt_data_end+0xfffed578>
  2211a0:	63000044 	addi	r12,r12,1
  2211a4:	608000cc 	andi	r2,r12,3
  2211a8:	5ac00204 	addi	r11,r11,8
  2211ac:	103f2a1e 	bne	r2,zero,220e58 <__alt_data_end+0xfffed5d8>
  2211b0:	00002106 	br	221238 <_malloc_r+0x628>
  2211b4:	80800204 	addi	r2,r16,8
  2211b8:	84000517 	ldw	r16,20(r16)
  2211bc:	143eb31e 	bne	r2,r16,220c8c <__alt_data_end+0xfffed40c>
  2211c0:	18c00084 	addi	r3,r3,2
  2211c4:	003eec06 	br	220d78 <__alt_data_end+0xfffed4f8>
  2211c8:	8085883a 	add	r2,r16,r2
  2211cc:	10c00117 	ldw	r3,4(r2)
  2211d0:	81000317 	ldw	r4,12(r16)
  2211d4:	81400217 	ldw	r5,8(r16)
  2211d8:	18c00054 	ori	r3,r3,1
  2211dc:	10c00115 	stw	r3,4(r2)
  2211e0:	29000315 	stw	r4,12(r5)
  2211e4:	21400215 	stw	r5,8(r4)
  2211e8:	9009883a 	mov	r4,r18
  2211ec:	02236f40 	call	2236f4 <__malloc_unlock>
  2211f0:	80800204 	addi	r2,r16,8
  2211f4:	003eb306 	br	220cc4 <__alt_data_end+0xfffed444>
  2211f8:	19c016c4 	addi	r7,r3,91
  2211fc:	39cb883a 	add	r5,r7,r7
  221200:	003ec706 	br	220d20 <__alt_data_end+0xfffed4a0>
  221204:	3804d1ba 	srli	r2,r7,6
  221208:	11000e04 	addi	r4,r2,56
  22120c:	210b883a 	add	r5,r4,r4
  221210:	003fbe06 	br	22110c <__alt_data_end+0xfffed88c>
  221214:	84ff5d26 	beq	r16,r19,220f8c <__alt_data_end+0xfffed70c>
  221218:	9c000217 	ldw	r16,8(r19)
  22121c:	00bfff04 	movi	r2,-4
  221220:	80c00117 	ldw	r3,4(r16)
  221224:	1886703a 	and	r3,r3,r2
  221228:	003f9706 	br	221088 <__alt_data_end+0xfffed808>
  22122c:	52800017 	ldw	r10,0(r10)
  221230:	18ffffc4 	addi	r3,r3,-1
  221234:	50805c1e 	bne	r10,r2,2213a8 <_malloc_r+0x798>
  221238:	190000cc 	andi	r4,r3,3
  22123c:	50bffe04 	addi	r2,r10,-8
  221240:	203ffa1e 	bne	r4,zero,22122c <__alt_data_end+0xfffed9ac>
  221244:	98800117 	ldw	r2,4(r19)
  221248:	0146303a 	nor	r3,zero,r5
  22124c:	1884703a 	and	r2,r3,r2
  221250:	98800115 	stw	r2,4(r19)
  221254:	294b883a 	add	r5,r5,r5
  221258:	117f2e36 	bltu	r2,r5,220f14 <__alt_data_end+0xfffed694>
  22125c:	283f2d26 	beq	r5,zero,220f14 <__alt_data_end+0xfffed694>
  221260:	1146703a 	and	r3,r2,r5
  221264:	1800521e 	bne	r3,zero,2213b0 <_malloc_r+0x7a0>
  221268:	6007883a 	mov	r3,r12
  22126c:	294b883a 	add	r5,r5,r5
  221270:	1148703a 	and	r4,r2,r5
  221274:	18c00104 	addi	r3,r3,4
  221278:	203ffc26 	beq	r4,zero,22126c <__alt_data_end+0xfffed9ec>
  22127c:	003ef006 	br	220e40 <__alt_data_end+0xfffed5c0>
  221280:	00805504 	movi	r2,340
  221284:	10c01336 	bltu	r2,r3,2212d4 <_malloc_r+0x6c4>
  221288:	8806d3fa 	srli	r3,r17,15
  22128c:	19c01dc4 	addi	r7,r3,119
  221290:	39cb883a 	add	r5,r7,r7
  221294:	003ea206 	br	220d20 <__alt_data_end+0xfffed4a0>
  221298:	00c40004 	movi	r3,4096
  22129c:	003f4d06 	br	220fd4 <__alt_data_end+0xfffed754>
  2212a0:	00800044 	movi	r2,1
  2212a4:	a0800115 	stw	r2,4(r20)
  2212a8:	a021883a 	mov	r16,r20
  2212ac:	0007883a 	mov	r3,zero
  2212b0:	003f7506 	br	221088 <__alt_data_end+0xfffed808>
  2212b4:	200bd0ba 	srai	r5,r4,2
  2212b8:	01800044 	movi	r6,1
  2212bc:	41000117 	ldw	r4,4(r8)
  2212c0:	314a983a 	sll	r5,r6,r5
  2212c4:	100d883a 	mov	r6,r2
  2212c8:	2908b03a 	or	r4,r5,r4
  2212cc:	41000115 	stw	r4,4(r8)
  2212d0:	003f9d06 	br	221148 <__alt_data_end+0xfffed8c8>
  2212d4:	00815504 	movi	r2,1364
  2212d8:	10c01336 	bltu	r2,r3,221328 <_malloc_r+0x718>
  2212dc:	8806d4ba 	srli	r3,r17,18
  2212e0:	19c01f04 	addi	r7,r3,124
  2212e4:	39cb883a 	add	r5,r7,r7
  2212e8:	003e8d06 	br	220d20 <__alt_data_end+0xfffed4a0>
  2212ec:	ad400404 	addi	r21,r21,16
  2212f0:	003f1d06 	br	220f68 <__alt_data_end+0xfffed6e8>
  2212f4:	01001504 	movi	r4,84
  2212f8:	20801c36 	bltu	r4,r2,22136c <_malloc_r+0x75c>
  2212fc:	3804d33a 	srli	r2,r7,12
  221300:	11001b84 	addi	r4,r2,110
  221304:	210b883a 	add	r5,r4,r4
  221308:	003f8006 	br	22110c <__alt_data_end+0xfffed88c>
  22130c:	3083ffcc 	andi	r2,r6,4095
  221310:	103f241e 	bne	r2,zero,220fa4 <__alt_data_end+0xfffed724>
  221314:	99000217 	ldw	r4,8(r19)
  221318:	ad85883a 	add	r2,r21,r22
  22131c:	10800054 	ori	r2,r2,1
  221320:	20800115 	stw	r2,4(r4)
  221324:	003f4a06 	br	221050 <__alt_data_end+0xfffed7d0>
  221328:	01403f04 	movi	r5,252
  22132c:	01c01f84 	movi	r7,126
  221330:	003e7b06 	br	220d20 <__alt_data_end+0xfffed4a0>
  221334:	00c00044 	movi	r3,1
  221338:	002b883a 	mov	r21,zero
  22133c:	003f3006 	br	221000 <__alt_data_end+0xfffed780>
  221340:	008008f4 	movhi	r2,35
  221344:	10a2d504 	addi	r2,r2,-29868
  221348:	15000015 	stw	r20,0(r2)
  22134c:	003f1b06 	br	220fbc <__alt_data_end+0xfffed73c>
  221350:	9009883a 	mov	r4,r18
  221354:	81400204 	addi	r5,r16,8
  221358:	02225740 	call	222574 <_free_r>
  22135c:	008008f4 	movhi	r2,35
  221360:	10a9d204 	addi	r2,r2,-22712
  221364:	10c00017 	ldw	r3,0(r2)
  221368:	003f3906 	br	221050 <__alt_data_end+0xfffed7d0>
  22136c:	01005504 	movi	r4,340
  221370:	20800436 	bltu	r4,r2,221384 <_malloc_r+0x774>
  221374:	3804d3fa 	srli	r2,r7,15
  221378:	11001dc4 	addi	r4,r2,119
  22137c:	210b883a 	add	r5,r4,r4
  221380:	003f6206 	br	22110c <__alt_data_end+0xfffed88c>
  221384:	01015504 	movi	r4,1364
  221388:	20800436 	bltu	r4,r2,22139c <_malloc_r+0x78c>
  22138c:	3804d4ba 	srli	r2,r7,18
  221390:	11001f04 	addi	r4,r2,124
  221394:	210b883a 	add	r5,r4,r4
  221398:	003f5c06 	br	22110c <__alt_data_end+0xfffed88c>
  22139c:	01403f04 	movi	r5,252
  2213a0:	01001f84 	movi	r4,126
  2213a4:	003f5906 	br	22110c <__alt_data_end+0xfffed88c>
  2213a8:	98800117 	ldw	r2,4(r19)
  2213ac:	003fa906 	br	221254 <__alt_data_end+0xfffed9d4>
  2213b0:	6007883a 	mov	r3,r12
  2213b4:	003ea206 	br	220e40 <__alt_data_end+0xfffed5c0>

002213b8 <memchr>:
  2213b8:	208000cc 	andi	r2,r4,3
  2213bc:	280f883a 	mov	r7,r5
  2213c0:	10003526 	beq	r2,zero,221498 <memchr+0xe0>
  2213c4:	30bfffc4 	addi	r2,r6,-1
  2213c8:	30001b26 	beq	r6,zero,221438 <memchr+0x80>
  2213cc:	21800003 	ldbu	r6,0(r4)
  2213d0:	28c03fcc 	andi	r3,r5,255
  2213d4:	30c01a26 	beq	r6,r3,221440 <memchr+0x88>
  2213d8:	180d883a 	mov	r6,r3
  2213dc:	00000406 	br	2213f0 <memchr+0x38>
  2213e0:	10001526 	beq	r2,zero,221438 <memchr+0x80>
  2213e4:	20c00003 	ldbu	r3,0(r4)
  2213e8:	10bfffc4 	addi	r2,r2,-1
  2213ec:	19801426 	beq	r3,r6,221440 <memchr+0x88>
  2213f0:	21000044 	addi	r4,r4,1
  2213f4:	20c000cc 	andi	r3,r4,3
  2213f8:	183ff91e 	bne	r3,zero,2213e0 <__alt_data_end+0xfffedb60>
  2213fc:	024000c4 	movi	r9,3
  221400:	48801136 	bltu	r9,r2,221448 <memchr+0x90>
  221404:	10000c26 	beq	r2,zero,221438 <memchr+0x80>
  221408:	20c00003 	ldbu	r3,0(r4)
  22140c:	29403fcc 	andi	r5,r5,255
  221410:	19400b26 	beq	r3,r5,221440 <memchr+0x88>
  221414:	20c00044 	addi	r3,r4,1
  221418:	2085883a 	add	r2,r4,r2
  22141c:	39803fcc 	andi	r6,r7,255
  221420:	00000306 	br	221430 <memchr+0x78>
  221424:	18c00044 	addi	r3,r3,1
  221428:	197fffc3 	ldbu	r5,-1(r3)
  22142c:	29800426 	beq	r5,r6,221440 <memchr+0x88>
  221430:	1809883a 	mov	r4,r3
  221434:	18bffb1e 	bne	r3,r2,221424 <__alt_data_end+0xfffedba4>
  221438:	0005883a 	mov	r2,zero
  22143c:	f800283a 	ret
  221440:	2005883a 	mov	r2,r4
  221444:	f800283a 	ret
  221448:	28c03fcc 	andi	r3,r5,255
  22144c:	1810923a 	slli	r8,r3,8
  221450:	02ffbff4 	movhi	r11,65279
  221454:	02a02074 	movhi	r10,32897
  221458:	40c6b03a 	or	r3,r8,r3
  22145c:	1810943a 	slli	r8,r3,16
  221460:	5affbfc4 	addi	r11,r11,-257
  221464:	52a02004 	addi	r10,r10,-32640
  221468:	40d0b03a 	or	r8,r8,r3
  22146c:	20c00017 	ldw	r3,0(r4)
  221470:	40c6f03a 	xor	r3,r8,r3
  221474:	1acd883a 	add	r6,r3,r11
  221478:	00c6303a 	nor	r3,zero,r3
  22147c:	30c6703a 	and	r3,r6,r3
  221480:	1a86703a 	and	r3,r3,r10
  221484:	183fdf1e 	bne	r3,zero,221404 <__alt_data_end+0xfffedb84>
  221488:	10bfff04 	addi	r2,r2,-4
  22148c:	21000104 	addi	r4,r4,4
  221490:	48bff636 	bltu	r9,r2,22146c <__alt_data_end+0xfffedbec>
  221494:	003fdb06 	br	221404 <__alt_data_end+0xfffedb84>
  221498:	3005883a 	mov	r2,r6
  22149c:	003fd706 	br	2213fc <__alt_data_end+0xfffedb7c>

002214a0 <memcpy>:
  2214a0:	deffff04 	addi	sp,sp,-4
  2214a4:	dc000015 	stw	r16,0(sp)
  2214a8:	00c003c4 	movi	r3,15
  2214ac:	2005883a 	mov	r2,r4
  2214b0:	1980432e 	bgeu	r3,r6,2215c0 <memcpy+0x120>
  2214b4:	2146b03a 	or	r3,r4,r5
  2214b8:	18c000cc 	andi	r3,r3,3
  2214bc:	1800421e 	bne	r3,zero,2215c8 <memcpy+0x128>
  2214c0:	343ffc04 	addi	r16,r6,-16
  2214c4:	8020d13a 	srli	r16,r16,4
  2214c8:	28c00104 	addi	r3,r5,4
  2214cc:	23400104 	addi	r13,r4,4
  2214d0:	801e913a 	slli	r15,r16,4
  2214d4:	2b000204 	addi	r12,r5,8
  2214d8:	22c00204 	addi	r11,r4,8
  2214dc:	7bc00504 	addi	r15,r15,20
  2214e0:	2a800304 	addi	r10,r5,12
  2214e4:	22400304 	addi	r9,r4,12
  2214e8:	2bdf883a 	add	r15,r5,r15
  2214ec:	2811883a 	mov	r8,r5
  2214f0:	200f883a 	mov	r7,r4
  2214f4:	41000017 	ldw	r4,0(r8)
  2214f8:	39c00404 	addi	r7,r7,16
  2214fc:	18c00404 	addi	r3,r3,16
  221500:	393ffc15 	stw	r4,-16(r7)
  221504:	1bbffc17 	ldw	r14,-16(r3)
  221508:	6b400404 	addi	r13,r13,16
  22150c:	5ac00404 	addi	r11,r11,16
  221510:	6bbffc15 	stw	r14,-16(r13)
  221514:	63800017 	ldw	r14,0(r12)
  221518:	4a400404 	addi	r9,r9,16
  22151c:	42000404 	addi	r8,r8,16
  221520:	5bbffc15 	stw	r14,-16(r11)
  221524:	53800017 	ldw	r14,0(r10)
  221528:	63000404 	addi	r12,r12,16
  22152c:	52800404 	addi	r10,r10,16
  221530:	4bbffc15 	stw	r14,-16(r9)
  221534:	1bffef1e 	bne	r3,r15,2214f4 <__alt_data_end+0xfffedc74>
  221538:	81c00044 	addi	r7,r16,1
  22153c:	380e913a 	slli	r7,r7,4
  221540:	310003cc 	andi	r4,r6,15
  221544:	02c000c4 	movi	r11,3
  221548:	11c7883a 	add	r3,r2,r7
  22154c:	29cb883a 	add	r5,r5,r7
  221550:	59001f2e 	bgeu	r11,r4,2215d0 <memcpy+0x130>
  221554:	1813883a 	mov	r9,r3
  221558:	2811883a 	mov	r8,r5
  22155c:	200f883a 	mov	r7,r4
  221560:	42800017 	ldw	r10,0(r8)
  221564:	4a400104 	addi	r9,r9,4
  221568:	39ffff04 	addi	r7,r7,-4
  22156c:	4abfff15 	stw	r10,-4(r9)
  221570:	42000104 	addi	r8,r8,4
  221574:	59fffa36 	bltu	r11,r7,221560 <__alt_data_end+0xfffedce0>
  221578:	213fff04 	addi	r4,r4,-4
  22157c:	2008d0ba 	srli	r4,r4,2
  221580:	318000cc 	andi	r6,r6,3
  221584:	21000044 	addi	r4,r4,1
  221588:	2109883a 	add	r4,r4,r4
  22158c:	2109883a 	add	r4,r4,r4
  221590:	1907883a 	add	r3,r3,r4
  221594:	290b883a 	add	r5,r5,r4
  221598:	30000626 	beq	r6,zero,2215b4 <memcpy+0x114>
  22159c:	198d883a 	add	r6,r3,r6
  2215a0:	29c00003 	ldbu	r7,0(r5)
  2215a4:	18c00044 	addi	r3,r3,1
  2215a8:	29400044 	addi	r5,r5,1
  2215ac:	19ffffc5 	stb	r7,-1(r3)
  2215b0:	19bffb1e 	bne	r3,r6,2215a0 <__alt_data_end+0xfffedd20>
  2215b4:	dc000017 	ldw	r16,0(sp)
  2215b8:	dec00104 	addi	sp,sp,4
  2215bc:	f800283a 	ret
  2215c0:	2007883a 	mov	r3,r4
  2215c4:	003ff406 	br	221598 <__alt_data_end+0xfffedd18>
  2215c8:	2007883a 	mov	r3,r4
  2215cc:	003ff306 	br	22159c <__alt_data_end+0xfffedd1c>
  2215d0:	200d883a 	mov	r6,r4
  2215d4:	003ff006 	br	221598 <__alt_data_end+0xfffedd18>

002215d8 <memmove>:
  2215d8:	2005883a 	mov	r2,r4
  2215dc:	29000b2e 	bgeu	r5,r4,22160c <memmove+0x34>
  2215e0:	298f883a 	add	r7,r5,r6
  2215e4:	21c0092e 	bgeu	r4,r7,22160c <memmove+0x34>
  2215e8:	2187883a 	add	r3,r4,r6
  2215ec:	198bc83a 	sub	r5,r3,r6
  2215f0:	30004b26 	beq	r6,zero,221720 <memmove+0x148>
  2215f4:	39ffffc4 	addi	r7,r7,-1
  2215f8:	39000003 	ldbu	r4,0(r7)
  2215fc:	18ffffc4 	addi	r3,r3,-1
  221600:	19000005 	stb	r4,0(r3)
  221604:	197ffb1e 	bne	r3,r5,2215f4 <__alt_data_end+0xfffedd74>
  221608:	f800283a 	ret
  22160c:	00c003c4 	movi	r3,15
  221610:	1980412e 	bgeu	r3,r6,221718 <memmove+0x140>
  221614:	1146b03a 	or	r3,r2,r5
  221618:	18c000cc 	andi	r3,r3,3
  22161c:	1800411e 	bne	r3,zero,221724 <memmove+0x14c>
  221620:	33fffc04 	addi	r15,r6,-16
  221624:	781ed13a 	srli	r15,r15,4
  221628:	28c00104 	addi	r3,r5,4
  22162c:	13400104 	addi	r13,r2,4
  221630:	781c913a 	slli	r14,r15,4
  221634:	2b000204 	addi	r12,r5,8
  221638:	12c00204 	addi	r11,r2,8
  22163c:	73800504 	addi	r14,r14,20
  221640:	2a800304 	addi	r10,r5,12
  221644:	12400304 	addi	r9,r2,12
  221648:	2b9d883a 	add	r14,r5,r14
  22164c:	2811883a 	mov	r8,r5
  221650:	100f883a 	mov	r7,r2
  221654:	41000017 	ldw	r4,0(r8)
  221658:	39c00404 	addi	r7,r7,16
  22165c:	18c00404 	addi	r3,r3,16
  221660:	393ffc15 	stw	r4,-16(r7)
  221664:	193ffc17 	ldw	r4,-16(r3)
  221668:	6b400404 	addi	r13,r13,16
  22166c:	5ac00404 	addi	r11,r11,16
  221670:	693ffc15 	stw	r4,-16(r13)
  221674:	61000017 	ldw	r4,0(r12)
  221678:	4a400404 	addi	r9,r9,16
  22167c:	42000404 	addi	r8,r8,16
  221680:	593ffc15 	stw	r4,-16(r11)
  221684:	51000017 	ldw	r4,0(r10)
  221688:	63000404 	addi	r12,r12,16
  22168c:	52800404 	addi	r10,r10,16
  221690:	493ffc15 	stw	r4,-16(r9)
  221694:	1bbfef1e 	bne	r3,r14,221654 <__alt_data_end+0xfffeddd4>
  221698:	79000044 	addi	r4,r15,1
  22169c:	2008913a 	slli	r4,r4,4
  2216a0:	328003cc 	andi	r10,r6,15
  2216a4:	02c000c4 	movi	r11,3
  2216a8:	1107883a 	add	r3,r2,r4
  2216ac:	290b883a 	add	r5,r5,r4
  2216b0:	5a801e2e 	bgeu	r11,r10,22172c <memmove+0x154>
  2216b4:	1813883a 	mov	r9,r3
  2216b8:	2811883a 	mov	r8,r5
  2216bc:	500f883a 	mov	r7,r10
  2216c0:	41000017 	ldw	r4,0(r8)
  2216c4:	4a400104 	addi	r9,r9,4
  2216c8:	39ffff04 	addi	r7,r7,-4
  2216cc:	493fff15 	stw	r4,-4(r9)
  2216d0:	42000104 	addi	r8,r8,4
  2216d4:	59fffa36 	bltu	r11,r7,2216c0 <__alt_data_end+0xfffede40>
  2216d8:	513fff04 	addi	r4,r10,-4
  2216dc:	2008d0ba 	srli	r4,r4,2
  2216e0:	318000cc 	andi	r6,r6,3
  2216e4:	21000044 	addi	r4,r4,1
  2216e8:	2109883a 	add	r4,r4,r4
  2216ec:	2109883a 	add	r4,r4,r4
  2216f0:	1907883a 	add	r3,r3,r4
  2216f4:	290b883a 	add	r5,r5,r4
  2216f8:	30000926 	beq	r6,zero,221720 <memmove+0x148>
  2216fc:	198d883a 	add	r6,r3,r6
  221700:	29c00003 	ldbu	r7,0(r5)
  221704:	18c00044 	addi	r3,r3,1
  221708:	29400044 	addi	r5,r5,1
  22170c:	19ffffc5 	stb	r7,-1(r3)
  221710:	19bffb1e 	bne	r3,r6,221700 <__alt_data_end+0xfffede80>
  221714:	f800283a 	ret
  221718:	1007883a 	mov	r3,r2
  22171c:	003ff606 	br	2216f8 <__alt_data_end+0xfffede78>
  221720:	f800283a 	ret
  221724:	1007883a 	mov	r3,r2
  221728:	003ff406 	br	2216fc <__alt_data_end+0xfffede7c>
  22172c:	500d883a 	mov	r6,r10
  221730:	003ff106 	br	2216f8 <__alt_data_end+0xfffede78>

00221734 <_realloc_r>:
  221734:	defff604 	addi	sp,sp,-40
  221738:	dcc00315 	stw	r19,12(sp)
  22173c:	dc400115 	stw	r17,4(sp)
  221740:	dfc00915 	stw	ra,36(sp)
  221744:	df000815 	stw	fp,32(sp)
  221748:	ddc00715 	stw	r23,28(sp)
  22174c:	dd800615 	stw	r22,24(sp)
  221750:	dd400515 	stw	r21,20(sp)
  221754:	dd000415 	stw	r20,16(sp)
  221758:	dc800215 	stw	r18,8(sp)
  22175c:	dc000015 	stw	r16,0(sp)
  221760:	2827883a 	mov	r19,r5
  221764:	3023883a 	mov	r17,r6
  221768:	2800bf26 	beq	r5,zero,221a68 <_realloc_r+0x334>
  22176c:	2025883a 	mov	r18,r4
  221770:	02236d40 	call	2236d4 <__malloc_lock>
  221774:	98ffff17 	ldw	r3,-4(r19)
  221778:	01bfff04 	movi	r6,-4
  22177c:	890002c4 	addi	r4,r17,11
  221780:	01c00584 	movi	r7,22
  221784:	9d7ffe04 	addi	r21,r19,-8
  221788:	19a0703a 	and	r16,r3,r6
  22178c:	39003f2e 	bgeu	r7,r4,22188c <_realloc_r+0x158>
  221790:	053ffe04 	movi	r20,-8
  221794:	2528703a 	and	r20,r4,r20
  221798:	a00f883a 	mov	r7,r20
  22179c:	a0008216 	blt	r20,zero,2219a8 <_realloc_r+0x274>
  2217a0:	a4408136 	bltu	r20,r17,2219a8 <_realloc_r+0x274>
  2217a4:	81c03c0e 	bge	r16,r7,221898 <_realloc_r+0x164>
  2217a8:	070008b4 	movhi	fp,34
  2217ac:	e71d0804 	addi	fp,fp,29728
  2217b0:	e1000217 	ldw	r4,8(fp)
  2217b4:	ac05883a 	add	r2,r21,r16
  2217b8:	2080bf26 	beq	r4,r2,221ab8 <_realloc_r+0x384>
  2217bc:	11000117 	ldw	r4,4(r2)
  2217c0:	023fff84 	movi	r8,-2
  2217c4:	2210703a 	and	r8,r4,r8
  2217c8:	1211883a 	add	r8,r2,r8
  2217cc:	41400117 	ldw	r5,4(r8)
  2217d0:	2940004c 	andi	r5,r5,1
  2217d4:	28004a1e 	bne	r5,zero,221900 <_realloc_r+0x1cc>
  2217d8:	017fff04 	movi	r5,-4
  2217dc:	2148703a 	and	r4,r4,r5
  2217e0:	2409883a 	add	r4,r4,r16
  2217e4:	21c0ad0e 	bge	r4,r7,221a9c <_realloc_r+0x368>
  2217e8:	18c0004c 	andi	r3,r3,1
  2217ec:	18007f1e 	bne	r3,zero,2219ec <_realloc_r+0x2b8>
  2217f0:	9dfffe17 	ldw	r23,-8(r19)
  2217f4:	adefc83a 	sub	r23,r21,r23
  2217f8:	bd800117 	ldw	r22,4(r23)
  2217fc:	b14a703a 	and	r5,r22,r5
  221800:	216d883a 	add	r22,r4,r5
  221804:	b1c04516 	blt	r22,r7,22191c <_realloc_r+0x1e8>
  221808:	10c00317 	ldw	r3,12(r2)
  22180c:	10800217 	ldw	r2,8(r2)
  221810:	81bfff04 	addi	r6,r16,-4
  221814:	bc400204 	addi	r17,r23,8
  221818:	10c00315 	stw	r3,12(r2)
  22181c:	18800215 	stw	r2,8(r3)
  221820:	b9400217 	ldw	r5,8(r23)
  221824:	b8c00317 	ldw	r3,12(r23)
  221828:	00800904 	movi	r2,36
  22182c:	28c00315 	stw	r3,12(r5)
  221830:	19400215 	stw	r5,8(r3)
  221834:	1180ef36 	bltu	r2,r6,221bf4 <_realloc_r+0x4c0>
  221838:	008004c4 	movi	r2,19
  22183c:	1180da2e 	bgeu	r2,r6,221ba8 <_realloc_r+0x474>
  221840:	98800017 	ldw	r2,0(r19)
  221844:	b8800215 	stw	r2,8(r23)
  221848:	98800117 	ldw	r2,4(r19)
  22184c:	b8800315 	stw	r2,12(r23)
  221850:	008006c4 	movi	r2,27
  221854:	1180fc2e 	bgeu	r2,r6,221c48 <_realloc_r+0x514>
  221858:	98800217 	ldw	r2,8(r19)
  22185c:	b8800415 	stw	r2,16(r23)
  221860:	98800317 	ldw	r2,12(r19)
  221864:	b8800515 	stw	r2,20(r23)
  221868:	00800904 	movi	r2,36
  22186c:	3080421e 	bne	r6,r2,221978 <_realloc_r+0x244>
  221870:	98800417 	ldw	r2,16(r19)
  221874:	9cc00604 	addi	r19,r19,24
  221878:	b8c00804 	addi	r3,r23,32
  22187c:	b8800615 	stw	r2,24(r23)
  221880:	98bfff17 	ldw	r2,-4(r19)
  221884:	b8800715 	stw	r2,28(r23)
  221888:	00003d06 	br	221980 <_realloc_r+0x24c>
  22188c:	01c00404 	movi	r7,16
  221890:	3829883a 	mov	r20,r7
  221894:	003fc206 	br	2217a0 <__alt_data_end+0xfffedf20>
  221898:	9823883a 	mov	r17,r19
  22189c:	850fc83a 	sub	r7,r16,r20
  2218a0:	008003c4 	movi	r2,15
  2218a4:	18c0004c 	andi	r3,r3,1
  2218a8:	11c04336 	bltu	r2,r7,2219b8 <_realloc_r+0x284>
  2218ac:	1c06b03a 	or	r3,r3,r16
  2218b0:	a8c00115 	stw	r3,4(r21)
  2218b4:	ac21883a 	add	r16,r21,r16
  2218b8:	80c00117 	ldw	r3,4(r16)
  2218bc:	18c00054 	ori	r3,r3,1
  2218c0:	80c00115 	stw	r3,4(r16)
  2218c4:	9009883a 	mov	r4,r18
  2218c8:	02236f40 	call	2236f4 <__malloc_unlock>
  2218cc:	8805883a 	mov	r2,r17
  2218d0:	dfc00917 	ldw	ra,36(sp)
  2218d4:	df000817 	ldw	fp,32(sp)
  2218d8:	ddc00717 	ldw	r23,28(sp)
  2218dc:	dd800617 	ldw	r22,24(sp)
  2218e0:	dd400517 	ldw	r21,20(sp)
  2218e4:	dd000417 	ldw	r20,16(sp)
  2218e8:	dcc00317 	ldw	r19,12(sp)
  2218ec:	dc800217 	ldw	r18,8(sp)
  2218f0:	dc400117 	ldw	r17,4(sp)
  2218f4:	dc000017 	ldw	r16,0(sp)
  2218f8:	dec00a04 	addi	sp,sp,40
  2218fc:	f800283a 	ret
  221900:	18c0004c 	andi	r3,r3,1
  221904:	1800391e 	bne	r3,zero,2219ec <_realloc_r+0x2b8>
  221908:	9dfffe17 	ldw	r23,-8(r19)
  22190c:	00bfff04 	movi	r2,-4
  221910:	adefc83a 	sub	r23,r21,r23
  221914:	b9400117 	ldw	r5,4(r23)
  221918:	288a703a 	and	r5,r5,r2
  22191c:	2c2d883a 	add	r22,r5,r16
  221920:	b1c03216 	blt	r22,r7,2219ec <_realloc_r+0x2b8>
  221924:	b8800317 	ldw	r2,12(r23)
  221928:	b8c00217 	ldw	r3,8(r23)
  22192c:	81bfff04 	addi	r6,r16,-4
  221930:	01000904 	movi	r4,36
  221934:	18800315 	stw	r2,12(r3)
  221938:	10c00215 	stw	r3,8(r2)
  22193c:	bc400204 	addi	r17,r23,8
  221940:	2180ac36 	bltu	r4,r6,221bf4 <_realloc_r+0x4c0>
  221944:	008004c4 	movi	r2,19
  221948:	1180972e 	bgeu	r2,r6,221ba8 <_realloc_r+0x474>
  22194c:	98800017 	ldw	r2,0(r19)
  221950:	b8800215 	stw	r2,8(r23)
  221954:	98800117 	ldw	r2,4(r19)
  221958:	b8800315 	stw	r2,12(r23)
  22195c:	008006c4 	movi	r2,27
  221960:	1180b92e 	bgeu	r2,r6,221c48 <_realloc_r+0x514>
  221964:	98800217 	ldw	r2,8(r19)
  221968:	b8800415 	stw	r2,16(r23)
  22196c:	98800317 	ldw	r2,12(r19)
  221970:	b8800515 	stw	r2,20(r23)
  221974:	313fbe26 	beq	r6,r4,221870 <__alt_data_end+0xfffedff0>
  221978:	b8c00604 	addi	r3,r23,24
  22197c:	9cc00404 	addi	r19,r19,16
  221980:	98800017 	ldw	r2,0(r19)
  221984:	b021883a 	mov	r16,r22
  221988:	b82b883a 	mov	r21,r23
  22198c:	18800015 	stw	r2,0(r3)
  221990:	98800117 	ldw	r2,4(r19)
  221994:	18800115 	stw	r2,4(r3)
  221998:	98800217 	ldw	r2,8(r19)
  22199c:	18800215 	stw	r2,8(r3)
  2219a0:	b8c00117 	ldw	r3,4(r23)
  2219a4:	003fbd06 	br	22189c <__alt_data_end+0xfffee01c>
  2219a8:	00800304 	movi	r2,12
  2219ac:	90800015 	stw	r2,0(r18)
  2219b0:	0005883a 	mov	r2,zero
  2219b4:	003fc606 	br	2218d0 <__alt_data_end+0xfffee050>
  2219b8:	1d06b03a 	or	r3,r3,r20
  2219bc:	ad0b883a 	add	r5,r21,r20
  2219c0:	a8c00115 	stw	r3,4(r21)
  2219c4:	38800054 	ori	r2,r7,1
  2219c8:	28800115 	stw	r2,4(r5)
  2219cc:	29cf883a 	add	r7,r5,r7
  2219d0:	38800117 	ldw	r2,4(r7)
  2219d4:	9009883a 	mov	r4,r18
  2219d8:	29400204 	addi	r5,r5,8
  2219dc:	10800054 	ori	r2,r2,1
  2219e0:	38800115 	stw	r2,4(r7)
  2219e4:	02225740 	call	222574 <_free_r>
  2219e8:	003fb606 	br	2218c4 <__alt_data_end+0xfffee044>
  2219ec:	880b883a 	mov	r5,r17
  2219f0:	9009883a 	mov	r4,r18
  2219f4:	0220c100 	call	220c10 <_malloc_r>
  2219f8:	1023883a 	mov	r17,r2
  2219fc:	1000aa26 	beq	r2,zero,221ca8 <_realloc_r+0x574>
  221a00:	98ffff17 	ldw	r3,-4(r19)
  221a04:	113ffe04 	addi	r4,r2,-8
  221a08:	00bfff84 	movi	r2,-2
  221a0c:	1884703a 	and	r2,r3,r2
  221a10:	a885883a 	add	r2,r21,r2
  221a14:	20808626 	beq	r4,r2,221c30 <_realloc_r+0x4fc>
  221a18:	81bfff04 	addi	r6,r16,-4
  221a1c:	00800904 	movi	r2,36
  221a20:	11807036 	bltu	r2,r6,221be4 <_realloc_r+0x4b0>
  221a24:	00c004c4 	movi	r3,19
  221a28:	19805636 	bltu	r3,r6,221b84 <_realloc_r+0x450>
  221a2c:	8805883a 	mov	r2,r17
  221a30:	9807883a 	mov	r3,r19
  221a34:	19000017 	ldw	r4,0(r3)
  221a38:	11000015 	stw	r4,0(r2)
  221a3c:	19000117 	ldw	r4,4(r3)
  221a40:	11000115 	stw	r4,4(r2)
  221a44:	18c00217 	ldw	r3,8(r3)
  221a48:	10c00215 	stw	r3,8(r2)
  221a4c:	980b883a 	mov	r5,r19
  221a50:	9009883a 	mov	r4,r18
  221a54:	02225740 	call	222574 <_free_r>
  221a58:	9009883a 	mov	r4,r18
  221a5c:	02236f40 	call	2236f4 <__malloc_unlock>
  221a60:	8805883a 	mov	r2,r17
  221a64:	003f9a06 	br	2218d0 <__alt_data_end+0xfffee050>
  221a68:	300b883a 	mov	r5,r6
  221a6c:	dfc00917 	ldw	ra,36(sp)
  221a70:	df000817 	ldw	fp,32(sp)
  221a74:	ddc00717 	ldw	r23,28(sp)
  221a78:	dd800617 	ldw	r22,24(sp)
  221a7c:	dd400517 	ldw	r21,20(sp)
  221a80:	dd000417 	ldw	r20,16(sp)
  221a84:	dcc00317 	ldw	r19,12(sp)
  221a88:	dc800217 	ldw	r18,8(sp)
  221a8c:	dc400117 	ldw	r17,4(sp)
  221a90:	dc000017 	ldw	r16,0(sp)
  221a94:	dec00a04 	addi	sp,sp,40
  221a98:	0220c101 	jmpi	220c10 <_malloc_r>
  221a9c:	11400317 	ldw	r5,12(r2)
  221aa0:	10800217 	ldw	r2,8(r2)
  221aa4:	9823883a 	mov	r17,r19
  221aa8:	2021883a 	mov	r16,r4
  221aac:	11400315 	stw	r5,12(r2)
  221ab0:	28800215 	stw	r2,8(r5)
  221ab4:	003f7906 	br	22189c <__alt_data_end+0xfffee01c>
  221ab8:	21000117 	ldw	r4,4(r4)
  221abc:	00bfff04 	movi	r2,-4
  221ac0:	a1800404 	addi	r6,r20,16
  221ac4:	2088703a 	and	r4,r4,r2
  221ac8:	2409883a 	add	r4,r4,r16
  221acc:	2180380e 	bge	r4,r6,221bb0 <_realloc_r+0x47c>
  221ad0:	18c0004c 	andi	r3,r3,1
  221ad4:	183fc51e 	bne	r3,zero,2219ec <__alt_data_end+0xfffee16c>
  221ad8:	9dfffe17 	ldw	r23,-8(r19)
  221adc:	adefc83a 	sub	r23,r21,r23
  221ae0:	b9400117 	ldw	r5,4(r23)
  221ae4:	288a703a 	and	r5,r5,r2
  221ae8:	216d883a 	add	r22,r4,r5
  221aec:	b1bf8b16 	blt	r22,r6,22191c <__alt_data_end+0xfffee09c>
  221af0:	b8800317 	ldw	r2,12(r23)
  221af4:	b8c00217 	ldw	r3,8(r23)
  221af8:	81bfff04 	addi	r6,r16,-4
  221afc:	01000904 	movi	r4,36
  221b00:	18800315 	stw	r2,12(r3)
  221b04:	10c00215 	stw	r3,8(r2)
  221b08:	bc400204 	addi	r17,r23,8
  221b0c:	21805a36 	bltu	r4,r6,221c78 <_realloc_r+0x544>
  221b10:	008004c4 	movi	r2,19
  221b14:	1180562e 	bgeu	r2,r6,221c70 <_realloc_r+0x53c>
  221b18:	98800017 	ldw	r2,0(r19)
  221b1c:	b8800215 	stw	r2,8(r23)
  221b20:	98800117 	ldw	r2,4(r19)
  221b24:	b8800315 	stw	r2,12(r23)
  221b28:	008006c4 	movi	r2,27
  221b2c:	11805636 	bltu	r2,r6,221c88 <_realloc_r+0x554>
  221b30:	b8800404 	addi	r2,r23,16
  221b34:	9cc00204 	addi	r19,r19,8
  221b38:	98c00017 	ldw	r3,0(r19)
  221b3c:	10c00015 	stw	r3,0(r2)
  221b40:	98c00117 	ldw	r3,4(r19)
  221b44:	10c00115 	stw	r3,4(r2)
  221b48:	98c00217 	ldw	r3,8(r19)
  221b4c:	10c00215 	stw	r3,8(r2)
  221b50:	bd07883a 	add	r3,r23,r20
  221b54:	b505c83a 	sub	r2,r22,r20
  221b58:	e0c00215 	stw	r3,8(fp)
  221b5c:	10800054 	ori	r2,r2,1
  221b60:	18800115 	stw	r2,4(r3)
  221b64:	b8800117 	ldw	r2,4(r23)
  221b68:	9009883a 	mov	r4,r18
  221b6c:	1080004c 	andi	r2,r2,1
  221b70:	a0a8b03a 	or	r20,r20,r2
  221b74:	bd000115 	stw	r20,4(r23)
  221b78:	02236f40 	call	2236f4 <__malloc_unlock>
  221b7c:	8805883a 	mov	r2,r17
  221b80:	003f5306 	br	2218d0 <__alt_data_end+0xfffee050>
  221b84:	98c00017 	ldw	r3,0(r19)
  221b88:	88c00015 	stw	r3,0(r17)
  221b8c:	98c00117 	ldw	r3,4(r19)
  221b90:	88c00115 	stw	r3,4(r17)
  221b94:	00c006c4 	movi	r3,27
  221b98:	19801d36 	bltu	r3,r6,221c10 <_realloc_r+0x4dc>
  221b9c:	88800204 	addi	r2,r17,8
  221ba0:	98c00204 	addi	r3,r19,8
  221ba4:	003fa306 	br	221a34 <__alt_data_end+0xfffee1b4>
  221ba8:	8807883a 	mov	r3,r17
  221bac:	003f7406 	br	221980 <__alt_data_end+0xfffee100>
  221bb0:	ad2b883a 	add	r21,r21,r20
  221bb4:	2505c83a 	sub	r2,r4,r20
  221bb8:	e5400215 	stw	r21,8(fp)
  221bbc:	10800054 	ori	r2,r2,1
  221bc0:	a8800115 	stw	r2,4(r21)
  221bc4:	98bfff17 	ldw	r2,-4(r19)
  221bc8:	9009883a 	mov	r4,r18
  221bcc:	1080004c 	andi	r2,r2,1
  221bd0:	a0a8b03a 	or	r20,r20,r2
  221bd4:	9d3fff15 	stw	r20,-4(r19)
  221bd8:	02236f40 	call	2236f4 <__malloc_unlock>
  221bdc:	9805883a 	mov	r2,r19
  221be0:	003f3b06 	br	2218d0 <__alt_data_end+0xfffee050>
  221be4:	8809883a 	mov	r4,r17
  221be8:	980b883a 	mov	r5,r19
  221bec:	02215d80 	call	2215d8 <memmove>
  221bf0:	003f9606 	br	221a4c <__alt_data_end+0xfffee1cc>
  221bf4:	8809883a 	mov	r4,r17
  221bf8:	980b883a 	mov	r5,r19
  221bfc:	02215d80 	call	2215d8 <memmove>
  221c00:	b8c00117 	ldw	r3,4(r23)
  221c04:	b021883a 	mov	r16,r22
  221c08:	b82b883a 	mov	r21,r23
  221c0c:	003f2306 	br	22189c <__alt_data_end+0xfffee01c>
  221c10:	98c00217 	ldw	r3,8(r19)
  221c14:	88c00215 	stw	r3,8(r17)
  221c18:	98c00317 	ldw	r3,12(r19)
  221c1c:	88c00315 	stw	r3,12(r17)
  221c20:	30800c26 	beq	r6,r2,221c54 <_realloc_r+0x520>
  221c24:	88800404 	addi	r2,r17,16
  221c28:	98c00404 	addi	r3,r19,16
  221c2c:	003f8106 	br	221a34 <__alt_data_end+0xfffee1b4>
  221c30:	893fff17 	ldw	r4,-4(r17)
  221c34:	00bfff04 	movi	r2,-4
  221c38:	9823883a 	mov	r17,r19
  221c3c:	2084703a 	and	r2,r4,r2
  221c40:	80a1883a 	add	r16,r16,r2
  221c44:	003f1506 	br	22189c <__alt_data_end+0xfffee01c>
  221c48:	b8c00404 	addi	r3,r23,16
  221c4c:	9cc00204 	addi	r19,r19,8
  221c50:	003f4b06 	br	221980 <__alt_data_end+0xfffee100>
  221c54:	99000417 	ldw	r4,16(r19)
  221c58:	88800604 	addi	r2,r17,24
  221c5c:	98c00604 	addi	r3,r19,24
  221c60:	89000415 	stw	r4,16(r17)
  221c64:	99000517 	ldw	r4,20(r19)
  221c68:	89000515 	stw	r4,20(r17)
  221c6c:	003f7106 	br	221a34 <__alt_data_end+0xfffee1b4>
  221c70:	8805883a 	mov	r2,r17
  221c74:	003fb006 	br	221b38 <__alt_data_end+0xfffee2b8>
  221c78:	8809883a 	mov	r4,r17
  221c7c:	980b883a 	mov	r5,r19
  221c80:	02215d80 	call	2215d8 <memmove>
  221c84:	003fb206 	br	221b50 <__alt_data_end+0xfffee2d0>
  221c88:	98800217 	ldw	r2,8(r19)
  221c8c:	b8800415 	stw	r2,16(r23)
  221c90:	98800317 	ldw	r2,12(r19)
  221c94:	b8800515 	stw	r2,20(r23)
  221c98:	31000726 	beq	r6,r4,221cb8 <_realloc_r+0x584>
  221c9c:	b8800604 	addi	r2,r23,24
  221ca0:	9cc00404 	addi	r19,r19,16
  221ca4:	003fa406 	br	221b38 <__alt_data_end+0xfffee2b8>
  221ca8:	9009883a 	mov	r4,r18
  221cac:	02236f40 	call	2236f4 <__malloc_unlock>
  221cb0:	0005883a 	mov	r2,zero
  221cb4:	003f0606 	br	2218d0 <__alt_data_end+0xfffee050>
  221cb8:	98c00417 	ldw	r3,16(r19)
  221cbc:	9cc00604 	addi	r19,r19,24
  221cc0:	b8800804 	addi	r2,r23,32
  221cc4:	b8c00615 	stw	r3,24(r23)
  221cc8:	98ffff17 	ldw	r3,-4(r19)
  221ccc:	b8c00715 	stw	r3,28(r23)
  221cd0:	003f9906 	br	221b38 <__alt_data_end+0xfffee2b8>

00221cd4 <_sbrk_r>:
  221cd4:	defffd04 	addi	sp,sp,-12
  221cd8:	dc000015 	stw	r16,0(sp)
  221cdc:	040008f4 	movhi	r16,35
  221ce0:	dc400115 	stw	r17,4(sp)
  221ce4:	8429ca04 	addi	r16,r16,-22744
  221ce8:	2023883a 	mov	r17,r4
  221cec:	2809883a 	mov	r4,r5
  221cf0:	dfc00215 	stw	ra,8(sp)
  221cf4:	80000015 	stw	zero,0(r16)
  221cf8:	0223b2c0 	call	223b2c <sbrk>
  221cfc:	00ffffc4 	movi	r3,-1
  221d00:	10c00526 	beq	r2,r3,221d18 <_sbrk_r+0x44>
  221d04:	dfc00217 	ldw	ra,8(sp)
  221d08:	dc400117 	ldw	r17,4(sp)
  221d0c:	dc000017 	ldw	r16,0(sp)
  221d10:	dec00304 	addi	sp,sp,12
  221d14:	f800283a 	ret
  221d18:	80c00017 	ldw	r3,0(r16)
  221d1c:	183ff926 	beq	r3,zero,221d04 <__alt_data_end+0xfffee484>
  221d20:	88c00015 	stw	r3,0(r17)
  221d24:	003ff706 	br	221d04 <__alt_data_end+0xfffee484>

00221d28 <__swsetup_r>:
  221d28:	008008f4 	movhi	r2,35
  221d2c:	defffd04 	addi	sp,sp,-12
  221d30:	10a2d404 	addi	r2,r2,-29872
  221d34:	dc400115 	stw	r17,4(sp)
  221d38:	2023883a 	mov	r17,r4
  221d3c:	11000017 	ldw	r4,0(r2)
  221d40:	dc000015 	stw	r16,0(sp)
  221d44:	dfc00215 	stw	ra,8(sp)
  221d48:	2821883a 	mov	r16,r5
  221d4c:	20000226 	beq	r4,zero,221d58 <__swsetup_r+0x30>
  221d50:	20c00e17 	ldw	r3,56(r4)
  221d54:	18002e26 	beq	r3,zero,221e10 <__swsetup_r+0xe8>
  221d58:	8080030b 	ldhu	r2,12(r16)
  221d5c:	10c0020c 	andi	r3,r2,8
  221d60:	100d883a 	mov	r6,r2
  221d64:	18000f26 	beq	r3,zero,221da4 <__swsetup_r+0x7c>
  221d68:	80c00417 	ldw	r3,16(r16)
  221d6c:	18001526 	beq	r3,zero,221dc4 <__swsetup_r+0x9c>
  221d70:	1100004c 	andi	r4,r2,1
  221d74:	20001c1e 	bne	r4,zero,221de8 <__swsetup_r+0xc0>
  221d78:	1080008c 	andi	r2,r2,2
  221d7c:	1000261e 	bne	r2,zero,221e18 <__swsetup_r+0xf0>
  221d80:	80800517 	ldw	r2,20(r16)
  221d84:	80800215 	stw	r2,8(r16)
  221d88:	18001c26 	beq	r3,zero,221dfc <__swsetup_r+0xd4>
  221d8c:	0005883a 	mov	r2,zero
  221d90:	dfc00217 	ldw	ra,8(sp)
  221d94:	dc400117 	ldw	r17,4(sp)
  221d98:	dc000017 	ldw	r16,0(sp)
  221d9c:	dec00304 	addi	sp,sp,12
  221da0:	f800283a 	ret
  221da4:	3080040c 	andi	r2,r6,16
  221da8:	10001726 	beq	r2,zero,221e08 <__swsetup_r+0xe0>
  221dac:	3080010c 	andi	r2,r6,4
  221db0:	10001b1e 	bne	r2,zero,221e20 <__swsetup_r+0xf8>
  221db4:	80c00417 	ldw	r3,16(r16)
  221db8:	30800214 	ori	r2,r6,8
  221dbc:	8080030d 	sth	r2,12(r16)
  221dc0:	183feb1e 	bne	r3,zero,221d70 <__alt_data_end+0xfffee4f0>
  221dc4:	1140a00c 	andi	r5,r2,640
  221dc8:	01008004 	movi	r4,512
  221dcc:	293fe826 	beq	r5,r4,221d70 <__alt_data_end+0xfffee4f0>
  221dd0:	8809883a 	mov	r4,r17
  221dd4:	800b883a 	mov	r5,r16
  221dd8:	02229d40 	call	2229d4 <__smakebuf_r>
  221ddc:	8080030b 	ldhu	r2,12(r16)
  221de0:	80c00417 	ldw	r3,16(r16)
  221de4:	003fe206 	br	221d70 <__alt_data_end+0xfffee4f0>
  221de8:	80800517 	ldw	r2,20(r16)
  221dec:	80000215 	stw	zero,8(r16)
  221df0:	0085c83a 	sub	r2,zero,r2
  221df4:	80800615 	stw	r2,24(r16)
  221df8:	183fe41e 	bne	r3,zero,221d8c <__alt_data_end+0xfffee50c>
  221dfc:	8080030b 	ldhu	r2,12(r16)
  221e00:	1080200c 	andi	r2,r2,128
  221e04:	103fe226 	beq	r2,zero,221d90 <__alt_data_end+0xfffee510>
  221e08:	00bfffc4 	movi	r2,-1
  221e0c:	003fe006 	br	221d90 <__alt_data_end+0xfffee510>
  221e10:	02224000 	call	222400 <__sinit>
  221e14:	003fd006 	br	221d58 <__alt_data_end+0xfffee4d8>
  221e18:	0005883a 	mov	r2,zero
  221e1c:	003fd906 	br	221d84 <__alt_data_end+0xfffee504>
  221e20:	81400c17 	ldw	r5,48(r16)
  221e24:	28000626 	beq	r5,zero,221e40 <__swsetup_r+0x118>
  221e28:	80801004 	addi	r2,r16,64
  221e2c:	28800326 	beq	r5,r2,221e3c <__swsetup_r+0x114>
  221e30:	8809883a 	mov	r4,r17
  221e34:	02225740 	call	222574 <_free_r>
  221e38:	8180030b 	ldhu	r6,12(r16)
  221e3c:	80000c15 	stw	zero,48(r16)
  221e40:	80c00417 	ldw	r3,16(r16)
  221e44:	00bff6c4 	movi	r2,-37
  221e48:	118c703a 	and	r6,r2,r6
  221e4c:	80000115 	stw	zero,4(r16)
  221e50:	80c00015 	stw	r3,0(r16)
  221e54:	003fd806 	br	221db8 <__alt_data_end+0xfffee538>

00221e58 <_fflush_r>:
  221e58:	defffb04 	addi	sp,sp,-20
  221e5c:	dcc00315 	stw	r19,12(sp)
  221e60:	dc000015 	stw	r16,0(sp)
  221e64:	dfc00415 	stw	ra,16(sp)
  221e68:	dc800215 	stw	r18,8(sp)
  221e6c:	dc400115 	stw	r17,4(sp)
  221e70:	2027883a 	mov	r19,r4
  221e74:	2821883a 	mov	r16,r5
  221e78:	20000226 	beq	r4,zero,221e84 <_fflush_r+0x2c>
  221e7c:	20800e17 	ldw	r2,56(r4)
  221e80:	10005326 	beq	r2,zero,221fd0 <_fflush_r+0x178>
  221e84:	8080030b 	ldhu	r2,12(r16)
  221e88:	10ffffcc 	andi	r3,r2,65535
  221e8c:	18e0001c 	xori	r3,r3,32768
  221e90:	18e00004 	addi	r3,r3,-32768
  221e94:	18002c26 	beq	r3,zero,221f48 <_fflush_r+0xf0>
  221e98:	10c0020c 	andi	r3,r2,8
  221e9c:	1800321e 	bne	r3,zero,221f68 <_fflush_r+0x110>
  221ea0:	80c00117 	ldw	r3,4(r16)
  221ea4:	10820014 	ori	r2,r2,2048
  221ea8:	8080030d 	sth	r2,12(r16)
  221eac:	00c0570e 	bge	zero,r3,22200c <_fflush_r+0x1b4>
  221eb0:	82000a17 	ldw	r8,40(r16)
  221eb4:	40002426 	beq	r8,zero,221f48 <_fflush_r+0xf0>
  221eb8:	9c400017 	ldw	r17,0(r19)
  221ebc:	10c4000c 	andi	r3,r2,4096
  221ec0:	98000015 	stw	zero,0(r19)
  221ec4:	18004626 	beq	r3,zero,221fe0 <_fflush_r+0x188>
  221ec8:	81801417 	ldw	r6,80(r16)
  221ecc:	10c0010c 	andi	r3,r2,4
  221ed0:	18000626 	beq	r3,zero,221eec <_fflush_r+0x94>
  221ed4:	80c00117 	ldw	r3,4(r16)
  221ed8:	80800c17 	ldw	r2,48(r16)
  221edc:	30cdc83a 	sub	r6,r6,r3
  221ee0:	10000226 	beq	r2,zero,221eec <_fflush_r+0x94>
  221ee4:	80800f17 	ldw	r2,60(r16)
  221ee8:	308dc83a 	sub	r6,r6,r2
  221eec:	81400717 	ldw	r5,28(r16)
  221ef0:	9809883a 	mov	r4,r19
  221ef4:	000f883a 	mov	r7,zero
  221ef8:	403ee83a 	callr	r8
  221efc:	00ffffc4 	movi	r3,-1
  221f00:	10c04526 	beq	r2,r3,222018 <_fflush_r+0x1c0>
  221f04:	80c0030b 	ldhu	r3,12(r16)
  221f08:	81000417 	ldw	r4,16(r16)
  221f0c:	80000115 	stw	zero,4(r16)
  221f10:	197dffcc 	andi	r5,r3,63487
  221f14:	8140030d 	sth	r5,12(r16)
  221f18:	81000015 	stw	r4,0(r16)
  221f1c:	18c4000c 	andi	r3,r3,4096
  221f20:	18000126 	beq	r3,zero,221f28 <_fflush_r+0xd0>
  221f24:	80801415 	stw	r2,80(r16)
  221f28:	81400c17 	ldw	r5,48(r16)
  221f2c:	9c400015 	stw	r17,0(r19)
  221f30:	28000526 	beq	r5,zero,221f48 <_fflush_r+0xf0>
  221f34:	80801004 	addi	r2,r16,64
  221f38:	28800226 	beq	r5,r2,221f44 <_fflush_r+0xec>
  221f3c:	9809883a 	mov	r4,r19
  221f40:	02225740 	call	222574 <_free_r>
  221f44:	80000c15 	stw	zero,48(r16)
  221f48:	0005883a 	mov	r2,zero
  221f4c:	dfc00417 	ldw	ra,16(sp)
  221f50:	dcc00317 	ldw	r19,12(sp)
  221f54:	dc800217 	ldw	r18,8(sp)
  221f58:	dc400117 	ldw	r17,4(sp)
  221f5c:	dc000017 	ldw	r16,0(sp)
  221f60:	dec00504 	addi	sp,sp,20
  221f64:	f800283a 	ret
  221f68:	84800417 	ldw	r18,16(r16)
  221f6c:	903ff626 	beq	r18,zero,221f48 <__alt_data_end+0xfffee6c8>
  221f70:	84400017 	ldw	r17,0(r16)
  221f74:	108000cc 	andi	r2,r2,3
  221f78:	84800015 	stw	r18,0(r16)
  221f7c:	8ca3c83a 	sub	r17,r17,r18
  221f80:	10001526 	beq	r2,zero,221fd8 <_fflush_r+0x180>
  221f84:	0005883a 	mov	r2,zero
  221f88:	80800215 	stw	r2,8(r16)
  221f8c:	04400316 	blt	zero,r17,221f9c <_fflush_r+0x144>
  221f90:	003fed06 	br	221f48 <__alt_data_end+0xfffee6c8>
  221f94:	90a5883a 	add	r18,r18,r2
  221f98:	047feb0e 	bge	zero,r17,221f48 <__alt_data_end+0xfffee6c8>
  221f9c:	80800917 	ldw	r2,36(r16)
  221fa0:	81400717 	ldw	r5,28(r16)
  221fa4:	880f883a 	mov	r7,r17
  221fa8:	900d883a 	mov	r6,r18
  221fac:	9809883a 	mov	r4,r19
  221fb0:	103ee83a 	callr	r2
  221fb4:	88a3c83a 	sub	r17,r17,r2
  221fb8:	00bff616 	blt	zero,r2,221f94 <__alt_data_end+0xfffee714>
  221fbc:	80c0030b 	ldhu	r3,12(r16)
  221fc0:	00bfffc4 	movi	r2,-1
  221fc4:	18c01014 	ori	r3,r3,64
  221fc8:	80c0030d 	sth	r3,12(r16)
  221fcc:	003fdf06 	br	221f4c <__alt_data_end+0xfffee6cc>
  221fd0:	02224000 	call	222400 <__sinit>
  221fd4:	003fab06 	br	221e84 <__alt_data_end+0xfffee604>
  221fd8:	80800517 	ldw	r2,20(r16)
  221fdc:	003fea06 	br	221f88 <__alt_data_end+0xfffee708>
  221fe0:	81400717 	ldw	r5,28(r16)
  221fe4:	000d883a 	mov	r6,zero
  221fe8:	9809883a 	mov	r4,r19
  221fec:	01c00044 	movi	r7,1
  221ff0:	403ee83a 	callr	r8
  221ff4:	100d883a 	mov	r6,r2
  221ff8:	00bfffc4 	movi	r2,-1
  221ffc:	30801326 	beq	r6,r2,22204c <_fflush_r+0x1f4>
  222000:	8080030b 	ldhu	r2,12(r16)
  222004:	82000a17 	ldw	r8,40(r16)
  222008:	003fb006 	br	221ecc <__alt_data_end+0xfffee64c>
  22200c:	80c00f17 	ldw	r3,60(r16)
  222010:	00ffa716 	blt	zero,r3,221eb0 <__alt_data_end+0xfffee630>
  222014:	003fcc06 	br	221f48 <__alt_data_end+0xfffee6c8>
  222018:	98c00017 	ldw	r3,0(r19)
  22201c:	183fb926 	beq	r3,zero,221f04 <__alt_data_end+0xfffee684>
  222020:	01000744 	movi	r4,29
  222024:	19000226 	beq	r3,r4,222030 <_fflush_r+0x1d8>
  222028:	01000584 	movi	r4,22
  22202c:	1900101e 	bne	r3,r4,222070 <_fflush_r+0x218>
  222030:	8080030b 	ldhu	r2,12(r16)
  222034:	80c00417 	ldw	r3,16(r16)
  222038:	80000115 	stw	zero,4(r16)
  22203c:	10bdffcc 	andi	r2,r2,63487
  222040:	8080030d 	sth	r2,12(r16)
  222044:	80c00015 	stw	r3,0(r16)
  222048:	003fb706 	br	221f28 <__alt_data_end+0xfffee6a8>
  22204c:	98800017 	ldw	r2,0(r19)
  222050:	103feb26 	beq	r2,zero,222000 <__alt_data_end+0xfffee780>
  222054:	00c00744 	movi	r3,29
  222058:	10c00226 	beq	r2,r3,222064 <_fflush_r+0x20c>
  22205c:	00c00584 	movi	r3,22
  222060:	10ffd61e 	bne	r2,r3,221fbc <__alt_data_end+0xfffee73c>
  222064:	9c400015 	stw	r17,0(r19)
  222068:	0005883a 	mov	r2,zero
  22206c:	003fb706 	br	221f4c <__alt_data_end+0xfffee6cc>
  222070:	80c0030b 	ldhu	r3,12(r16)
  222074:	18c01014 	ori	r3,r3,64
  222078:	80c0030d 	sth	r3,12(r16)
  22207c:	003fb306 	br	221f4c <__alt_data_end+0xfffee6cc>

00222080 <fflush>:
  222080:	20000526 	beq	r4,zero,222098 <fflush+0x18>
  222084:	008008f4 	movhi	r2,35
  222088:	10a2d404 	addi	r2,r2,-29872
  22208c:	200b883a 	mov	r5,r4
  222090:	11000017 	ldw	r4,0(r2)
  222094:	0221e581 	jmpi	221e58 <_fflush_r>
  222098:	008008f4 	movhi	r2,35
  22209c:	10a2d304 	addi	r2,r2,-29876
  2220a0:	11000017 	ldw	r4,0(r2)
  2220a4:	014008b4 	movhi	r5,34
  2220a8:	29479604 	addi	r5,r5,7768
  2220ac:	022291c1 	jmpi	22291c <_fwalk_reent>

002220b0 <__fp_lock>:
  2220b0:	0005883a 	mov	r2,zero
  2220b4:	f800283a 	ret

002220b8 <__fp_unlock>:
  2220b8:	0005883a 	mov	r2,zero
  2220bc:	f800283a 	ret

002220c0 <_cleanup_r>:
  2220c0:	014008b4 	movhi	r5,34
  2220c4:	294be704 	addi	r5,r5,12188
  2220c8:	02228641 	jmpi	222864 <_fwalk>

002220cc <__sinit.part.1>:
  2220cc:	defff604 	addi	sp,sp,-40
  2220d0:	00c008b4 	movhi	r3,34
  2220d4:	dfc00915 	stw	ra,36(sp)
  2220d8:	df000815 	stw	fp,32(sp)
  2220dc:	ddc00715 	stw	r23,28(sp)
  2220e0:	dd800615 	stw	r22,24(sp)
  2220e4:	dd400515 	stw	r21,20(sp)
  2220e8:	dd000415 	stw	r20,16(sp)
  2220ec:	dcc00315 	stw	r19,12(sp)
  2220f0:	dc800215 	stw	r18,8(sp)
  2220f4:	dc400115 	stw	r17,4(sp)
  2220f8:	dc000015 	stw	r16,0(sp)
  2220fc:	18c83004 	addi	r3,r3,8384
  222100:	24000117 	ldw	r16,4(r4)
  222104:	20c00f15 	stw	r3,60(r4)
  222108:	07000044 	movi	fp,1
  22210c:	00c000c4 	movi	r3,3
  222110:	2080bb04 	addi	r2,r4,748
  222114:	20c0b915 	stw	r3,740(r4)
  222118:	27000e15 	stw	fp,56(r4)
  22211c:	2080ba15 	stw	r2,744(r4)
  222120:	2000b815 	stw	zero,736(r4)
  222124:	05c00204 	movi	r23,8
  222128:	00800104 	movi	r2,4
  22212c:	2025883a 	mov	r18,r4
  222130:	b80d883a 	mov	r6,r23
  222134:	81001704 	addi	r4,r16,92
  222138:	000b883a 	mov	r5,zero
  22213c:	80000015 	stw	zero,0(r16)
  222140:	80000115 	stw	zero,4(r16)
  222144:	80000215 	stw	zero,8(r16)
  222148:	8080030d 	sth	r2,12(r16)
  22214c:	80001915 	stw	zero,100(r16)
  222150:	8000038d 	sth	zero,14(r16)
  222154:	80000415 	stw	zero,16(r16)
  222158:	80000515 	stw	zero,20(r16)
  22215c:	80000615 	stw	zero,24(r16)
  222160:	0222b8c0 	call	222b8c <memset>
  222164:	058008b4 	movhi	r22,34
  222168:	94400217 	ldw	r17,8(r18)
  22216c:	054008b4 	movhi	r21,34
  222170:	050008b4 	movhi	r20,34
  222174:	04c008b4 	movhi	r19,34
  222178:	b58b2c04 	addi	r22,r22,11440
  22217c:	ad4b4304 	addi	r21,r21,11532
  222180:	a50b6204 	addi	r20,r20,11656
  222184:	9ccb7904 	addi	r19,r19,11748
  222188:	85800815 	stw	r22,32(r16)
  22218c:	85400915 	stw	r21,36(r16)
  222190:	85000a15 	stw	r20,40(r16)
  222194:	84c00b15 	stw	r19,44(r16)
  222198:	84000715 	stw	r16,28(r16)
  22219c:	00800284 	movi	r2,10
  2221a0:	89001704 	addi	r4,r17,92
  2221a4:	b80d883a 	mov	r6,r23
  2221a8:	000b883a 	mov	r5,zero
  2221ac:	88000015 	stw	zero,0(r17)
  2221b0:	88000115 	stw	zero,4(r17)
  2221b4:	88000215 	stw	zero,8(r17)
  2221b8:	8880030d 	sth	r2,12(r17)
  2221bc:	88001915 	stw	zero,100(r17)
  2221c0:	8f00038d 	sth	fp,14(r17)
  2221c4:	88000415 	stw	zero,16(r17)
  2221c8:	88000515 	stw	zero,20(r17)
  2221cc:	88000615 	stw	zero,24(r17)
  2221d0:	0222b8c0 	call	222b8c <memset>
  2221d4:	94000317 	ldw	r16,12(r18)
  2221d8:	00800484 	movi	r2,18
  2221dc:	8c400715 	stw	r17,28(r17)
  2221e0:	8d800815 	stw	r22,32(r17)
  2221e4:	8d400915 	stw	r21,36(r17)
  2221e8:	8d000a15 	stw	r20,40(r17)
  2221ec:	8cc00b15 	stw	r19,44(r17)
  2221f0:	8080030d 	sth	r2,12(r16)
  2221f4:	00800084 	movi	r2,2
  2221f8:	80000015 	stw	zero,0(r16)
  2221fc:	80000115 	stw	zero,4(r16)
  222200:	80000215 	stw	zero,8(r16)
  222204:	80001915 	stw	zero,100(r16)
  222208:	8080038d 	sth	r2,14(r16)
  22220c:	80000415 	stw	zero,16(r16)
  222210:	80000515 	stw	zero,20(r16)
  222214:	80000615 	stw	zero,24(r16)
  222218:	81001704 	addi	r4,r16,92
  22221c:	000b883a 	mov	r5,zero
  222220:	b80d883a 	mov	r6,r23
  222224:	0222b8c0 	call	222b8c <memset>
  222228:	84000715 	stw	r16,28(r16)
  22222c:	85800815 	stw	r22,32(r16)
  222230:	85400915 	stw	r21,36(r16)
  222234:	85000a15 	stw	r20,40(r16)
  222238:	84c00b15 	stw	r19,44(r16)
  22223c:	dfc00917 	ldw	ra,36(sp)
  222240:	df000817 	ldw	fp,32(sp)
  222244:	ddc00717 	ldw	r23,28(sp)
  222248:	dd800617 	ldw	r22,24(sp)
  22224c:	dd400517 	ldw	r21,20(sp)
  222250:	dd000417 	ldw	r20,16(sp)
  222254:	dcc00317 	ldw	r19,12(sp)
  222258:	dc800217 	ldw	r18,8(sp)
  22225c:	dc400117 	ldw	r17,4(sp)
  222260:	dc000017 	ldw	r16,0(sp)
  222264:	dec00a04 	addi	sp,sp,40
  222268:	f800283a 	ret

0022226c <__sfmoreglue>:
  22226c:	defffc04 	addi	sp,sp,-16
  222270:	dc400115 	stw	r17,4(sp)
  222274:	2c401a24 	muli	r17,r5,104
  222278:	dc800215 	stw	r18,8(sp)
  22227c:	2825883a 	mov	r18,r5
  222280:	89400304 	addi	r5,r17,12
  222284:	dc000015 	stw	r16,0(sp)
  222288:	dfc00315 	stw	ra,12(sp)
  22228c:	0220c100 	call	220c10 <_malloc_r>
  222290:	1021883a 	mov	r16,r2
  222294:	10000726 	beq	r2,zero,2222b4 <__sfmoreglue+0x48>
  222298:	11000304 	addi	r4,r2,12
  22229c:	10000015 	stw	zero,0(r2)
  2222a0:	14800115 	stw	r18,4(r2)
  2222a4:	11000215 	stw	r4,8(r2)
  2222a8:	000b883a 	mov	r5,zero
  2222ac:	880d883a 	mov	r6,r17
  2222b0:	0222b8c0 	call	222b8c <memset>
  2222b4:	8005883a 	mov	r2,r16
  2222b8:	dfc00317 	ldw	ra,12(sp)
  2222bc:	dc800217 	ldw	r18,8(sp)
  2222c0:	dc400117 	ldw	r17,4(sp)
  2222c4:	dc000017 	ldw	r16,0(sp)
  2222c8:	dec00404 	addi	sp,sp,16
  2222cc:	f800283a 	ret

002222d0 <__sfp>:
  2222d0:	008008f4 	movhi	r2,35
  2222d4:	defffb04 	addi	sp,sp,-20
  2222d8:	10a2d304 	addi	r2,r2,-29876
  2222dc:	dc800215 	stw	r18,8(sp)
  2222e0:	14800017 	ldw	r18,0(r2)
  2222e4:	dcc00315 	stw	r19,12(sp)
  2222e8:	dfc00415 	stw	ra,16(sp)
  2222ec:	90800e17 	ldw	r2,56(r18)
  2222f0:	dc400115 	stw	r17,4(sp)
  2222f4:	dc000015 	stw	r16,0(sp)
  2222f8:	2027883a 	mov	r19,r4
  2222fc:	1000021e 	bne	r2,zero,222308 <__sfp+0x38>
  222300:	9009883a 	mov	r4,r18
  222304:	02220cc0 	call	2220cc <__sinit.part.1>
  222308:	9480b804 	addi	r18,r18,736
  22230c:	047fffc4 	movi	r17,-1
  222310:	91400117 	ldw	r5,4(r18)
  222314:	94000217 	ldw	r16,8(r18)
  222318:	297fffc4 	addi	r5,r5,-1
  22231c:	28000a16 	blt	r5,zero,222348 <__sfp+0x78>
  222320:	8080030f 	ldh	r2,12(r16)
  222324:	10000c26 	beq	r2,zero,222358 <__sfp+0x88>
  222328:	80c01d04 	addi	r3,r16,116
  22232c:	00000206 	br	222338 <__sfp+0x68>
  222330:	18bfe60f 	ldh	r2,-104(r3)
  222334:	10000826 	beq	r2,zero,222358 <__sfp+0x88>
  222338:	297fffc4 	addi	r5,r5,-1
  22233c:	1c3ffd04 	addi	r16,r3,-12
  222340:	18c01a04 	addi	r3,r3,104
  222344:	2c7ffa1e 	bne	r5,r17,222330 <__alt_data_end+0xfffeeab0>
  222348:	90800017 	ldw	r2,0(r18)
  22234c:	10001d26 	beq	r2,zero,2223c4 <__sfp+0xf4>
  222350:	1025883a 	mov	r18,r2
  222354:	003fee06 	br	222310 <__alt_data_end+0xfffeea90>
  222358:	00bfffc4 	movi	r2,-1
  22235c:	8080038d 	sth	r2,14(r16)
  222360:	00800044 	movi	r2,1
  222364:	8080030d 	sth	r2,12(r16)
  222368:	80001915 	stw	zero,100(r16)
  22236c:	80000015 	stw	zero,0(r16)
  222370:	80000215 	stw	zero,8(r16)
  222374:	80000115 	stw	zero,4(r16)
  222378:	80000415 	stw	zero,16(r16)
  22237c:	80000515 	stw	zero,20(r16)
  222380:	80000615 	stw	zero,24(r16)
  222384:	81001704 	addi	r4,r16,92
  222388:	000b883a 	mov	r5,zero
  22238c:	01800204 	movi	r6,8
  222390:	0222b8c0 	call	222b8c <memset>
  222394:	8005883a 	mov	r2,r16
  222398:	80000c15 	stw	zero,48(r16)
  22239c:	80000d15 	stw	zero,52(r16)
  2223a0:	80001115 	stw	zero,68(r16)
  2223a4:	80001215 	stw	zero,72(r16)
  2223a8:	dfc00417 	ldw	ra,16(sp)
  2223ac:	dcc00317 	ldw	r19,12(sp)
  2223b0:	dc800217 	ldw	r18,8(sp)
  2223b4:	dc400117 	ldw	r17,4(sp)
  2223b8:	dc000017 	ldw	r16,0(sp)
  2223bc:	dec00504 	addi	sp,sp,20
  2223c0:	f800283a 	ret
  2223c4:	9809883a 	mov	r4,r19
  2223c8:	01400104 	movi	r5,4
  2223cc:	022226c0 	call	22226c <__sfmoreglue>
  2223d0:	90800015 	stw	r2,0(r18)
  2223d4:	103fde1e 	bne	r2,zero,222350 <__alt_data_end+0xfffeead0>
  2223d8:	00800304 	movi	r2,12
  2223dc:	98800015 	stw	r2,0(r19)
  2223e0:	0005883a 	mov	r2,zero
  2223e4:	003ff006 	br	2223a8 <__alt_data_end+0xfffeeb28>

002223e8 <_cleanup>:
  2223e8:	008008f4 	movhi	r2,35
  2223ec:	10a2d304 	addi	r2,r2,-29876
  2223f0:	11000017 	ldw	r4,0(r2)
  2223f4:	014008b4 	movhi	r5,34
  2223f8:	294be704 	addi	r5,r5,12188
  2223fc:	02228641 	jmpi	222864 <_fwalk>

00222400 <__sinit>:
  222400:	20800e17 	ldw	r2,56(r4)
  222404:	10000126 	beq	r2,zero,22240c <__sinit+0xc>
  222408:	f800283a 	ret
  22240c:	02220cc1 	jmpi	2220cc <__sinit.part.1>

00222410 <__sfp_lock_acquire>:
  222410:	f800283a 	ret

00222414 <__sfp_lock_release>:
  222414:	f800283a 	ret

00222418 <__sinit_lock_acquire>:
  222418:	f800283a 	ret

0022241c <__sinit_lock_release>:
  22241c:	f800283a 	ret

00222420 <__fp_lock_all>:
  222420:	008008f4 	movhi	r2,35
  222424:	10a2d404 	addi	r2,r2,-29872
  222428:	11000017 	ldw	r4,0(r2)
  22242c:	014008b4 	movhi	r5,34
  222430:	29482c04 	addi	r5,r5,8368
  222434:	02228641 	jmpi	222864 <_fwalk>

00222438 <__fp_unlock_all>:
  222438:	008008f4 	movhi	r2,35
  22243c:	10a2d404 	addi	r2,r2,-29872
  222440:	11000017 	ldw	r4,0(r2)
  222444:	014008b4 	movhi	r5,34
  222448:	29482e04 	addi	r5,r5,8376
  22244c:	02228641 	jmpi	222864 <_fwalk>

00222450 <_malloc_trim_r>:
  222450:	defffb04 	addi	sp,sp,-20
  222454:	dcc00315 	stw	r19,12(sp)
  222458:	04c008b4 	movhi	r19,34
  22245c:	dc800215 	stw	r18,8(sp)
  222460:	dc400115 	stw	r17,4(sp)
  222464:	dc000015 	stw	r16,0(sp)
  222468:	dfc00415 	stw	ra,16(sp)
  22246c:	2821883a 	mov	r16,r5
  222470:	9cdd0804 	addi	r19,r19,29728
  222474:	2025883a 	mov	r18,r4
  222478:	02236d40 	call	2236d4 <__malloc_lock>
  22247c:	98800217 	ldw	r2,8(r19)
  222480:	14400117 	ldw	r17,4(r2)
  222484:	00bfff04 	movi	r2,-4
  222488:	88a2703a 	and	r17,r17,r2
  22248c:	8c21c83a 	sub	r16,r17,r16
  222490:	8403fbc4 	addi	r16,r16,4079
  222494:	8020d33a 	srli	r16,r16,12
  222498:	0083ffc4 	movi	r2,4095
  22249c:	843fffc4 	addi	r16,r16,-1
  2224a0:	8020933a 	slli	r16,r16,12
  2224a4:	1400060e 	bge	r2,r16,2224c0 <_malloc_trim_r+0x70>
  2224a8:	9009883a 	mov	r4,r18
  2224ac:	000b883a 	mov	r5,zero
  2224b0:	0221cd40 	call	221cd4 <_sbrk_r>
  2224b4:	98c00217 	ldw	r3,8(r19)
  2224b8:	1c47883a 	add	r3,r3,r17
  2224bc:	10c00a26 	beq	r2,r3,2224e8 <_malloc_trim_r+0x98>
  2224c0:	9009883a 	mov	r4,r18
  2224c4:	02236f40 	call	2236f4 <__malloc_unlock>
  2224c8:	0005883a 	mov	r2,zero
  2224cc:	dfc00417 	ldw	ra,16(sp)
  2224d0:	dcc00317 	ldw	r19,12(sp)
  2224d4:	dc800217 	ldw	r18,8(sp)
  2224d8:	dc400117 	ldw	r17,4(sp)
  2224dc:	dc000017 	ldw	r16,0(sp)
  2224e0:	dec00504 	addi	sp,sp,20
  2224e4:	f800283a 	ret
  2224e8:	9009883a 	mov	r4,r18
  2224ec:	040bc83a 	sub	r5,zero,r16
  2224f0:	0221cd40 	call	221cd4 <_sbrk_r>
  2224f4:	00ffffc4 	movi	r3,-1
  2224f8:	10c00d26 	beq	r2,r3,222530 <_malloc_trim_r+0xe0>
  2224fc:	00c008f4 	movhi	r3,35
  222500:	18e9d204 	addi	r3,r3,-22712
  222504:	18800017 	ldw	r2,0(r3)
  222508:	99000217 	ldw	r4,8(r19)
  22250c:	8c23c83a 	sub	r17,r17,r16
  222510:	8c400054 	ori	r17,r17,1
  222514:	1421c83a 	sub	r16,r2,r16
  222518:	24400115 	stw	r17,4(r4)
  22251c:	9009883a 	mov	r4,r18
  222520:	1c000015 	stw	r16,0(r3)
  222524:	02236f40 	call	2236f4 <__malloc_unlock>
  222528:	00800044 	movi	r2,1
  22252c:	003fe706 	br	2224cc <__alt_data_end+0xfffeec4c>
  222530:	9009883a 	mov	r4,r18
  222534:	000b883a 	mov	r5,zero
  222538:	0221cd40 	call	221cd4 <_sbrk_r>
  22253c:	99000217 	ldw	r4,8(r19)
  222540:	014003c4 	movi	r5,15
  222544:	1107c83a 	sub	r3,r2,r4
  222548:	28ffdd0e 	bge	r5,r3,2224c0 <__alt_data_end+0xfffeec40>
  22254c:	014008f4 	movhi	r5,35
  222550:	2962d504 	addi	r5,r5,-29868
  222554:	29400017 	ldw	r5,0(r5)
  222558:	18c00054 	ori	r3,r3,1
  22255c:	20c00115 	stw	r3,4(r4)
  222560:	00c008f4 	movhi	r3,35
  222564:	1145c83a 	sub	r2,r2,r5
  222568:	18e9d204 	addi	r3,r3,-22712
  22256c:	18800015 	stw	r2,0(r3)
  222570:	003fd306 	br	2224c0 <__alt_data_end+0xfffeec40>

00222574 <_free_r>:
  222574:	28004c26 	beq	r5,zero,2226a8 <_free_r+0x134>
  222578:	defffd04 	addi	sp,sp,-12
  22257c:	dc400115 	stw	r17,4(sp)
  222580:	dc000015 	stw	r16,0(sp)
  222584:	2023883a 	mov	r17,r4
  222588:	2821883a 	mov	r16,r5
  22258c:	dfc00215 	stw	ra,8(sp)
  222590:	02236d40 	call	2236d4 <__malloc_lock>
  222594:	813fff17 	ldw	r4,-4(r16)
  222598:	00bfff84 	movi	r2,-2
  22259c:	024008b4 	movhi	r9,34
  2225a0:	81bffe04 	addi	r6,r16,-8
  2225a4:	2084703a 	and	r2,r4,r2
  2225a8:	4a5d0804 	addi	r9,r9,29728
  2225ac:	308b883a 	add	r5,r6,r2
  2225b0:	2a000117 	ldw	r8,4(r5)
  2225b4:	49c00217 	ldw	r7,8(r9)
  2225b8:	00ffff04 	movi	r3,-4
  2225bc:	40c6703a 	and	r3,r8,r3
  2225c0:	39405326 	beq	r7,r5,222710 <_free_r+0x19c>
  2225c4:	28c00115 	stw	r3,4(r5)
  2225c8:	2100004c 	andi	r4,r4,1
  2225cc:	2000091e 	bne	r4,zero,2225f4 <_free_r+0x80>
  2225d0:	81fffe17 	ldw	r7,-8(r16)
  2225d4:	4a000204 	addi	r8,r9,8
  2225d8:	31cdc83a 	sub	r6,r6,r7
  2225dc:	31000217 	ldw	r4,8(r6)
  2225e0:	11c5883a 	add	r2,r2,r7
  2225e4:	22006126 	beq	r4,r8,22276c <_free_r+0x1f8>
  2225e8:	31c00317 	ldw	r7,12(r6)
  2225ec:	21c00315 	stw	r7,12(r4)
  2225f0:	39000215 	stw	r4,8(r7)
  2225f4:	28c9883a 	add	r4,r5,r3
  2225f8:	21c00117 	ldw	r7,4(r4)
  2225fc:	39c0004c 	andi	r7,r7,1
  222600:	38000d1e 	bne	r7,zero,222638 <_free_r+0xc4>
  222604:	29000217 	ldw	r4,8(r5)
  222608:	10c5883a 	add	r2,r2,r3
  22260c:	00c008b4 	movhi	r3,34
  222610:	18dd0a04 	addi	r3,r3,29736
  222614:	20c07526 	beq	r4,r3,2227ec <_free_r+0x278>
  222618:	29c00317 	ldw	r7,12(r5)
  22261c:	11400054 	ori	r5,r2,1
  222620:	3087883a 	add	r3,r6,r2
  222624:	21c00315 	stw	r7,12(r4)
  222628:	39000215 	stw	r4,8(r7)
  22262c:	31400115 	stw	r5,4(r6)
  222630:	18800015 	stw	r2,0(r3)
  222634:	00000406 	br	222648 <_free_r+0xd4>
  222638:	10c00054 	ori	r3,r2,1
  22263c:	30c00115 	stw	r3,4(r6)
  222640:	3087883a 	add	r3,r6,r2
  222644:	18800015 	stw	r2,0(r3)
  222648:	00c07fc4 	movi	r3,511
  22264c:	18801736 	bltu	r3,r2,2226ac <_free_r+0x138>
  222650:	1004d0fa 	srli	r2,r2,3
  222654:	01400044 	movi	r5,1
  222658:	49000117 	ldw	r4,4(r9)
  22265c:	1087883a 	add	r3,r2,r2
  222660:	18c7883a 	add	r3,r3,r3
  222664:	1005d0ba 	srai	r2,r2,2
  222668:	18c7883a 	add	r3,r3,r3
  22266c:	1a47883a 	add	r3,r3,r9
  222670:	19c00217 	ldw	r7,8(r3)
  222674:	2884983a 	sll	r2,r5,r2
  222678:	30c00315 	stw	r3,12(r6)
  22267c:	31c00215 	stw	r7,8(r6)
  222680:	1104b03a 	or	r2,r2,r4
  222684:	19800215 	stw	r6,8(r3)
  222688:	48800115 	stw	r2,4(r9)
  22268c:	39800315 	stw	r6,12(r7)
  222690:	8809883a 	mov	r4,r17
  222694:	dfc00217 	ldw	ra,8(sp)
  222698:	dc400117 	ldw	r17,4(sp)
  22269c:	dc000017 	ldw	r16,0(sp)
  2226a0:	dec00304 	addi	sp,sp,12
  2226a4:	02236f41 	jmpi	2236f4 <__malloc_unlock>
  2226a8:	f800283a 	ret
  2226ac:	1006d27a 	srli	r3,r2,9
  2226b0:	01000104 	movi	r4,4
  2226b4:	20c04036 	bltu	r4,r3,2227b8 <_free_r+0x244>
  2226b8:	1006d1ba 	srli	r3,r2,6
  2226bc:	19400e04 	addi	r5,r3,56
  2226c0:	2947883a 	add	r3,r5,r5
  2226c4:	18c7883a 	add	r3,r3,r3
  2226c8:	18c7883a 	add	r3,r3,r3
  2226cc:	1a49883a 	add	r4,r3,r9
  2226d0:	20c00217 	ldw	r3,8(r4)
  2226d4:	01c008b4 	movhi	r7,34
  2226d8:	39dd0804 	addi	r7,r7,29728
  2226dc:	19003b26 	beq	r3,r4,2227cc <_free_r+0x258>
  2226e0:	01ffff04 	movi	r7,-4
  2226e4:	19400117 	ldw	r5,4(r3)
  2226e8:	29ca703a 	and	r5,r5,r7
  2226ec:	1140022e 	bgeu	r2,r5,2226f8 <_free_r+0x184>
  2226f0:	18c00217 	ldw	r3,8(r3)
  2226f4:	20fffb1e 	bne	r4,r3,2226e4 <__alt_data_end+0xfffeee64>
  2226f8:	18800317 	ldw	r2,12(r3)
  2226fc:	30800315 	stw	r2,12(r6)
  222700:	30c00215 	stw	r3,8(r6)
  222704:	11800215 	stw	r6,8(r2)
  222708:	19800315 	stw	r6,12(r3)
  22270c:	003fe006 	br	222690 <__alt_data_end+0xfffeee10>
  222710:	2100004c 	andi	r4,r4,1
  222714:	1885883a 	add	r2,r3,r2
  222718:	2000071e 	bne	r4,zero,222738 <_free_r+0x1c4>
  22271c:	817ffe17 	ldw	r5,-8(r16)
  222720:	314dc83a 	sub	r6,r6,r5
  222724:	30c00317 	ldw	r3,12(r6)
  222728:	31000217 	ldw	r4,8(r6)
  22272c:	1145883a 	add	r2,r2,r5
  222730:	20c00315 	stw	r3,12(r4)
  222734:	19000215 	stw	r4,8(r3)
  222738:	10c00054 	ori	r3,r2,1
  22273c:	30c00115 	stw	r3,4(r6)
  222740:	00c008f4 	movhi	r3,35
  222744:	18e2d604 	addi	r3,r3,-29864
  222748:	18c00017 	ldw	r3,0(r3)
  22274c:	49800215 	stw	r6,8(r9)
  222750:	10ffcf36 	bltu	r2,r3,222690 <__alt_data_end+0xfffeee10>
  222754:	008008f4 	movhi	r2,35
  222758:	10a9c904 	addi	r2,r2,-22748
  22275c:	11400017 	ldw	r5,0(r2)
  222760:	8809883a 	mov	r4,r17
  222764:	02224500 	call	222450 <_malloc_trim_r>
  222768:	003fc906 	br	222690 <__alt_data_end+0xfffeee10>
  22276c:	28c9883a 	add	r4,r5,r3
  222770:	21000117 	ldw	r4,4(r4)
  222774:	2100004c 	andi	r4,r4,1
  222778:	20000a1e 	bne	r4,zero,2227a4 <_free_r+0x230>
  22277c:	29000317 	ldw	r4,12(r5)
  222780:	29400217 	ldw	r5,8(r5)
  222784:	10c5883a 	add	r2,r2,r3
  222788:	10c00054 	ori	r3,r2,1
  22278c:	29000315 	stw	r4,12(r5)
  222790:	21400215 	stw	r5,8(r4)
  222794:	30c00115 	stw	r3,4(r6)
  222798:	308d883a 	add	r6,r6,r2
  22279c:	30800015 	stw	r2,0(r6)
  2227a0:	003fbb06 	br	222690 <__alt_data_end+0xfffeee10>
  2227a4:	10c00054 	ori	r3,r2,1
  2227a8:	30c00115 	stw	r3,4(r6)
  2227ac:	308d883a 	add	r6,r6,r2
  2227b0:	30800015 	stw	r2,0(r6)
  2227b4:	003fb606 	br	222690 <__alt_data_end+0xfffeee10>
  2227b8:	01000504 	movi	r4,20
  2227bc:	20c01436 	bltu	r4,r3,222810 <_free_r+0x29c>
  2227c0:	194016c4 	addi	r5,r3,91
  2227c4:	2947883a 	add	r3,r5,r5
  2227c8:	003fbe06 	br	2226c4 <__alt_data_end+0xfffeee44>
  2227cc:	280bd0ba 	srai	r5,r5,2
  2227d0:	00800044 	movi	r2,1
  2227d4:	39000117 	ldw	r4,4(r7)
  2227d8:	114a983a 	sll	r5,r2,r5
  2227dc:	1805883a 	mov	r2,r3
  2227e0:	2908b03a 	or	r4,r5,r4
  2227e4:	39000115 	stw	r4,4(r7)
  2227e8:	003fc406 	br	2226fc <__alt_data_end+0xfffeee7c>
  2227ec:	49800515 	stw	r6,20(r9)
  2227f0:	49800415 	stw	r6,16(r9)
  2227f4:	10c00054 	ori	r3,r2,1
  2227f8:	31000315 	stw	r4,12(r6)
  2227fc:	31000215 	stw	r4,8(r6)
  222800:	30c00115 	stw	r3,4(r6)
  222804:	308d883a 	add	r6,r6,r2
  222808:	30800015 	stw	r2,0(r6)
  22280c:	003fa006 	br	222690 <__alt_data_end+0xfffeee10>
  222810:	01001504 	movi	r4,84
  222814:	20c00436 	bltu	r4,r3,222828 <_free_r+0x2b4>
  222818:	1006d33a 	srli	r3,r2,12
  22281c:	19401b84 	addi	r5,r3,110
  222820:	2947883a 	add	r3,r5,r5
  222824:	003fa706 	br	2226c4 <__alt_data_end+0xfffeee44>
  222828:	01005504 	movi	r4,340
  22282c:	20c00436 	bltu	r4,r3,222840 <_free_r+0x2cc>
  222830:	1006d3fa 	srli	r3,r2,15
  222834:	19401dc4 	addi	r5,r3,119
  222838:	2947883a 	add	r3,r5,r5
  22283c:	003fa106 	br	2226c4 <__alt_data_end+0xfffeee44>
  222840:	01015504 	movi	r4,1364
  222844:	20c00436 	bltu	r4,r3,222858 <_free_r+0x2e4>
  222848:	1006d4ba 	srli	r3,r2,18
  22284c:	19401f04 	addi	r5,r3,124
  222850:	2947883a 	add	r3,r5,r5
  222854:	003f9b06 	br	2226c4 <__alt_data_end+0xfffeee44>
  222858:	00c03f04 	movi	r3,252
  22285c:	01401f84 	movi	r5,126
  222860:	003f9806 	br	2226c4 <__alt_data_end+0xfffeee44>

00222864 <_fwalk>:
  222864:	defff804 	addi	sp,sp,-32
  222868:	dd400515 	stw	r21,20(sp)
  22286c:	2540b804 	addi	r21,r4,736
  222870:	dd800615 	stw	r22,24(sp)
  222874:	dd000415 	stw	r20,16(sp)
  222878:	dfc00715 	stw	ra,28(sp)
  22287c:	dcc00315 	stw	r19,12(sp)
  222880:	dc800215 	stw	r18,8(sp)
  222884:	dc400115 	stw	r17,4(sp)
  222888:	dc000015 	stw	r16,0(sp)
  22288c:	2829883a 	mov	r20,r5
  222890:	002d883a 	mov	r22,zero
  222894:	02224100 	call	222410 <__sfp_lock_acquire>
  222898:	a8001426 	beq	r21,zero,2228ec <_fwalk+0x88>
  22289c:	04ffffc4 	movi	r19,-1
  2228a0:	ac400117 	ldw	r17,4(r21)
  2228a4:	ac800217 	ldw	r18,8(r21)
  2228a8:	8c7fffc4 	addi	r17,r17,-1
  2228ac:	88000d16 	blt	r17,zero,2228e4 <_fwalk+0x80>
  2228b0:	94000304 	addi	r16,r18,12
  2228b4:	94800384 	addi	r18,r18,14
  2228b8:	80c0000f 	ldh	r3,0(r16)
  2228bc:	8c7fffc4 	addi	r17,r17,-1
  2228c0:	813ffd04 	addi	r4,r16,-12
  2228c4:	18000426 	beq	r3,zero,2228d8 <_fwalk+0x74>
  2228c8:	90c0000f 	ldh	r3,0(r18)
  2228cc:	1cc00226 	beq	r3,r19,2228d8 <_fwalk+0x74>
  2228d0:	a03ee83a 	callr	r20
  2228d4:	b0acb03a 	or	r22,r22,r2
  2228d8:	84001a04 	addi	r16,r16,104
  2228dc:	94801a04 	addi	r18,r18,104
  2228e0:	8cfff51e 	bne	r17,r19,2228b8 <__alt_data_end+0xfffef038>
  2228e4:	ad400017 	ldw	r21,0(r21)
  2228e8:	a83fed1e 	bne	r21,zero,2228a0 <__alt_data_end+0xfffef020>
  2228ec:	02224140 	call	222414 <__sfp_lock_release>
  2228f0:	b005883a 	mov	r2,r22
  2228f4:	dfc00717 	ldw	ra,28(sp)
  2228f8:	dd800617 	ldw	r22,24(sp)
  2228fc:	dd400517 	ldw	r21,20(sp)
  222900:	dd000417 	ldw	r20,16(sp)
  222904:	dcc00317 	ldw	r19,12(sp)
  222908:	dc800217 	ldw	r18,8(sp)
  22290c:	dc400117 	ldw	r17,4(sp)
  222910:	dc000017 	ldw	r16,0(sp)
  222914:	dec00804 	addi	sp,sp,32
  222918:	f800283a 	ret

0022291c <_fwalk_reent>:
  22291c:	defff804 	addi	sp,sp,-32
  222920:	dd400515 	stw	r21,20(sp)
  222924:	2540b804 	addi	r21,r4,736
  222928:	dd800615 	stw	r22,24(sp)
  22292c:	dd000415 	stw	r20,16(sp)
  222930:	dcc00315 	stw	r19,12(sp)
  222934:	dfc00715 	stw	ra,28(sp)
  222938:	dc800215 	stw	r18,8(sp)
  22293c:	dc400115 	stw	r17,4(sp)
  222940:	dc000015 	stw	r16,0(sp)
  222944:	2027883a 	mov	r19,r4
  222948:	2829883a 	mov	r20,r5
  22294c:	002d883a 	mov	r22,zero
  222950:	02224100 	call	222410 <__sfp_lock_acquire>
  222954:	a8001326 	beq	r21,zero,2229a4 <_fwalk_reent+0x88>
  222958:	04bfffc4 	movi	r18,-1
  22295c:	ac400117 	ldw	r17,4(r21)
  222960:	ac000217 	ldw	r16,8(r21)
  222964:	8c7fffc4 	addi	r17,r17,-1
  222968:	88000c16 	blt	r17,zero,22299c <_fwalk_reent+0x80>
  22296c:	84000304 	addi	r16,r16,12
  222970:	80c0000f 	ldh	r3,0(r16)
  222974:	8c7fffc4 	addi	r17,r17,-1
  222978:	817ffd04 	addi	r5,r16,-12
  22297c:	18000526 	beq	r3,zero,222994 <_fwalk_reent+0x78>
  222980:	80c0008f 	ldh	r3,2(r16)
  222984:	9809883a 	mov	r4,r19
  222988:	1c800226 	beq	r3,r18,222994 <_fwalk_reent+0x78>
  22298c:	a03ee83a 	callr	r20
  222990:	b0acb03a 	or	r22,r22,r2
  222994:	84001a04 	addi	r16,r16,104
  222998:	8cbff51e 	bne	r17,r18,222970 <__alt_data_end+0xfffef0f0>
  22299c:	ad400017 	ldw	r21,0(r21)
  2229a0:	a83fee1e 	bne	r21,zero,22295c <__alt_data_end+0xfffef0dc>
  2229a4:	02224140 	call	222414 <__sfp_lock_release>
  2229a8:	b005883a 	mov	r2,r22
  2229ac:	dfc00717 	ldw	ra,28(sp)
  2229b0:	dd800617 	ldw	r22,24(sp)
  2229b4:	dd400517 	ldw	r21,20(sp)
  2229b8:	dd000417 	ldw	r20,16(sp)
  2229bc:	dcc00317 	ldw	r19,12(sp)
  2229c0:	dc800217 	ldw	r18,8(sp)
  2229c4:	dc400117 	ldw	r17,4(sp)
  2229c8:	dc000017 	ldw	r16,0(sp)
  2229cc:	dec00804 	addi	sp,sp,32
  2229d0:	f800283a 	ret

002229d4 <__smakebuf_r>:
  2229d4:	2880030b 	ldhu	r2,12(r5)
  2229d8:	10c0008c 	andi	r3,r2,2
  2229dc:	1800401e 	bne	r3,zero,222ae0 <__smakebuf_r+0x10c>
  2229e0:	deffec04 	addi	sp,sp,-80
  2229e4:	dc000f15 	stw	r16,60(sp)
  2229e8:	2821883a 	mov	r16,r5
  2229ec:	2940038f 	ldh	r5,14(r5)
  2229f0:	dc401015 	stw	r17,64(sp)
  2229f4:	dfc01315 	stw	ra,76(sp)
  2229f8:	dcc01215 	stw	r19,72(sp)
  2229fc:	dc801115 	stw	r18,68(sp)
  222a00:	2023883a 	mov	r17,r4
  222a04:	28001b16 	blt	r5,zero,222a74 <__smakebuf_r+0xa0>
  222a08:	d80d883a 	mov	r6,sp
  222a0c:	0222fb00 	call	222fb0 <_fstat_r>
  222a10:	10001716 	blt	r2,zero,222a70 <__smakebuf_r+0x9c>
  222a14:	d8800117 	ldw	r2,4(sp)
  222a18:	00e00014 	movui	r3,32768
  222a1c:	10bc000c 	andi	r2,r2,61440
  222a20:	10c03726 	beq	r2,r3,222b00 <__smakebuf_r+0x12c>
  222a24:	80c0030b 	ldhu	r3,12(r16)
  222a28:	18c20014 	ori	r3,r3,2048
  222a2c:	80c0030d 	sth	r3,12(r16)
  222a30:	00c80004 	movi	r3,8192
  222a34:	10c03c1e 	bne	r2,r3,222b28 <__smakebuf_r+0x154>
  222a38:	8140038f 	ldh	r5,14(r16)
  222a3c:	8809883a 	mov	r4,r17
  222a40:	02230080 	call	223008 <_isatty_r>
  222a44:	10004e26 	beq	r2,zero,222b80 <__smakebuf_r+0x1ac>
  222a48:	8080030b 	ldhu	r2,12(r16)
  222a4c:	04c00044 	movi	r19,1
  222a50:	80c010c4 	addi	r3,r16,67
  222a54:	14c4b03a 	or	r2,r2,r19
  222a58:	8080030d 	sth	r2,12(r16)
  222a5c:	80c00015 	stw	r3,0(r16)
  222a60:	80c00415 	stw	r3,16(r16)
  222a64:	84c00515 	stw	r19,20(r16)
  222a68:	04810004 	movi	r18,1024
  222a6c:	00000706 	br	222a8c <__smakebuf_r+0xb8>
  222a70:	8080030b 	ldhu	r2,12(r16)
  222a74:	10c0200c 	andi	r3,r2,128
  222a78:	18001f1e 	bne	r3,zero,222af8 <__smakebuf_r+0x124>
  222a7c:	04810004 	movi	r18,1024
  222a80:	10820014 	ori	r2,r2,2048
  222a84:	8080030d 	sth	r2,12(r16)
  222a88:	0027883a 	mov	r19,zero
  222a8c:	8809883a 	mov	r4,r17
  222a90:	900b883a 	mov	r5,r18
  222a94:	0220c100 	call	220c10 <_malloc_r>
  222a98:	10002e26 	beq	r2,zero,222b54 <__smakebuf_r+0x180>
  222a9c:	80c0030b 	ldhu	r3,12(r16)
  222aa0:	010008b4 	movhi	r4,34
  222aa4:	21083004 	addi	r4,r4,8384
  222aa8:	89000f15 	stw	r4,60(r17)
  222aac:	18c02014 	ori	r3,r3,128
  222ab0:	80c0030d 	sth	r3,12(r16)
  222ab4:	80800015 	stw	r2,0(r16)
  222ab8:	80800415 	stw	r2,16(r16)
  222abc:	84800515 	stw	r18,20(r16)
  222ac0:	98001c1e 	bne	r19,zero,222b34 <__smakebuf_r+0x160>
  222ac4:	dfc01317 	ldw	ra,76(sp)
  222ac8:	dcc01217 	ldw	r19,72(sp)
  222acc:	dc801117 	ldw	r18,68(sp)
  222ad0:	dc401017 	ldw	r17,64(sp)
  222ad4:	dc000f17 	ldw	r16,60(sp)
  222ad8:	dec01404 	addi	sp,sp,80
  222adc:	f800283a 	ret
  222ae0:	288010c4 	addi	r2,r5,67
  222ae4:	28800015 	stw	r2,0(r5)
  222ae8:	28800415 	stw	r2,16(r5)
  222aec:	00800044 	movi	r2,1
  222af0:	28800515 	stw	r2,20(r5)
  222af4:	f800283a 	ret
  222af8:	04801004 	movi	r18,64
  222afc:	003fe006 	br	222a80 <__alt_data_end+0xfffef200>
  222b00:	81000a17 	ldw	r4,40(r16)
  222b04:	00c008b4 	movhi	r3,34
  222b08:	18cb6204 	addi	r3,r3,11656
  222b0c:	20ffc51e 	bne	r4,r3,222a24 <__alt_data_end+0xfffef1a4>
  222b10:	80c0030b 	ldhu	r3,12(r16)
  222b14:	01010004 	movi	r4,1024
  222b18:	81001315 	stw	r4,76(r16)
  222b1c:	1906b03a 	or	r3,r3,r4
  222b20:	80c0030d 	sth	r3,12(r16)
  222b24:	003fc206 	br	222a30 <__alt_data_end+0xfffef1b0>
  222b28:	0027883a 	mov	r19,zero
  222b2c:	04810004 	movi	r18,1024
  222b30:	003fd606 	br	222a8c <__alt_data_end+0xfffef20c>
  222b34:	8140038f 	ldh	r5,14(r16)
  222b38:	8809883a 	mov	r4,r17
  222b3c:	02230080 	call	223008 <_isatty_r>
  222b40:	103fe026 	beq	r2,zero,222ac4 <__alt_data_end+0xfffef244>
  222b44:	8080030b 	ldhu	r2,12(r16)
  222b48:	10800054 	ori	r2,r2,1
  222b4c:	8080030d 	sth	r2,12(r16)
  222b50:	003fdc06 	br	222ac4 <__alt_data_end+0xfffef244>
  222b54:	8080030b 	ldhu	r2,12(r16)
  222b58:	10c0800c 	andi	r3,r2,512
  222b5c:	183fd91e 	bne	r3,zero,222ac4 <__alt_data_end+0xfffef244>
  222b60:	10800094 	ori	r2,r2,2
  222b64:	80c010c4 	addi	r3,r16,67
  222b68:	8080030d 	sth	r2,12(r16)
  222b6c:	00800044 	movi	r2,1
  222b70:	80c00015 	stw	r3,0(r16)
  222b74:	80c00415 	stw	r3,16(r16)
  222b78:	80800515 	stw	r2,20(r16)
  222b7c:	003fd106 	br	222ac4 <__alt_data_end+0xfffef244>
  222b80:	04c00044 	movi	r19,1
  222b84:	04810004 	movi	r18,1024
  222b88:	003fc006 	br	222a8c <__alt_data_end+0xfffef20c>

00222b8c <memset>:
  222b8c:	20c000cc 	andi	r3,r4,3
  222b90:	2005883a 	mov	r2,r4
  222b94:	18004326 	beq	r3,zero,222ca4 <memset+0x118>
  222b98:	31ffffc4 	addi	r7,r6,-1
  222b9c:	30004026 	beq	r6,zero,222ca0 <memset+0x114>
  222ba0:	2813883a 	mov	r9,r5
  222ba4:	200d883a 	mov	r6,r4
  222ba8:	2007883a 	mov	r3,r4
  222bac:	00000406 	br	222bc0 <memset+0x34>
  222bb0:	3a3fffc4 	addi	r8,r7,-1
  222bb4:	31800044 	addi	r6,r6,1
  222bb8:	38003926 	beq	r7,zero,222ca0 <memset+0x114>
  222bbc:	400f883a 	mov	r7,r8
  222bc0:	18c00044 	addi	r3,r3,1
  222bc4:	32400005 	stb	r9,0(r6)
  222bc8:	1a0000cc 	andi	r8,r3,3
  222bcc:	403ff81e 	bne	r8,zero,222bb0 <__alt_data_end+0xfffef330>
  222bd0:	010000c4 	movi	r4,3
  222bd4:	21c02d2e 	bgeu	r4,r7,222c8c <memset+0x100>
  222bd8:	29803fcc 	andi	r6,r5,255
  222bdc:	3008923a 	slli	r4,r6,8
  222be0:	218cb03a 	or	r6,r4,r6
  222be4:	3008943a 	slli	r4,r6,16
  222be8:	218cb03a 	or	r6,r4,r6
  222bec:	010003c4 	movi	r4,15
  222bf0:	21c0182e 	bgeu	r4,r7,222c54 <memset+0xc8>
  222bf4:	3b3ffc04 	addi	r12,r7,-16
  222bf8:	6018d13a 	srli	r12,r12,4
  222bfc:	1a000104 	addi	r8,r3,4
  222c00:	1ac00204 	addi	r11,r3,8
  222c04:	6008913a 	slli	r4,r12,4
  222c08:	1a800304 	addi	r10,r3,12
  222c0c:	1813883a 	mov	r9,r3
  222c10:	21000504 	addi	r4,r4,20
  222c14:	1909883a 	add	r4,r3,r4
  222c18:	49800015 	stw	r6,0(r9)
  222c1c:	41800015 	stw	r6,0(r8)
  222c20:	59800015 	stw	r6,0(r11)
  222c24:	51800015 	stw	r6,0(r10)
  222c28:	42000404 	addi	r8,r8,16
  222c2c:	4a400404 	addi	r9,r9,16
  222c30:	5ac00404 	addi	r11,r11,16
  222c34:	52800404 	addi	r10,r10,16
  222c38:	413ff71e 	bne	r8,r4,222c18 <__alt_data_end+0xfffef398>
  222c3c:	63000044 	addi	r12,r12,1
  222c40:	6018913a 	slli	r12,r12,4
  222c44:	39c003cc 	andi	r7,r7,15
  222c48:	010000c4 	movi	r4,3
  222c4c:	1b07883a 	add	r3,r3,r12
  222c50:	21c00e2e 	bgeu	r4,r7,222c8c <memset+0x100>
  222c54:	1813883a 	mov	r9,r3
  222c58:	3811883a 	mov	r8,r7
  222c5c:	010000c4 	movi	r4,3
  222c60:	49800015 	stw	r6,0(r9)
  222c64:	423fff04 	addi	r8,r8,-4
  222c68:	4a400104 	addi	r9,r9,4
  222c6c:	223ffc36 	bltu	r4,r8,222c60 <__alt_data_end+0xfffef3e0>
  222c70:	393fff04 	addi	r4,r7,-4
  222c74:	2008d0ba 	srli	r4,r4,2
  222c78:	39c000cc 	andi	r7,r7,3
  222c7c:	21000044 	addi	r4,r4,1
  222c80:	2109883a 	add	r4,r4,r4
  222c84:	2109883a 	add	r4,r4,r4
  222c88:	1907883a 	add	r3,r3,r4
  222c8c:	38000426 	beq	r7,zero,222ca0 <memset+0x114>
  222c90:	19cf883a 	add	r7,r3,r7
  222c94:	19400005 	stb	r5,0(r3)
  222c98:	18c00044 	addi	r3,r3,1
  222c9c:	19fffd1e 	bne	r3,r7,222c94 <__alt_data_end+0xfffef414>
  222ca0:	f800283a 	ret
  222ca4:	2007883a 	mov	r3,r4
  222ca8:	300f883a 	mov	r7,r6
  222cac:	003fc806 	br	222bd0 <__alt_data_end+0xfffef350>

00222cb0 <__sread>:
  222cb0:	defffe04 	addi	sp,sp,-8
  222cb4:	dc000015 	stw	r16,0(sp)
  222cb8:	2821883a 	mov	r16,r5
  222cbc:	2940038f 	ldh	r5,14(r5)
  222cc0:	dfc00115 	stw	ra,4(sp)
  222cc4:	02230b80 	call	2230b8 <_read_r>
  222cc8:	10000716 	blt	r2,zero,222ce8 <__sread+0x38>
  222ccc:	80c01417 	ldw	r3,80(r16)
  222cd0:	1887883a 	add	r3,r3,r2
  222cd4:	80c01415 	stw	r3,80(r16)
  222cd8:	dfc00117 	ldw	ra,4(sp)
  222cdc:	dc000017 	ldw	r16,0(sp)
  222ce0:	dec00204 	addi	sp,sp,8
  222ce4:	f800283a 	ret
  222ce8:	80c0030b 	ldhu	r3,12(r16)
  222cec:	18fbffcc 	andi	r3,r3,61439
  222cf0:	80c0030d 	sth	r3,12(r16)
  222cf4:	dfc00117 	ldw	ra,4(sp)
  222cf8:	dc000017 	ldw	r16,0(sp)
  222cfc:	dec00204 	addi	sp,sp,8
  222d00:	f800283a 	ret

00222d04 <__seofread>:
  222d04:	0005883a 	mov	r2,zero
  222d08:	f800283a 	ret

00222d0c <__swrite>:
  222d0c:	2880030b 	ldhu	r2,12(r5)
  222d10:	defffb04 	addi	sp,sp,-20
  222d14:	dcc00315 	stw	r19,12(sp)
  222d18:	dc800215 	stw	r18,8(sp)
  222d1c:	dc400115 	stw	r17,4(sp)
  222d20:	dc000015 	stw	r16,0(sp)
  222d24:	dfc00415 	stw	ra,16(sp)
  222d28:	10c0400c 	andi	r3,r2,256
  222d2c:	2821883a 	mov	r16,r5
  222d30:	2027883a 	mov	r19,r4
  222d34:	3025883a 	mov	r18,r6
  222d38:	3823883a 	mov	r17,r7
  222d3c:	18000526 	beq	r3,zero,222d54 <__swrite+0x48>
  222d40:	2940038f 	ldh	r5,14(r5)
  222d44:	000d883a 	mov	r6,zero
  222d48:	01c00084 	movi	r7,2
  222d4c:	022305c0 	call	22305c <_lseek_r>
  222d50:	8080030b 	ldhu	r2,12(r16)
  222d54:	8140038f 	ldh	r5,14(r16)
  222d58:	10bbffcc 	andi	r2,r2,61439
  222d5c:	9809883a 	mov	r4,r19
  222d60:	900d883a 	mov	r6,r18
  222d64:	880f883a 	mov	r7,r17
  222d68:	8080030d 	sth	r2,12(r16)
  222d6c:	dfc00417 	ldw	ra,16(sp)
  222d70:	dcc00317 	ldw	r19,12(sp)
  222d74:	dc800217 	ldw	r18,8(sp)
  222d78:	dc400117 	ldw	r17,4(sp)
  222d7c:	dc000017 	ldw	r16,0(sp)
  222d80:	dec00504 	addi	sp,sp,20
  222d84:	0222dec1 	jmpi	222dec <_write_r>

00222d88 <__sseek>:
  222d88:	defffe04 	addi	sp,sp,-8
  222d8c:	dc000015 	stw	r16,0(sp)
  222d90:	2821883a 	mov	r16,r5
  222d94:	2940038f 	ldh	r5,14(r5)
  222d98:	dfc00115 	stw	ra,4(sp)
  222d9c:	022305c0 	call	22305c <_lseek_r>
  222da0:	00ffffc4 	movi	r3,-1
  222da4:	10c00826 	beq	r2,r3,222dc8 <__sseek+0x40>
  222da8:	80c0030b 	ldhu	r3,12(r16)
  222dac:	80801415 	stw	r2,80(r16)
  222db0:	18c40014 	ori	r3,r3,4096
  222db4:	80c0030d 	sth	r3,12(r16)
  222db8:	dfc00117 	ldw	ra,4(sp)
  222dbc:	dc000017 	ldw	r16,0(sp)
  222dc0:	dec00204 	addi	sp,sp,8
  222dc4:	f800283a 	ret
  222dc8:	80c0030b 	ldhu	r3,12(r16)
  222dcc:	18fbffcc 	andi	r3,r3,61439
  222dd0:	80c0030d 	sth	r3,12(r16)
  222dd4:	dfc00117 	ldw	ra,4(sp)
  222dd8:	dc000017 	ldw	r16,0(sp)
  222ddc:	dec00204 	addi	sp,sp,8
  222de0:	f800283a 	ret

00222de4 <__sclose>:
  222de4:	2940038f 	ldh	r5,14(r5)
  222de8:	0222e481 	jmpi	222e48 <_close_r>

00222dec <_write_r>:
  222dec:	defffd04 	addi	sp,sp,-12
  222df0:	dc000015 	stw	r16,0(sp)
  222df4:	040008f4 	movhi	r16,35
  222df8:	dc400115 	stw	r17,4(sp)
  222dfc:	8429ca04 	addi	r16,r16,-22744
  222e00:	2023883a 	mov	r17,r4
  222e04:	2809883a 	mov	r4,r5
  222e08:	300b883a 	mov	r5,r6
  222e0c:	380d883a 	mov	r6,r7
  222e10:	dfc00215 	stw	ra,8(sp)
  222e14:	80000015 	stw	zero,0(r16)
  222e18:	0223c2c0 	call	223c2c <write>
  222e1c:	00ffffc4 	movi	r3,-1
  222e20:	10c00526 	beq	r2,r3,222e38 <_write_r+0x4c>
  222e24:	dfc00217 	ldw	ra,8(sp)
  222e28:	dc400117 	ldw	r17,4(sp)
  222e2c:	dc000017 	ldw	r16,0(sp)
  222e30:	dec00304 	addi	sp,sp,12
  222e34:	f800283a 	ret
  222e38:	80c00017 	ldw	r3,0(r16)
  222e3c:	183ff926 	beq	r3,zero,222e24 <__alt_data_end+0xfffef5a4>
  222e40:	88c00015 	stw	r3,0(r17)
  222e44:	003ff706 	br	222e24 <__alt_data_end+0xfffef5a4>

00222e48 <_close_r>:
  222e48:	defffd04 	addi	sp,sp,-12
  222e4c:	dc000015 	stw	r16,0(sp)
  222e50:	040008f4 	movhi	r16,35
  222e54:	dc400115 	stw	r17,4(sp)
  222e58:	8429ca04 	addi	r16,r16,-22744
  222e5c:	2023883a 	mov	r17,r4
  222e60:	2809883a 	mov	r4,r5
  222e64:	dfc00215 	stw	ra,8(sp)
  222e68:	80000015 	stw	zero,0(r16)
  222e6c:	02231640 	call	223164 <close>
  222e70:	00ffffc4 	movi	r3,-1
  222e74:	10c00526 	beq	r2,r3,222e8c <_close_r+0x44>
  222e78:	dfc00217 	ldw	ra,8(sp)
  222e7c:	dc400117 	ldw	r17,4(sp)
  222e80:	dc000017 	ldw	r16,0(sp)
  222e84:	dec00304 	addi	sp,sp,12
  222e88:	f800283a 	ret
  222e8c:	80c00017 	ldw	r3,0(r16)
  222e90:	183ff926 	beq	r3,zero,222e78 <__alt_data_end+0xfffef5f8>
  222e94:	88c00015 	stw	r3,0(r17)
  222e98:	003ff706 	br	222e78 <__alt_data_end+0xfffef5f8>

00222e9c <_fclose_r>:
  222e9c:	28003226 	beq	r5,zero,222f68 <_fclose_r+0xcc>
  222ea0:	defffc04 	addi	sp,sp,-16
  222ea4:	dc400115 	stw	r17,4(sp)
  222ea8:	2023883a 	mov	r17,r4
  222eac:	dc000015 	stw	r16,0(sp)
  222eb0:	dfc00315 	stw	ra,12(sp)
  222eb4:	dc800215 	stw	r18,8(sp)
  222eb8:	2821883a 	mov	r16,r5
  222ebc:	02224100 	call	222410 <__sfp_lock_acquire>
  222ec0:	88000226 	beq	r17,zero,222ecc <_fclose_r+0x30>
  222ec4:	88800e17 	ldw	r2,56(r17)
  222ec8:	10002926 	beq	r2,zero,222f70 <_fclose_r+0xd4>
  222ecc:	8080030f 	ldh	r2,12(r16)
  222ed0:	10002226 	beq	r2,zero,222f5c <_fclose_r+0xc0>
  222ed4:	8809883a 	mov	r4,r17
  222ed8:	800b883a 	mov	r5,r16
  222edc:	0221e580 	call	221e58 <_fflush_r>
  222ee0:	1025883a 	mov	r18,r2
  222ee4:	80800b17 	ldw	r2,44(r16)
  222ee8:	10000426 	beq	r2,zero,222efc <_fclose_r+0x60>
  222eec:	81400717 	ldw	r5,28(r16)
  222ef0:	8809883a 	mov	r4,r17
  222ef4:	103ee83a 	callr	r2
  222ef8:	10002616 	blt	r2,zero,222f94 <_fclose_r+0xf8>
  222efc:	8080030b 	ldhu	r2,12(r16)
  222f00:	1080200c 	andi	r2,r2,128
  222f04:	10001f1e 	bne	r2,zero,222f84 <_fclose_r+0xe8>
  222f08:	81400c17 	ldw	r5,48(r16)
  222f0c:	28000526 	beq	r5,zero,222f24 <_fclose_r+0x88>
  222f10:	80801004 	addi	r2,r16,64
  222f14:	28800226 	beq	r5,r2,222f20 <_fclose_r+0x84>
  222f18:	8809883a 	mov	r4,r17
  222f1c:	02225740 	call	222574 <_free_r>
  222f20:	80000c15 	stw	zero,48(r16)
  222f24:	81401117 	ldw	r5,68(r16)
  222f28:	28000326 	beq	r5,zero,222f38 <_fclose_r+0x9c>
  222f2c:	8809883a 	mov	r4,r17
  222f30:	02225740 	call	222574 <_free_r>
  222f34:	80001115 	stw	zero,68(r16)
  222f38:	8000030d 	sth	zero,12(r16)
  222f3c:	02224140 	call	222414 <__sfp_lock_release>
  222f40:	9005883a 	mov	r2,r18
  222f44:	dfc00317 	ldw	ra,12(sp)
  222f48:	dc800217 	ldw	r18,8(sp)
  222f4c:	dc400117 	ldw	r17,4(sp)
  222f50:	dc000017 	ldw	r16,0(sp)
  222f54:	dec00404 	addi	sp,sp,16
  222f58:	f800283a 	ret
  222f5c:	02224140 	call	222414 <__sfp_lock_release>
  222f60:	0005883a 	mov	r2,zero
  222f64:	003ff706 	br	222f44 <__alt_data_end+0xfffef6c4>
  222f68:	0005883a 	mov	r2,zero
  222f6c:	f800283a 	ret
  222f70:	8809883a 	mov	r4,r17
  222f74:	02224000 	call	222400 <__sinit>
  222f78:	8080030f 	ldh	r2,12(r16)
  222f7c:	103fd51e 	bne	r2,zero,222ed4 <__alt_data_end+0xfffef654>
  222f80:	003ff606 	br	222f5c <__alt_data_end+0xfffef6dc>
  222f84:	81400417 	ldw	r5,16(r16)
  222f88:	8809883a 	mov	r4,r17
  222f8c:	02225740 	call	222574 <_free_r>
  222f90:	003fdd06 	br	222f08 <__alt_data_end+0xfffef688>
  222f94:	04bfffc4 	movi	r18,-1
  222f98:	003fd806 	br	222efc <__alt_data_end+0xfffef67c>

00222f9c <fclose>:
  222f9c:	008008f4 	movhi	r2,35
  222fa0:	10a2d404 	addi	r2,r2,-29872
  222fa4:	200b883a 	mov	r5,r4
  222fa8:	11000017 	ldw	r4,0(r2)
  222fac:	0222e9c1 	jmpi	222e9c <_fclose_r>

00222fb0 <_fstat_r>:
  222fb0:	defffd04 	addi	sp,sp,-12
  222fb4:	dc000015 	stw	r16,0(sp)
  222fb8:	040008f4 	movhi	r16,35
  222fbc:	dc400115 	stw	r17,4(sp)
  222fc0:	8429ca04 	addi	r16,r16,-22744
  222fc4:	2023883a 	mov	r17,r4
  222fc8:	2809883a 	mov	r4,r5
  222fcc:	300b883a 	mov	r5,r6
  222fd0:	dfc00215 	stw	ra,8(sp)
  222fd4:	80000015 	stw	zero,0(r16)
  222fd8:	02232b00 	call	2232b0 <fstat>
  222fdc:	00ffffc4 	movi	r3,-1
  222fe0:	10c00526 	beq	r2,r3,222ff8 <_fstat_r+0x48>
  222fe4:	dfc00217 	ldw	ra,8(sp)
  222fe8:	dc400117 	ldw	r17,4(sp)
  222fec:	dc000017 	ldw	r16,0(sp)
  222ff0:	dec00304 	addi	sp,sp,12
  222ff4:	f800283a 	ret
  222ff8:	80c00017 	ldw	r3,0(r16)
  222ffc:	183ff926 	beq	r3,zero,222fe4 <__alt_data_end+0xfffef764>
  223000:	88c00015 	stw	r3,0(r17)
  223004:	003ff706 	br	222fe4 <__alt_data_end+0xfffef764>

00223008 <_isatty_r>:
  223008:	defffd04 	addi	sp,sp,-12
  22300c:	dc000015 	stw	r16,0(sp)
  223010:	040008f4 	movhi	r16,35
  223014:	dc400115 	stw	r17,4(sp)
  223018:	8429ca04 	addi	r16,r16,-22744
  22301c:	2023883a 	mov	r17,r4
  223020:	2809883a 	mov	r4,r5
  223024:	dfc00215 	stw	ra,8(sp)
  223028:	80000015 	stw	zero,0(r16)
  22302c:	02233b00 	call	2233b0 <isatty>
  223030:	00ffffc4 	movi	r3,-1
  223034:	10c00526 	beq	r2,r3,22304c <_isatty_r+0x44>
  223038:	dfc00217 	ldw	ra,8(sp)
  22303c:	dc400117 	ldw	r17,4(sp)
  223040:	dc000017 	ldw	r16,0(sp)
  223044:	dec00304 	addi	sp,sp,12
  223048:	f800283a 	ret
  22304c:	80c00017 	ldw	r3,0(r16)
  223050:	183ff926 	beq	r3,zero,223038 <__alt_data_end+0xfffef7b8>
  223054:	88c00015 	stw	r3,0(r17)
  223058:	003ff706 	br	223038 <__alt_data_end+0xfffef7b8>

0022305c <_lseek_r>:
  22305c:	defffd04 	addi	sp,sp,-12
  223060:	dc000015 	stw	r16,0(sp)
  223064:	040008f4 	movhi	r16,35
  223068:	dc400115 	stw	r17,4(sp)
  22306c:	8429ca04 	addi	r16,r16,-22744
  223070:	2023883a 	mov	r17,r4
  223074:	2809883a 	mov	r4,r5
  223078:	300b883a 	mov	r5,r6
  22307c:	380d883a 	mov	r6,r7
  223080:	dfc00215 	stw	ra,8(sp)
  223084:	80000015 	stw	zero,0(r16)
  223088:	02235880 	call	223588 <lseek>
  22308c:	00ffffc4 	movi	r3,-1
  223090:	10c00526 	beq	r2,r3,2230a8 <_lseek_r+0x4c>
  223094:	dfc00217 	ldw	ra,8(sp)
  223098:	dc400117 	ldw	r17,4(sp)
  22309c:	dc000017 	ldw	r16,0(sp)
  2230a0:	dec00304 	addi	sp,sp,12
  2230a4:	f800283a 	ret
  2230a8:	80c00017 	ldw	r3,0(r16)
  2230ac:	183ff926 	beq	r3,zero,223094 <__alt_data_end+0xfffef814>
  2230b0:	88c00015 	stw	r3,0(r17)
  2230b4:	003ff706 	br	223094 <__alt_data_end+0xfffef814>

002230b8 <_read_r>:
  2230b8:	defffd04 	addi	sp,sp,-12
  2230bc:	dc000015 	stw	r16,0(sp)
  2230c0:	040008f4 	movhi	r16,35
  2230c4:	dc400115 	stw	r17,4(sp)
  2230c8:	8429ca04 	addi	r16,r16,-22744
  2230cc:	2023883a 	mov	r17,r4
  2230d0:	2809883a 	mov	r4,r5
  2230d4:	300b883a 	mov	r5,r6
  2230d8:	380d883a 	mov	r6,r7
  2230dc:	dfc00215 	stw	ra,8(sp)
  2230e0:	80000015 	stw	zero,0(r16)
  2230e4:	02239d00 	call	2239d0 <read>
  2230e8:	00ffffc4 	movi	r3,-1
  2230ec:	10c00526 	beq	r2,r3,223104 <_read_r+0x4c>
  2230f0:	dfc00217 	ldw	ra,8(sp)
  2230f4:	dc400117 	ldw	r17,4(sp)
  2230f8:	dc000017 	ldw	r16,0(sp)
  2230fc:	dec00304 	addi	sp,sp,12
  223100:	f800283a 	ret
  223104:	80c00017 	ldw	r3,0(r16)
  223108:	183ff926 	beq	r3,zero,2230f0 <__alt_data_end+0xfffef870>
  22310c:	88c00015 	stw	r3,0(r17)
  223110:	003ff706 	br	2230f0 <__alt_data_end+0xfffef870>

00223114 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  223114:	defffe04 	addi	sp,sp,-8
  223118:	dfc00115 	stw	ra,4(sp)
  22311c:	df000015 	stw	fp,0(sp)
  223120:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  223124:	008008f4 	movhi	r2,35
  223128:	10a2dc04 	addi	r2,r2,-29840
  22312c:	10800017 	ldw	r2,0(r2)
  223130:	10000526 	beq	r2,zero,223148 <alt_get_errno+0x34>
  223134:	008008f4 	movhi	r2,35
  223138:	10a2dc04 	addi	r2,r2,-29840
  22313c:	10800017 	ldw	r2,0(r2)
  223140:	103ee83a 	callr	r2
  223144:	00000206 	br	223150 <alt_get_errno+0x3c>
  223148:	008008f4 	movhi	r2,35
  22314c:	10a9ca04 	addi	r2,r2,-22744
}
  223150:	e037883a 	mov	sp,fp
  223154:	dfc00117 	ldw	ra,4(sp)
  223158:	df000017 	ldw	fp,0(sp)
  22315c:	dec00204 	addi	sp,sp,8
  223160:	f800283a 	ret

00223164 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
  223164:	defffb04 	addi	sp,sp,-20
  223168:	dfc00415 	stw	ra,16(sp)
  22316c:	df000315 	stw	fp,12(sp)
  223170:	df000304 	addi	fp,sp,12
  223174:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
  223178:	e0bfff17 	ldw	r2,-4(fp)
  22317c:	10000616 	blt	r2,zero,223198 <close+0x34>
  223180:	e0bfff17 	ldw	r2,-4(fp)
  223184:	10c00324 	muli	r3,r2,12
  223188:	008008b4 	movhi	r2,34
  22318c:	109e1404 	addi	r2,r2,30800
  223190:	1885883a 	add	r2,r3,r2
  223194:	00000106 	br	22319c <close+0x38>
  223198:	0005883a 	mov	r2,zero
  22319c:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
  2231a0:	e0bffd17 	ldw	r2,-12(fp)
  2231a4:	10001926 	beq	r2,zero,22320c <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
  2231a8:	e0bffd17 	ldw	r2,-12(fp)
  2231ac:	10800017 	ldw	r2,0(r2)
  2231b0:	10800417 	ldw	r2,16(r2)
  2231b4:	10000626 	beq	r2,zero,2231d0 <close+0x6c>
  2231b8:	e0bffd17 	ldw	r2,-12(fp)
  2231bc:	10800017 	ldw	r2,0(r2)
  2231c0:	10800417 	ldw	r2,16(r2)
  2231c4:	e13ffd17 	ldw	r4,-12(fp)
  2231c8:	103ee83a 	callr	r2
  2231cc:	00000106 	br	2231d4 <close+0x70>
  2231d0:	0005883a 	mov	r2,zero
  2231d4:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
  2231d8:	e13fff17 	ldw	r4,-4(fp)
  2231dc:	0223acc0 	call	223acc <alt_release_fd>
    if (rval < 0)
  2231e0:	e0bffe17 	ldw	r2,-8(fp)
  2231e4:	1000070e 	bge	r2,zero,223204 <close+0xa0>
    {
      ALT_ERRNO = -rval;
  2231e8:	02231140 	call	223114 <alt_get_errno>
  2231ec:	1007883a 	mov	r3,r2
  2231f0:	e0bffe17 	ldw	r2,-8(fp)
  2231f4:	0085c83a 	sub	r2,zero,r2
  2231f8:	18800015 	stw	r2,0(r3)
      return -1;
  2231fc:	00bfffc4 	movi	r2,-1
  223200:	00000706 	br	223220 <close+0xbc>
    }
    return 0;
  223204:	0005883a 	mov	r2,zero
  223208:	00000506 	br	223220 <close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
  22320c:	02231140 	call	223114 <alt_get_errno>
  223210:	1007883a 	mov	r3,r2
  223214:	00801444 	movi	r2,81
  223218:	18800015 	stw	r2,0(r3)
    return -1;
  22321c:	00bfffc4 	movi	r2,-1
  }
}
  223220:	e037883a 	mov	sp,fp
  223224:	dfc00117 	ldw	ra,4(sp)
  223228:	df000017 	ldw	fp,0(sp)
  22322c:	dec00204 	addi	sp,sp,8
  223230:	f800283a 	ret

00223234 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  223234:	defffc04 	addi	sp,sp,-16
  223238:	df000315 	stw	fp,12(sp)
  22323c:	df000304 	addi	fp,sp,12
  223240:	e13ffd15 	stw	r4,-12(fp)
  223244:	e17ffe15 	stw	r5,-8(fp)
  223248:	e1bfff15 	stw	r6,-4(fp)
  return len;
  22324c:	e0bfff17 	ldw	r2,-4(fp)
}
  223250:	e037883a 	mov	sp,fp
  223254:	df000017 	ldw	fp,0(sp)
  223258:	dec00104 	addi	sp,sp,4
  22325c:	f800283a 	ret

00223260 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  223260:	defffe04 	addi	sp,sp,-8
  223264:	dfc00115 	stw	ra,4(sp)
  223268:	df000015 	stw	fp,0(sp)
  22326c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  223270:	008008f4 	movhi	r2,35
  223274:	10a2dc04 	addi	r2,r2,-29840
  223278:	10800017 	ldw	r2,0(r2)
  22327c:	10000526 	beq	r2,zero,223294 <alt_get_errno+0x34>
  223280:	008008f4 	movhi	r2,35
  223284:	10a2dc04 	addi	r2,r2,-29840
  223288:	10800017 	ldw	r2,0(r2)
  22328c:	103ee83a 	callr	r2
  223290:	00000206 	br	22329c <alt_get_errno+0x3c>
  223294:	008008f4 	movhi	r2,35
  223298:	10a9ca04 	addi	r2,r2,-22744
}
  22329c:	e037883a 	mov	sp,fp
  2232a0:	dfc00117 	ldw	ra,4(sp)
  2232a4:	df000017 	ldw	fp,0(sp)
  2232a8:	dec00204 	addi	sp,sp,8
  2232ac:	f800283a 	ret

002232b0 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
  2232b0:	defffb04 	addi	sp,sp,-20
  2232b4:	dfc00415 	stw	ra,16(sp)
  2232b8:	df000315 	stw	fp,12(sp)
  2232bc:	df000304 	addi	fp,sp,12
  2232c0:	e13ffe15 	stw	r4,-8(fp)
  2232c4:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  2232c8:	e0bffe17 	ldw	r2,-8(fp)
  2232cc:	10000616 	blt	r2,zero,2232e8 <fstat+0x38>
  2232d0:	e0bffe17 	ldw	r2,-8(fp)
  2232d4:	10c00324 	muli	r3,r2,12
  2232d8:	008008b4 	movhi	r2,34
  2232dc:	109e1404 	addi	r2,r2,30800
  2232e0:	1885883a 	add	r2,r3,r2
  2232e4:	00000106 	br	2232ec <fstat+0x3c>
  2232e8:	0005883a 	mov	r2,zero
  2232ec:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
  2232f0:	e0bffd17 	ldw	r2,-12(fp)
  2232f4:	10001026 	beq	r2,zero,223338 <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
  2232f8:	e0bffd17 	ldw	r2,-12(fp)
  2232fc:	10800017 	ldw	r2,0(r2)
  223300:	10800817 	ldw	r2,32(r2)
  223304:	10000726 	beq	r2,zero,223324 <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
  223308:	e0bffd17 	ldw	r2,-12(fp)
  22330c:	10800017 	ldw	r2,0(r2)
  223310:	10800817 	ldw	r2,32(r2)
  223314:	e13ffd17 	ldw	r4,-12(fp)
  223318:	e17fff17 	ldw	r5,-4(fp)
  22331c:	103ee83a 	callr	r2
  223320:	00000a06 	br	22334c <fstat+0x9c>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
  223324:	e0bfff17 	ldw	r2,-4(fp)
  223328:	00c80004 	movi	r3,8192
  22332c:	10c00115 	stw	r3,4(r2)
      return 0;
  223330:	0005883a 	mov	r2,zero
  223334:	00000506 	br	22334c <fstat+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
  223338:	02232600 	call	223260 <alt_get_errno>
  22333c:	1007883a 	mov	r3,r2
  223340:	00801444 	movi	r2,81
  223344:	18800015 	stw	r2,0(r3)
    return -1;
  223348:	00bfffc4 	movi	r2,-1
  }
}
  22334c:	e037883a 	mov	sp,fp
  223350:	dfc00117 	ldw	ra,4(sp)
  223354:	df000017 	ldw	fp,0(sp)
  223358:	dec00204 	addi	sp,sp,8
  22335c:	f800283a 	ret

00223360 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  223360:	defffe04 	addi	sp,sp,-8
  223364:	dfc00115 	stw	ra,4(sp)
  223368:	df000015 	stw	fp,0(sp)
  22336c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  223370:	008008f4 	movhi	r2,35
  223374:	10a2dc04 	addi	r2,r2,-29840
  223378:	10800017 	ldw	r2,0(r2)
  22337c:	10000526 	beq	r2,zero,223394 <alt_get_errno+0x34>
  223380:	008008f4 	movhi	r2,35
  223384:	10a2dc04 	addi	r2,r2,-29840
  223388:	10800017 	ldw	r2,0(r2)
  22338c:	103ee83a 	callr	r2
  223390:	00000206 	br	22339c <alt_get_errno+0x3c>
  223394:	008008f4 	movhi	r2,35
  223398:	10a9ca04 	addi	r2,r2,-22744
}
  22339c:	e037883a 	mov	sp,fp
  2233a0:	dfc00117 	ldw	ra,4(sp)
  2233a4:	df000017 	ldw	fp,0(sp)
  2233a8:	dec00204 	addi	sp,sp,8
  2233ac:	f800283a 	ret

002233b0 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
  2233b0:	deffed04 	addi	sp,sp,-76
  2233b4:	dfc01215 	stw	ra,72(sp)
  2233b8:	df001115 	stw	fp,68(sp)
  2233bc:	df001104 	addi	fp,sp,68
  2233c0:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  2233c4:	e0bfff17 	ldw	r2,-4(fp)
  2233c8:	10000616 	blt	r2,zero,2233e4 <isatty+0x34>
  2233cc:	e0bfff17 	ldw	r2,-4(fp)
  2233d0:	10c00324 	muli	r3,r2,12
  2233d4:	008008b4 	movhi	r2,34
  2233d8:	109e1404 	addi	r2,r2,30800
  2233dc:	1885883a 	add	r2,r3,r2
  2233e0:	00000106 	br	2233e8 <isatty+0x38>
  2233e4:	0005883a 	mov	r2,zero
  2233e8:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
  2233ec:	e0bfef17 	ldw	r2,-68(fp)
  2233f0:	10000e26 	beq	r2,zero,22342c <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
  2233f4:	e0bfef17 	ldw	r2,-68(fp)
  2233f8:	10800017 	ldw	r2,0(r2)
  2233fc:	10800817 	ldw	r2,32(r2)
  223400:	1000021e 	bne	r2,zero,22340c <isatty+0x5c>
    {
      return 1;
  223404:	00800044 	movi	r2,1
  223408:	00000d06 	br	223440 <isatty+0x90>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
  22340c:	e0bff004 	addi	r2,fp,-64
  223410:	e13fff17 	ldw	r4,-4(fp)
  223414:	100b883a 	mov	r5,r2
  223418:	02232b00 	call	2232b0 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
  22341c:	e0bff117 	ldw	r2,-60(fp)
  223420:	10880020 	cmpeqi	r2,r2,8192
  223424:	10803fcc 	andi	r2,r2,255
  223428:	00000506 	br	223440 <isatty+0x90>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
  22342c:	02233600 	call	223360 <alt_get_errno>
  223430:	1007883a 	mov	r3,r2
  223434:	00801444 	movi	r2,81
  223438:	18800015 	stw	r2,0(r3)
    return 0;
  22343c:	0005883a 	mov	r2,zero
  }
}
  223440:	e037883a 	mov	sp,fp
  223444:	dfc00117 	ldw	ra,4(sp)
  223448:	df000017 	ldw	fp,0(sp)
  22344c:	dec00204 	addi	sp,sp,8
  223450:	f800283a 	ret

00223454 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  223454:	defffc04 	addi	sp,sp,-16
  223458:	df000315 	stw	fp,12(sp)
  22345c:	df000304 	addi	fp,sp,12
  223460:	e13ffd15 	stw	r4,-12(fp)
  223464:	e17ffe15 	stw	r5,-8(fp)
  223468:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
  22346c:	e0fffe17 	ldw	r3,-8(fp)
  223470:	e0bffd17 	ldw	r2,-12(fp)
  223474:	18800c26 	beq	r3,r2,2234a8 <alt_load_section+0x54>
  {
    while( to != end )
  223478:	00000806 	br	22349c <alt_load_section+0x48>
    {
      *to++ = *from++;
  22347c:	e0bffe17 	ldw	r2,-8(fp)
  223480:	10c00104 	addi	r3,r2,4
  223484:	e0fffe15 	stw	r3,-8(fp)
  223488:	e0fffd17 	ldw	r3,-12(fp)
  22348c:	19000104 	addi	r4,r3,4
  223490:	e13ffd15 	stw	r4,-12(fp)
  223494:	18c00017 	ldw	r3,0(r3)
  223498:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
  22349c:	e0fffe17 	ldw	r3,-8(fp)
  2234a0:	e0bfff17 	ldw	r2,-4(fp)
  2234a4:	18bff51e 	bne	r3,r2,22347c <__alt_data_end+0xfffefbfc>
    {
      *to++ = *from++;
    }
  }
}
  2234a8:	e037883a 	mov	sp,fp
  2234ac:	df000017 	ldw	fp,0(sp)
  2234b0:	dec00104 	addi	sp,sp,4
  2234b4:	f800283a 	ret

002234b8 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
  2234b8:	defffe04 	addi	sp,sp,-8
  2234bc:	dfc00115 	stw	ra,4(sp)
  2234c0:	df000015 	stw	fp,0(sp)
  2234c4:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
  2234c8:	010008f4 	movhi	r4,35
  2234cc:	2122e304 	addi	r4,r4,-29812
  2234d0:	014008b4 	movhi	r5,34
  2234d4:	295bff04 	addi	r5,r5,28668
  2234d8:	018008f4 	movhi	r6,35
  2234dc:	31a2e304 	addi	r6,r6,-29812
  2234e0:	02234540 	call	223454 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
  2234e4:	010008b4 	movhi	r4,34
  2234e8:	21000804 	addi	r4,r4,32
  2234ec:	014008b4 	movhi	r5,34
  2234f0:	29400804 	addi	r5,r5,32
  2234f4:	018008b4 	movhi	r6,34
  2234f8:	31809004 	addi	r6,r6,576
  2234fc:	02234540 	call	223454 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
  223500:	010008b4 	movhi	r4,34
  223504:	211baa04 	addi	r4,r4,28328
  223508:	014008b4 	movhi	r5,34
  22350c:	295baa04 	addi	r5,r5,28328
  223510:	018008b4 	movhi	r6,34
  223514:	319bff04 	addi	r6,r6,28668
  223518:	02234540 	call	223454 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  22351c:	02259b00 	call	2259b0 <alt_dcache_flush_all>
  alt_icache_flush_all();
  223520:	0225c300 	call	225c30 <alt_icache_flush_all>
}
  223524:	e037883a 	mov	sp,fp
  223528:	dfc00117 	ldw	ra,4(sp)
  22352c:	df000017 	ldw	fp,0(sp)
  223530:	dec00204 	addi	sp,sp,8
  223534:	f800283a 	ret

00223538 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  223538:	defffe04 	addi	sp,sp,-8
  22353c:	dfc00115 	stw	ra,4(sp)
  223540:	df000015 	stw	fp,0(sp)
  223544:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  223548:	008008f4 	movhi	r2,35
  22354c:	10a2dc04 	addi	r2,r2,-29840
  223550:	10800017 	ldw	r2,0(r2)
  223554:	10000526 	beq	r2,zero,22356c <alt_get_errno+0x34>
  223558:	008008f4 	movhi	r2,35
  22355c:	10a2dc04 	addi	r2,r2,-29840
  223560:	10800017 	ldw	r2,0(r2)
  223564:	103ee83a 	callr	r2
  223568:	00000206 	br	223574 <alt_get_errno+0x3c>
  22356c:	008008f4 	movhi	r2,35
  223570:	10a9ca04 	addi	r2,r2,-22744
}
  223574:	e037883a 	mov	sp,fp
  223578:	dfc00117 	ldw	ra,4(sp)
  22357c:	df000017 	ldw	fp,0(sp)
  223580:	dec00204 	addi	sp,sp,8
  223584:	f800283a 	ret

00223588 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
  223588:	defff904 	addi	sp,sp,-28
  22358c:	dfc00615 	stw	ra,24(sp)
  223590:	df000515 	stw	fp,20(sp)
  223594:	df000504 	addi	fp,sp,20
  223598:	e13ffd15 	stw	r4,-12(fp)
  22359c:	e17ffe15 	stw	r5,-8(fp)
  2235a0:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
  2235a4:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  2235a8:	e0bffd17 	ldw	r2,-12(fp)
  2235ac:	10000616 	blt	r2,zero,2235c8 <lseek+0x40>
  2235b0:	e0bffd17 	ldw	r2,-12(fp)
  2235b4:	10c00324 	muli	r3,r2,12
  2235b8:	008008b4 	movhi	r2,34
  2235bc:	109e1404 	addi	r2,r2,30800
  2235c0:	1885883a 	add	r2,r3,r2
  2235c4:	00000106 	br	2235cc <lseek+0x44>
  2235c8:	0005883a 	mov	r2,zero
  2235cc:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
  2235d0:	e0bffc17 	ldw	r2,-16(fp)
  2235d4:	10001026 	beq	r2,zero,223618 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
  2235d8:	e0bffc17 	ldw	r2,-16(fp)
  2235dc:	10800017 	ldw	r2,0(r2)
  2235e0:	10800717 	ldw	r2,28(r2)
  2235e4:	10000926 	beq	r2,zero,22360c <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
  2235e8:	e0bffc17 	ldw	r2,-16(fp)
  2235ec:	10800017 	ldw	r2,0(r2)
  2235f0:	10800717 	ldw	r2,28(r2)
  2235f4:	e13ffc17 	ldw	r4,-16(fp)
  2235f8:	e17ffe17 	ldw	r5,-8(fp)
  2235fc:	e1bfff17 	ldw	r6,-4(fp)
  223600:	103ee83a 	callr	r2
  223604:	e0bffb15 	stw	r2,-20(fp)
  223608:	00000506 	br	223620 <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
  22360c:	00bfde84 	movi	r2,-134
  223610:	e0bffb15 	stw	r2,-20(fp)
  223614:	00000206 	br	223620 <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
  223618:	00bfebc4 	movi	r2,-81
  22361c:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
  223620:	e0bffb17 	ldw	r2,-20(fp)
  223624:	1000070e 	bge	r2,zero,223644 <lseek+0xbc>
  {
    ALT_ERRNO = -rc;
  223628:	02235380 	call	223538 <alt_get_errno>
  22362c:	1007883a 	mov	r3,r2
  223630:	e0bffb17 	ldw	r2,-20(fp)
  223634:	0085c83a 	sub	r2,zero,r2
  223638:	18800015 	stw	r2,0(r3)
    rc = -1;
  22363c:	00bfffc4 	movi	r2,-1
  223640:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
  223644:	e0bffb17 	ldw	r2,-20(fp)
}
  223648:	e037883a 	mov	sp,fp
  22364c:	dfc00117 	ldw	ra,4(sp)
  223650:	df000017 	ldw	fp,0(sp)
  223654:	dec00204 	addi	sp,sp,8
  223658:	f800283a 	ret

0022365c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
  22365c:	defffd04 	addi	sp,sp,-12
  223660:	dfc00215 	stw	ra,8(sp)
  223664:	df000115 	stw	fp,4(sp)
  223668:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
  22366c:	0009883a 	mov	r4,zero
  223670:	0223e180 	call	223e18 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
  223674:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
  223678:	0223e4c0 	call	223e4c <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
  22367c:	010008b4 	movhi	r4,34
  223680:	211bd904 	addi	r4,r4,28516
  223684:	014008b4 	movhi	r5,34
  223688:	295bd904 	addi	r5,r5,28516
  22368c:	018008b4 	movhi	r6,34
  223690:	319bd904 	addi	r6,r6,28516
  223694:	0225ff00 	call	225ff0 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
  223698:	0225ae80 	call	225ae8 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
  22369c:	010008b4 	movhi	r4,34
  2236a0:	2116d104 	addi	r4,r4,23364
  2236a4:	02267880 	call	226788 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
  2236a8:	d126f817 	ldw	r4,-25632(gp)
  2236ac:	d0e6f917 	ldw	r3,-25628(gp)
  2236b0:	d0a6fa17 	ldw	r2,-25624(gp)
  2236b4:	180b883a 	mov	r5,r3
  2236b8:	100d883a 	mov	r6,r2
  2236bc:	022028c0 	call	22028c <main>
  2236c0:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
  2236c4:	01000044 	movi	r4,1
  2236c8:	02231640 	call	223164 <close>
  exit (result);
  2236cc:	e13fff17 	ldw	r4,-4(fp)
  2236d0:	022679c0 	call	22679c <exit>

002236d4 <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
  2236d4:	defffe04 	addi	sp,sp,-8
  2236d8:	df000115 	stw	fp,4(sp)
  2236dc:	df000104 	addi	fp,sp,4
  2236e0:	e13fff15 	stw	r4,-4(fp)
}
  2236e4:	e037883a 	mov	sp,fp
  2236e8:	df000017 	ldw	fp,0(sp)
  2236ec:	dec00104 	addi	sp,sp,4
  2236f0:	f800283a 	ret

002236f4 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
  2236f4:	defffe04 	addi	sp,sp,-8
  2236f8:	df000115 	stw	fp,4(sp)
  2236fc:	df000104 	addi	fp,sp,4
  223700:	e13fff15 	stw	r4,-4(fp)
}
  223704:	e037883a 	mov	sp,fp
  223708:	df000017 	ldw	fp,0(sp)
  22370c:	dec00104 	addi	sp,sp,4
  223710:	f800283a 	ret

00223714 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
  223714:	defff204 	addi	sp,sp,-56
  223718:	dfc00a15 	stw	ra,40(sp)
  22371c:	df000915 	stw	fp,36(sp)
  223720:	df000904 	addi	fp,sp,36
  223724:	e1400215 	stw	r5,8(fp)
  223728:	e1800315 	stw	r6,12(fp)
  22372c:	e1c00415 	stw	r7,16(fp)
  223730:	e13fff15 	stw	r4,-4(fp)
	va_list args;
	va_start(args, fmt);
  223734:	e0800204 	addi	r2,fp,8
  223738:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
  22373c:	e0bfff17 	ldw	r2,-4(fp)
  223740:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
  223744:	00007106 	br	22390c <alt_printf+0x1f8>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
  223748:	e0bff807 	ldb	r2,-32(fp)
  22374c:	10800960 	cmpeqi	r2,r2,37
  223750:	1000041e 	bne	r2,zero,223764 <alt_printf+0x50>
        {
            alt_putchar(c);
  223754:	e0bff807 	ldb	r2,-32(fp)
  223758:	1009883a 	mov	r4,r2
  22375c:	022393c0 	call	22393c <alt_putchar>
  223760:	00006a06 	br	22390c <alt_printf+0x1f8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
  223764:	e0bff717 	ldw	r2,-36(fp)
  223768:	10c00044 	addi	r3,r2,1
  22376c:	e0fff715 	stw	r3,-36(fp)
  223770:	10800003 	ldbu	r2,0(r2)
  223774:	e0bff805 	stb	r2,-32(fp)
  223778:	e0bff807 	ldb	r2,-32(fp)
  22377c:	10006226 	beq	r2,zero,223908 <alt_printf+0x1f4>
            {
                if (c == '%')
  223780:	e0bff807 	ldb	r2,-32(fp)
  223784:	10800958 	cmpnei	r2,r2,37
  223788:	1000041e 	bne	r2,zero,22379c <alt_printf+0x88>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
  22378c:	e0bff807 	ldb	r2,-32(fp)
  223790:	1009883a 	mov	r4,r2
  223794:	022393c0 	call	22393c <alt_putchar>
  223798:	00005c06 	br	22390c <alt_printf+0x1f8>
                } 
                else if (c == 'c')
  22379c:	e0bff807 	ldb	r2,-32(fp)
  2237a0:	108018d8 	cmpnei	r2,r2,99
  2237a4:	1000081e 	bne	r2,zero,2237c8 <alt_printf+0xb4>
                {
                    int v = va_arg(args, int);
  2237a8:	e0bffe17 	ldw	r2,-8(fp)
  2237ac:	10c00104 	addi	r3,r2,4
  2237b0:	e0fffe15 	stw	r3,-8(fp)
  2237b4:	10800017 	ldw	r2,0(r2)
  2237b8:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
  2237bc:	e13ffd17 	ldw	r4,-12(fp)
  2237c0:	022393c0 	call	22393c <alt_putchar>
  2237c4:	00005106 	br	22390c <alt_printf+0x1f8>
                }
                else if (c == 'x')
  2237c8:	e0bff807 	ldb	r2,-32(fp)
  2237cc:	10801e18 	cmpnei	r2,r2,120
  2237d0:	1000341e 	bne	r2,zero,2238a4 <alt_printf+0x190>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
  2237d4:	e0bffe17 	ldw	r2,-8(fp)
  2237d8:	10c00104 	addi	r3,r2,4
  2237dc:	e0fffe15 	stw	r3,-8(fp)
  2237e0:	10800017 	ldw	r2,0(r2)
  2237e4:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
  2237e8:	e0bffb17 	ldw	r2,-20(fp)
  2237ec:	1000031e 	bne	r2,zero,2237fc <alt_printf+0xe8>
                    {
                        alt_putchar('0');
  2237f0:	01000c04 	movi	r4,48
  2237f4:	022393c0 	call	22393c <alt_putchar>
                        continue;
  2237f8:	00004406 	br	22390c <alt_printf+0x1f8>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
  2237fc:	00800704 	movi	r2,28
  223800:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
  223804:	00000306 	br	223814 <alt_printf+0x100>
                        digit_shift -= 4;
  223808:	e0bff917 	ldw	r2,-28(fp)
  22380c:	10bfff04 	addi	r2,r2,-4
  223810:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
  223814:	00c003c4 	movi	r3,15
  223818:	e0bff917 	ldw	r2,-28(fp)
  22381c:	1884983a 	sll	r2,r3,r2
  223820:	1007883a 	mov	r3,r2
  223824:	e0bffb17 	ldw	r2,-20(fp)
  223828:	1884703a 	and	r2,r3,r2
  22382c:	103ff626 	beq	r2,zero,223808 <__alt_data_end+0xfffeff88>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
  223830:	00001906 	br	223898 <alt_printf+0x184>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
  223834:	00c003c4 	movi	r3,15
  223838:	e0bff917 	ldw	r2,-28(fp)
  22383c:	1884983a 	sll	r2,r3,r2
  223840:	1007883a 	mov	r3,r2
  223844:	e0bffb17 	ldw	r2,-20(fp)
  223848:	1886703a 	and	r3,r3,r2
  22384c:	e0bff917 	ldw	r2,-28(fp)
  223850:	1884d83a 	srl	r2,r3,r2
  223854:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
  223858:	e0bffc17 	ldw	r2,-16(fp)
  22385c:	108002a8 	cmpgeui	r2,r2,10
  223860:	1000041e 	bne	r2,zero,223874 <alt_printf+0x160>
                            c = '0' + digit;
  223864:	e0bffc17 	ldw	r2,-16(fp)
  223868:	10800c04 	addi	r2,r2,48
  22386c:	e0bff805 	stb	r2,-32(fp)
  223870:	00000306 	br	223880 <alt_printf+0x16c>
                        else
                            c = 'a' + digit - 10;
  223874:	e0bffc17 	ldw	r2,-16(fp)
  223878:	108015c4 	addi	r2,r2,87
  22387c:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
  223880:	e0bff807 	ldb	r2,-32(fp)
  223884:	1009883a 	mov	r4,r2
  223888:	022393c0 	call	22393c <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
  22388c:	e0bff917 	ldw	r2,-28(fp)
  223890:	10bfff04 	addi	r2,r2,-4
  223894:	e0bff915 	stw	r2,-28(fp)
  223898:	e0bff917 	ldw	r2,-28(fp)
  22389c:	103fe50e 	bge	r2,zero,223834 <__alt_data_end+0xfffeffb4>
  2238a0:	00001a06 	br	22390c <alt_printf+0x1f8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
  2238a4:	e0bff807 	ldb	r2,-32(fp)
  2238a8:	10801cd8 	cmpnei	r2,r2,115
  2238ac:	1000151e 	bne	r2,zero,223904 <alt_printf+0x1f0>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
  2238b0:	e0bffe17 	ldw	r2,-8(fp)
  2238b4:	10c00104 	addi	r3,r2,4
  2238b8:	e0fffe15 	stw	r3,-8(fp)
  2238bc:	10800017 	ldw	r2,0(r2)
  2238c0:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
  2238c4:	00000906 	br	2238ec <alt_printf+0x1d8>
                      alt_putchar(*s++);
  2238c8:	e0bffa17 	ldw	r2,-24(fp)
  2238cc:	10c00044 	addi	r3,r2,1
  2238d0:	e0fffa15 	stw	r3,-24(fp)
  2238d4:	10800003 	ldbu	r2,0(r2)
  2238d8:	10803fcc 	andi	r2,r2,255
  2238dc:	1080201c 	xori	r2,r2,128
  2238e0:	10bfe004 	addi	r2,r2,-128
  2238e4:	1009883a 	mov	r4,r2
  2238e8:	022393c0 	call	22393c <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
  2238ec:	e0bffa17 	ldw	r2,-24(fp)
  2238f0:	10800003 	ldbu	r2,0(r2)
  2238f4:	10803fcc 	andi	r2,r2,255
  2238f8:	1080201c 	xori	r2,r2,128
  2238fc:	10bfe004 	addi	r2,r2,-128
  223900:	103ff11e 	bne	r2,zero,2238c8 <__alt_data_end+0xffff0048>
  223904:	00000106 	br	22390c <alt_printf+0x1f8>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
  223908:	00000706 	br	223928 <alt_printf+0x214>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
  22390c:	e0bff717 	ldw	r2,-36(fp)
  223910:	10c00044 	addi	r3,r2,1
  223914:	e0fff715 	stw	r3,-36(fp)
  223918:	10800003 	ldbu	r2,0(r2)
  22391c:	e0bff805 	stb	r2,-32(fp)
  223920:	e0bff807 	ldb	r2,-32(fp)
  223924:	103f881e 	bne	r2,zero,223748 <__alt_data_end+0xfffefec8>
            {
                break;
            }
        }
    }
}
  223928:	e037883a 	mov	sp,fp
  22392c:	dfc00117 	ldw	ra,4(sp)
  223930:	df000017 	ldw	fp,0(sp)
  223934:	dec00504 	addi	sp,sp,20
  223938:	f800283a 	ret

0022393c <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
  22393c:	defffd04 	addi	sp,sp,-12
  223940:	dfc00215 	stw	ra,8(sp)
  223944:	df000115 	stw	fp,4(sp)
  223948:	df000104 	addi	fp,sp,4
  22394c:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
  223950:	008008f4 	movhi	r2,35
  223954:	10a2d404 	addi	r2,r2,-29872
  223958:	10800017 	ldw	r2,0(r2)
  22395c:	10800217 	ldw	r2,8(r2)
  223960:	e13fff17 	ldw	r4,-4(fp)
  223964:	100b883a 	mov	r5,r2
  223968:	02268f00 	call	2268f0 <putc>
#endif
}
  22396c:	e037883a 	mov	sp,fp
  223970:	dfc00117 	ldw	ra,4(sp)
  223974:	df000017 	ldw	fp,0(sp)
  223978:	dec00204 	addi	sp,sp,8
  22397c:	f800283a 	ret

00223980 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  223980:	defffe04 	addi	sp,sp,-8
  223984:	dfc00115 	stw	ra,4(sp)
  223988:	df000015 	stw	fp,0(sp)
  22398c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  223990:	008008f4 	movhi	r2,35
  223994:	10a2dc04 	addi	r2,r2,-29840
  223998:	10800017 	ldw	r2,0(r2)
  22399c:	10000526 	beq	r2,zero,2239b4 <alt_get_errno+0x34>
  2239a0:	008008f4 	movhi	r2,35
  2239a4:	10a2dc04 	addi	r2,r2,-29840
  2239a8:	10800017 	ldw	r2,0(r2)
  2239ac:	103ee83a 	callr	r2
  2239b0:	00000206 	br	2239bc <alt_get_errno+0x3c>
  2239b4:	008008f4 	movhi	r2,35
  2239b8:	10a9ca04 	addi	r2,r2,-22744
}
  2239bc:	e037883a 	mov	sp,fp
  2239c0:	dfc00117 	ldw	ra,4(sp)
  2239c4:	df000017 	ldw	fp,0(sp)
  2239c8:	dec00204 	addi	sp,sp,8
  2239cc:	f800283a 	ret

002239d0 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
  2239d0:	defff904 	addi	sp,sp,-28
  2239d4:	dfc00615 	stw	ra,24(sp)
  2239d8:	df000515 	stw	fp,20(sp)
  2239dc:	df000504 	addi	fp,sp,20
  2239e0:	e13ffd15 	stw	r4,-12(fp)
  2239e4:	e17ffe15 	stw	r5,-8(fp)
  2239e8:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  2239ec:	e0bffd17 	ldw	r2,-12(fp)
  2239f0:	10000616 	blt	r2,zero,223a0c <read+0x3c>
  2239f4:	e0bffd17 	ldw	r2,-12(fp)
  2239f8:	10c00324 	muli	r3,r2,12
  2239fc:	008008b4 	movhi	r2,34
  223a00:	109e1404 	addi	r2,r2,30800
  223a04:	1885883a 	add	r2,r3,r2
  223a08:	00000106 	br	223a10 <read+0x40>
  223a0c:	0005883a 	mov	r2,zero
  223a10:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
  223a14:	e0bffb17 	ldw	r2,-20(fp)
  223a18:	10002226 	beq	r2,zero,223aa4 <read+0xd4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
  223a1c:	e0bffb17 	ldw	r2,-20(fp)
  223a20:	10800217 	ldw	r2,8(r2)
  223a24:	108000cc 	andi	r2,r2,3
  223a28:	10800060 	cmpeqi	r2,r2,1
  223a2c:	1000181e 	bne	r2,zero,223a90 <read+0xc0>
        (fd->dev->read))
  223a30:	e0bffb17 	ldw	r2,-20(fp)
  223a34:	10800017 	ldw	r2,0(r2)
  223a38:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
  223a3c:	10001426 	beq	r2,zero,223a90 <read+0xc0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
  223a40:	e0bffb17 	ldw	r2,-20(fp)
  223a44:	10800017 	ldw	r2,0(r2)
  223a48:	10800517 	ldw	r2,20(r2)
  223a4c:	e0ffff17 	ldw	r3,-4(fp)
  223a50:	e13ffb17 	ldw	r4,-20(fp)
  223a54:	e17ffe17 	ldw	r5,-8(fp)
  223a58:	180d883a 	mov	r6,r3
  223a5c:	103ee83a 	callr	r2
  223a60:	e0bffc15 	stw	r2,-16(fp)
  223a64:	e0bffc17 	ldw	r2,-16(fp)
  223a68:	1000070e 	bge	r2,zero,223a88 <read+0xb8>
        {
          ALT_ERRNO = -rval;
  223a6c:	02239800 	call	223980 <alt_get_errno>
  223a70:	1007883a 	mov	r3,r2
  223a74:	e0bffc17 	ldw	r2,-16(fp)
  223a78:	0085c83a 	sub	r2,zero,r2
  223a7c:	18800015 	stw	r2,0(r3)
          return -1;
  223a80:	00bfffc4 	movi	r2,-1
  223a84:	00000c06 	br	223ab8 <read+0xe8>
        }
        return rval;
  223a88:	e0bffc17 	ldw	r2,-16(fp)
  223a8c:	00000a06 	br	223ab8 <read+0xe8>
      }
      else
      {
        ALT_ERRNO = EACCES;
  223a90:	02239800 	call	223980 <alt_get_errno>
  223a94:	1007883a 	mov	r3,r2
  223a98:	00800344 	movi	r2,13
  223a9c:	18800015 	stw	r2,0(r3)
  223aa0:	00000406 	br	223ab4 <read+0xe4>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
  223aa4:	02239800 	call	223980 <alt_get_errno>
  223aa8:	1007883a 	mov	r3,r2
  223aac:	00801444 	movi	r2,81
  223ab0:	18800015 	stw	r2,0(r3)
  }
  return -1;
  223ab4:	00bfffc4 	movi	r2,-1
}
  223ab8:	e037883a 	mov	sp,fp
  223abc:	dfc00117 	ldw	ra,4(sp)
  223ac0:	df000017 	ldw	fp,0(sp)
  223ac4:	dec00204 	addi	sp,sp,8
  223ac8:	f800283a 	ret

00223acc <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
  223acc:	defffe04 	addi	sp,sp,-8
  223ad0:	df000115 	stw	fp,4(sp)
  223ad4:	df000104 	addi	fp,sp,4
  223ad8:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
  223adc:	e0bfff17 	ldw	r2,-4(fp)
  223ae0:	108000d0 	cmplti	r2,r2,3
  223ae4:	10000d1e 	bne	r2,zero,223b1c <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
  223ae8:	008008b4 	movhi	r2,34
  223aec:	109e1404 	addi	r2,r2,30800
  223af0:	e0ffff17 	ldw	r3,-4(fp)
  223af4:	18c00324 	muli	r3,r3,12
  223af8:	10c5883a 	add	r2,r2,r3
  223afc:	10800204 	addi	r2,r2,8
  223b00:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
  223b04:	008008b4 	movhi	r2,34
  223b08:	109e1404 	addi	r2,r2,30800
  223b0c:	e0ffff17 	ldw	r3,-4(fp)
  223b10:	18c00324 	muli	r3,r3,12
  223b14:	10c5883a 	add	r2,r2,r3
  223b18:	10000015 	stw	zero,0(r2)
  }
}
  223b1c:	e037883a 	mov	sp,fp
  223b20:	df000017 	ldw	fp,0(sp)
  223b24:	dec00104 	addi	sp,sp,4
  223b28:	f800283a 	ret

00223b2c <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
  223b2c:	defff904 	addi	sp,sp,-28
  223b30:	df000615 	stw	fp,24(sp)
  223b34:	df000604 	addi	fp,sp,24
  223b38:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  223b3c:	0005303a 	rdctl	r2,status
  223b40:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  223b44:	e0fffc17 	ldw	r3,-16(fp)
  223b48:	00bfff84 	movi	r2,-2
  223b4c:	1884703a 	and	r2,r3,r2
  223b50:	1001703a 	wrctl	status,r2
  
  return context;
  223b54:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
  223b58:	e0bffa15 	stw	r2,-24(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
  223b5c:	d0a00a17 	ldw	r2,-32728(gp)
  223b60:	10c000c4 	addi	r3,r2,3
  223b64:	00bfff04 	movi	r2,-4
  223b68:	1884703a 	and	r2,r3,r2
  223b6c:	d0a00a15 	stw	r2,-32728(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
  223b70:	d0e00a17 	ldw	r3,-32728(gp)
  223b74:	e0bfff17 	ldw	r2,-4(fp)
  223b78:	1887883a 	add	r3,r3,r2
  223b7c:	008008f4 	movhi	r2,35
  223b80:	108e2004 	addi	r2,r2,14464
  223b84:	10c0062e 	bgeu	r2,r3,223ba0 <sbrk+0x74>
  223b88:	e0bffa17 	ldw	r2,-24(fp)
  223b8c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  223b90:	e0bffd17 	ldw	r2,-12(fp)
  223b94:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  223b98:	00bfffc4 	movi	r2,-1
  223b9c:	00000b06 	br	223bcc <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
  223ba0:	d0a00a17 	ldw	r2,-32728(gp)
  223ba4:	e0bffb15 	stw	r2,-20(fp)
  heap_end += incr; 
  223ba8:	d0e00a17 	ldw	r3,-32728(gp)
  223bac:	e0bfff17 	ldw	r2,-4(fp)
  223bb0:	1885883a 	add	r2,r3,r2
  223bb4:	d0a00a15 	stw	r2,-32728(gp)
  223bb8:	e0bffa17 	ldw	r2,-24(fp)
  223bbc:	e0bffe15 	stw	r2,-8(fp)
  223bc0:	e0bffe17 	ldw	r2,-8(fp)
  223bc4:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
  223bc8:	e0bffb17 	ldw	r2,-20(fp)
} 
  223bcc:	e037883a 	mov	sp,fp
  223bd0:	df000017 	ldw	fp,0(sp)
  223bd4:	dec00104 	addi	sp,sp,4
  223bd8:	f800283a 	ret

00223bdc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  223bdc:	defffe04 	addi	sp,sp,-8
  223be0:	dfc00115 	stw	ra,4(sp)
  223be4:	df000015 	stw	fp,0(sp)
  223be8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  223bec:	008008f4 	movhi	r2,35
  223bf0:	10a2dc04 	addi	r2,r2,-29840
  223bf4:	10800017 	ldw	r2,0(r2)
  223bf8:	10000526 	beq	r2,zero,223c10 <alt_get_errno+0x34>
  223bfc:	008008f4 	movhi	r2,35
  223c00:	10a2dc04 	addi	r2,r2,-29840
  223c04:	10800017 	ldw	r2,0(r2)
  223c08:	103ee83a 	callr	r2
  223c0c:	00000206 	br	223c18 <alt_get_errno+0x3c>
  223c10:	008008f4 	movhi	r2,35
  223c14:	10a9ca04 	addi	r2,r2,-22744
}
  223c18:	e037883a 	mov	sp,fp
  223c1c:	dfc00117 	ldw	ra,4(sp)
  223c20:	df000017 	ldw	fp,0(sp)
  223c24:	dec00204 	addi	sp,sp,8
  223c28:	f800283a 	ret

00223c2c <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
  223c2c:	defff904 	addi	sp,sp,-28
  223c30:	dfc00615 	stw	ra,24(sp)
  223c34:	df000515 	stw	fp,20(sp)
  223c38:	df000504 	addi	fp,sp,20
  223c3c:	e13ffd15 	stw	r4,-12(fp)
  223c40:	e17ffe15 	stw	r5,-8(fp)
  223c44:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
  223c48:	e0bffd17 	ldw	r2,-12(fp)
  223c4c:	10000616 	blt	r2,zero,223c68 <write+0x3c>
  223c50:	e0bffd17 	ldw	r2,-12(fp)
  223c54:	10c00324 	muli	r3,r2,12
  223c58:	008008b4 	movhi	r2,34
  223c5c:	109e1404 	addi	r2,r2,30800
  223c60:	1885883a 	add	r2,r3,r2
  223c64:	00000106 	br	223c6c <write+0x40>
  223c68:	0005883a 	mov	r2,zero
  223c6c:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
  223c70:	e0bffb17 	ldw	r2,-20(fp)
  223c74:	10002126 	beq	r2,zero,223cfc <write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
  223c78:	e0bffb17 	ldw	r2,-20(fp)
  223c7c:	10800217 	ldw	r2,8(r2)
  223c80:	108000cc 	andi	r2,r2,3
  223c84:	10001826 	beq	r2,zero,223ce8 <write+0xbc>
  223c88:	e0bffb17 	ldw	r2,-20(fp)
  223c8c:	10800017 	ldw	r2,0(r2)
  223c90:	10800617 	ldw	r2,24(r2)
  223c94:	10001426 	beq	r2,zero,223ce8 <write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
  223c98:	e0bffb17 	ldw	r2,-20(fp)
  223c9c:	10800017 	ldw	r2,0(r2)
  223ca0:	10800617 	ldw	r2,24(r2)
  223ca4:	e0ffff17 	ldw	r3,-4(fp)
  223ca8:	e13ffb17 	ldw	r4,-20(fp)
  223cac:	e17ffe17 	ldw	r5,-8(fp)
  223cb0:	180d883a 	mov	r6,r3
  223cb4:	103ee83a 	callr	r2
  223cb8:	e0bffc15 	stw	r2,-16(fp)
  223cbc:	e0bffc17 	ldw	r2,-16(fp)
  223cc0:	1000070e 	bge	r2,zero,223ce0 <write+0xb4>
      {
        ALT_ERRNO = -rval;
  223cc4:	0223bdc0 	call	223bdc <alt_get_errno>
  223cc8:	1007883a 	mov	r3,r2
  223ccc:	e0bffc17 	ldw	r2,-16(fp)
  223cd0:	0085c83a 	sub	r2,zero,r2
  223cd4:	18800015 	stw	r2,0(r3)
        return -1;
  223cd8:	00bfffc4 	movi	r2,-1
  223cdc:	00000c06 	br	223d10 <write+0xe4>
      }
      return rval;
  223ce0:	e0bffc17 	ldw	r2,-16(fp)
  223ce4:	00000a06 	br	223d10 <write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
  223ce8:	0223bdc0 	call	223bdc <alt_get_errno>
  223cec:	1007883a 	mov	r3,r2
  223cf0:	00800344 	movi	r2,13
  223cf4:	18800015 	stw	r2,0(r3)
  223cf8:	00000406 	br	223d0c <write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
  223cfc:	0223bdc0 	call	223bdc <alt_get_errno>
  223d00:	1007883a 	mov	r3,r2
  223d04:	00801444 	movi	r2,81
  223d08:	18800015 	stw	r2,0(r3)
  }
  return -1;
  223d0c:	00bfffc4 	movi	r2,-1
}
  223d10:	e037883a 	mov	sp,fp
  223d14:	dfc00117 	ldw	ra,4(sp)
  223d18:	df000017 	ldw	fp,0(sp)
  223d1c:	dec00204 	addi	sp,sp,8
  223d20:	f800283a 	ret

00223d24 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  223d24:	defffd04 	addi	sp,sp,-12
  223d28:	dfc00215 	stw	ra,8(sp)
  223d2c:	df000115 	stw	fp,4(sp)
  223d30:	df000104 	addi	fp,sp,4
  223d34:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
  223d38:	e13fff17 	ldw	r4,-4(fp)
  223d3c:	014008f4 	movhi	r5,35
  223d40:	2962d904 	addi	r5,r5,-29852
  223d44:	0225a440 	call	225a44 <alt_dev_llist_insert>
}
  223d48:	e037883a 	mov	sp,fp
  223d4c:	dfc00117 	ldw	ra,4(sp)
  223d50:	df000017 	ldw	fp,0(sp)
  223d54:	dec00204 	addi	sp,sp,8
  223d58:	f800283a 	ret

00223d5c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  223d5c:	defffe04 	addi	sp,sp,-8
  223d60:	dfc00115 	stw	ra,4(sp)
  223d64:	df000015 	stw	fp,0(sp)
  223d68:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  223d6c:	008008f4 	movhi	r2,35
  223d70:	10a2dc04 	addi	r2,r2,-29840
  223d74:	10800017 	ldw	r2,0(r2)
  223d78:	10000526 	beq	r2,zero,223d90 <alt_get_errno+0x34>
  223d7c:	008008f4 	movhi	r2,35
  223d80:	10a2dc04 	addi	r2,r2,-29840
  223d84:	10800017 	ldw	r2,0(r2)
  223d88:	103ee83a 	callr	r2
  223d8c:	00000206 	br	223d98 <alt_get_errno+0x3c>
  223d90:	008008f4 	movhi	r2,35
  223d94:	10a9ca04 	addi	r2,r2,-22744
}
  223d98:	e037883a 	mov	sp,fp
  223d9c:	dfc00117 	ldw	ra,4(sp)
  223da0:	df000017 	ldw	fp,0(sp)
  223da4:	dec00204 	addi	sp,sp,8
  223da8:	f800283a 	ret

00223dac <alt_avalon_mutex_reg>:
/*
 * Register a Mutex device
 */

static ALT_INLINE int alt_avalon_mutex_reg (alt_mutex_dev* dev)
{
  223dac:	defffc04 	addi	sp,sp,-16
  223db0:	dfc00315 	stw	ra,12(sp)
  223db4:	df000215 	stw	fp,8(sp)
  223db8:	df000204 	addi	fp,sp,8
  223dbc:	e13fff15 	stw	r4,-4(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
  223dc0:	0005883a 	mov	r2,zero
  int ret_code;
  extern alt_llist alt_mutex_list;
  ret_code = ALT_SEM_CREATE (&dev->lock, 1);
  223dc4:	e0bffe15 	stw	r2,-8(fp)
  if (!ret_code)
  223dc8:	e0bffe17 	ldw	r2,-8(fp)
  223dcc:	1000061e 	bne	r2,zero,223de8 <alt_avalon_mutex_reg+0x3c>
  {
    ret_code = alt_dev_llist_insert((alt_dev_llist*) dev, &alt_mutex_list);
  223dd0:	e13fff17 	ldw	r4,-4(fp)
  223dd4:	014008f4 	movhi	r5,35
  223dd8:	2962de04 	addi	r5,r5,-29832
  223ddc:	0225a440 	call	225a44 <alt_dev_llist_insert>
  223de0:	e0bffe15 	stw	r2,-8(fp)
  223de4:	00000606 	br	223e00 <alt_avalon_mutex_reg+0x54>
  }
  else
  {
    ALT_ERRNO = ENOMEM;
  223de8:	0223d5c0 	call	223d5c <alt_get_errno>
  223dec:	1007883a 	mov	r3,r2
  223df0:	00800304 	movi	r2,12
  223df4:	18800015 	stw	r2,0(r3)
    ret_code = -ENOMEM;
  223df8:	00bffd04 	movi	r2,-12
  223dfc:	e0bffe15 	stw	r2,-8(fp)
  }

  return ret_code;
  223e00:	e0bffe17 	ldw	r2,-8(fp)
}
  223e04:	e037883a 	mov	sp,fp
  223e08:	dfc00117 	ldw	ra,4(sp)
  223e0c:	df000017 	ldw	fp,0(sp)
  223e10:	dec00204 	addi	sp,sp,8
  223e14:	f800283a 	ret

00223e18 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
  223e18:	defffd04 	addi	sp,sp,-12
  223e1c:	dfc00215 	stw	ra,8(sp)
  223e20:	df000115 	stw	fp,4(sp)
  223e24:	df000104 	addi	fp,sp,4
  223e28:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( CPUSLAVE2, CPUSlave2);
  223e2c:	02264780 	call	226478 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
  223e30:	00800044 	movi	r2,1
  223e34:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
  223e38:	e037883a 	mov	sp,fp
  223e3c:	dfc00117 	ldw	ra,4(sp)
  223e40:	df000017 	ldw	fp,0(sp)
  223e44:	dec00204 	addi	sp,sp,8
  223e48:	f800283a 	ret

00223e4c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
  223e4c:	defffe04 	addi	sp,sp,-8
  223e50:	dfc00115 	stw	ra,4(sp)
  223e54:	df000015 	stw	fp,0(sp)
  223e58:	d839883a 	mov	fp,sp
    ALTERA_AVALON_JTAG_UART_INIT ( JTAGSLAVE2, JTAGSlave2);
  223e5c:	010008b4 	movhi	r4,34
  223e60:	211e7e04 	addi	r4,r4,31224
  223e64:	000b883a 	mov	r5,zero
  223e68:	01800084 	movi	r6,2
  223e6c:	02240d80 	call	2240d8 <altera_avalon_jtag_uart_init>
  223e70:	010008b4 	movhi	r4,34
  223e74:	211e7404 	addi	r4,r4,31184
  223e78:	0223d240 	call	223d24 <alt_dev_reg>
    ALTERA_AVALON_MUTEX_INIT ( MUTEX_0, mutex_0);
  223e7c:	010008f4 	movhi	r4,35
  223e80:	21228c04 	addi	r4,r4,-30160
  223e84:	0223dac0 	call	223dac <alt_avalon_mutex_reg>
    ALTERA_AVALON_UART_INIT ( UART_0, uart_0);
  223e88:	010008f4 	movhi	r4,35
  223e8c:	21229a04 	addi	r4,r4,-30104
  223e90:	000b883a 	mov	r5,zero
  223e94:	01800144 	movi	r6,5
  223e98:	0224da80 	call	224da8 <altera_avalon_uart_init>
  223e9c:	010008f4 	movhi	r4,35
  223ea0:	21229004 	addi	r4,r4,-30144
  223ea4:	0223d240 	call	223d24 <alt_dev_reg>
    ALTERA_UP_AVALON_VIDEO_CHARACTER_BUFFER_WITH_DMA_INIT ( VIDEO_CHARACTER_BUFFER_WITH_DMA_0, video_character_buffer_with_dma_0);
  223ea8:	008008f4 	movhi	r2,35
  223eac:	10a2c104 	addi	r2,r2,-29948
  223eb0:	10800a17 	ldw	r2,40(r2)
  223eb4:	10800104 	addi	r2,r2,4
  223eb8:	10800017 	ldw	r2,0(r2)
  223ebc:	10ffffcc 	andi	r3,r2,65535
  223ec0:	008008f4 	movhi	r2,35
  223ec4:	10a2c104 	addi	r2,r2,-29948
  223ec8:	10c00c15 	stw	r3,48(r2)
  223ecc:	008008f4 	movhi	r2,35
  223ed0:	10a2c104 	addi	r2,r2,-29948
  223ed4:	10800a17 	ldw	r2,40(r2)
  223ed8:	10800104 	addi	r2,r2,4
  223edc:	10800017 	ldw	r2,0(r2)
  223ee0:	1006d43a 	srli	r3,r2,16
  223ee4:	008008f4 	movhi	r2,35
  223ee8:	10a2c104 	addi	r2,r2,-29948
  223eec:	10c00d15 	stw	r3,52(r2)
  223ef0:	008008f4 	movhi	r2,35
  223ef4:	10a2c104 	addi	r2,r2,-29948
  223ef8:	10800c17 	ldw	r2,48(r2)
  223efc:	10801068 	cmpgeui	r2,r2,65
  223f00:	1000081e 	bne	r2,zero,223f24 <alt_sys_init+0xd8>
  223f04:	008008f4 	movhi	r2,35
  223f08:	10a2c104 	addi	r2,r2,-29948
  223f0c:	00c00fc4 	movi	r3,63
  223f10:	10c00f15 	stw	r3,60(r2)
  223f14:	008008f4 	movhi	r2,35
  223f18:	10a2c104 	addi	r2,r2,-29948
  223f1c:	00c00184 	movi	r3,6
  223f20:	10c01015 	stw	r3,64(r2)
  223f24:	008008f4 	movhi	r2,35
  223f28:	10a2c104 	addi	r2,r2,-29948
  223f2c:	10800d17 	ldw	r2,52(r2)
  223f30:	10800868 	cmpgeui	r2,r2,33
  223f34:	1000041e 	bne	r2,zero,223f48 <alt_sys_init+0xfc>
  223f38:	008008f4 	movhi	r2,35
  223f3c:	10a2c104 	addi	r2,r2,-29948
  223f40:	00c007c4 	movi	r3,31
  223f44:	10c01115 	stw	r3,68(r2)
  223f48:	010008f4 	movhi	r4,35
  223f4c:	2122c104 	addi	r4,r4,-29948
  223f50:	02255880 	call	225588 <alt_up_char_buffer_init>
  223f54:	010008f4 	movhi	r4,35
  223f58:	2122c104 	addi	r4,r4,-29948
  223f5c:	0223d240 	call	223d24 <alt_dev_reg>
}
  223f60:	e037883a 	mov	sp,fp
  223f64:	dfc00117 	ldw	ra,4(sp)
  223f68:	df000017 	ldw	fp,0(sp)
  223f6c:	dec00204 	addi	sp,sp,8
  223f70:	f800283a 	ret

00223f74 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  223f74:	defffa04 	addi	sp,sp,-24
  223f78:	dfc00515 	stw	ra,20(sp)
  223f7c:	df000415 	stw	fp,16(sp)
  223f80:	df000404 	addi	fp,sp,16
  223f84:	e13ffd15 	stw	r4,-12(fp)
  223f88:	e17ffe15 	stw	r5,-8(fp)
  223f8c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  223f90:	e0bffd17 	ldw	r2,-12(fp)
  223f94:	10800017 	ldw	r2,0(r2)
  223f98:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
  223f9c:	e0bffc17 	ldw	r2,-16(fp)
  223fa0:	10c00a04 	addi	r3,r2,40
  223fa4:	e0bffd17 	ldw	r2,-12(fp)
  223fa8:	10800217 	ldw	r2,8(r2)
  223fac:	1809883a 	mov	r4,r3
  223fb0:	e17ffe17 	ldw	r5,-8(fp)
  223fb4:	e1bfff17 	ldw	r6,-4(fp)
  223fb8:	100f883a 	mov	r7,r2
  223fbc:	022459c0 	call	22459c <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
  223fc0:	e037883a 	mov	sp,fp
  223fc4:	dfc00117 	ldw	ra,4(sp)
  223fc8:	df000017 	ldw	fp,0(sp)
  223fcc:	dec00204 	addi	sp,sp,8
  223fd0:	f800283a 	ret

00223fd4 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  223fd4:	defffa04 	addi	sp,sp,-24
  223fd8:	dfc00515 	stw	ra,20(sp)
  223fdc:	df000415 	stw	fp,16(sp)
  223fe0:	df000404 	addi	fp,sp,16
  223fe4:	e13ffd15 	stw	r4,-12(fp)
  223fe8:	e17ffe15 	stw	r5,-8(fp)
  223fec:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  223ff0:	e0bffd17 	ldw	r2,-12(fp)
  223ff4:	10800017 	ldw	r2,0(r2)
  223ff8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
  223ffc:	e0bffc17 	ldw	r2,-16(fp)
  224000:	10c00a04 	addi	r3,r2,40
  224004:	e0bffd17 	ldw	r2,-12(fp)
  224008:	10800217 	ldw	r2,8(r2)
  22400c:	1809883a 	mov	r4,r3
  224010:	e17ffe17 	ldw	r5,-8(fp)
  224014:	e1bfff17 	ldw	r6,-4(fp)
  224018:	100f883a 	mov	r7,r2
  22401c:	02247a80 	call	2247a8 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
  224020:	e037883a 	mov	sp,fp
  224024:	dfc00117 	ldw	ra,4(sp)
  224028:	df000017 	ldw	fp,0(sp)
  22402c:	dec00204 	addi	sp,sp,8
  224030:	f800283a 	ret

00224034 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
  224034:	defffc04 	addi	sp,sp,-16
  224038:	dfc00315 	stw	ra,12(sp)
  22403c:	df000215 	stw	fp,8(sp)
  224040:	df000204 	addi	fp,sp,8
  224044:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
  224048:	e0bfff17 	ldw	r2,-4(fp)
  22404c:	10800017 	ldw	r2,0(r2)
  224050:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
  224054:	e0bffe17 	ldw	r2,-8(fp)
  224058:	10c00a04 	addi	r3,r2,40
  22405c:	e0bfff17 	ldw	r2,-4(fp)
  224060:	10800217 	ldw	r2,8(r2)
  224064:	1809883a 	mov	r4,r3
  224068:	100b883a 	mov	r5,r2
  22406c:	02244480 	call	224448 <altera_avalon_jtag_uart_close>
}
  224070:	e037883a 	mov	sp,fp
  224074:	dfc00117 	ldw	ra,4(sp)
  224078:	df000017 	ldw	fp,0(sp)
  22407c:	dec00204 	addi	sp,sp,8
  224080:	f800283a 	ret

00224084 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
  224084:	defffa04 	addi	sp,sp,-24
  224088:	dfc00515 	stw	ra,20(sp)
  22408c:	df000415 	stw	fp,16(sp)
  224090:	df000404 	addi	fp,sp,16
  224094:	e13ffd15 	stw	r4,-12(fp)
  224098:	e17ffe15 	stw	r5,-8(fp)
  22409c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
  2240a0:	e0bffd17 	ldw	r2,-12(fp)
  2240a4:	10800017 	ldw	r2,0(r2)
  2240a8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
  2240ac:	e0bffc17 	ldw	r2,-16(fp)
  2240b0:	10800a04 	addi	r2,r2,40
  2240b4:	1009883a 	mov	r4,r2
  2240b8:	e17ffe17 	ldw	r5,-8(fp)
  2240bc:	e1bfff17 	ldw	r6,-4(fp)
  2240c0:	02244b00 	call	2244b0 <altera_avalon_jtag_uart_ioctl>
}
  2240c4:	e037883a 	mov	sp,fp
  2240c8:	dfc00117 	ldw	ra,4(sp)
  2240cc:	df000017 	ldw	fp,0(sp)
  2240d0:	dec00204 	addi	sp,sp,8
  2240d4:	f800283a 	ret

002240d8 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
  2240d8:	defffa04 	addi	sp,sp,-24
  2240dc:	dfc00515 	stw	ra,20(sp)
  2240e0:	df000415 	stw	fp,16(sp)
  2240e4:	df000404 	addi	fp,sp,16
  2240e8:	e13ffd15 	stw	r4,-12(fp)
  2240ec:	e17ffe15 	stw	r5,-8(fp)
  2240f0:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  2240f4:	e0bffd17 	ldw	r2,-12(fp)
  2240f8:	00c00044 	movi	r3,1
  2240fc:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
  224100:	e0bffd17 	ldw	r2,-12(fp)
  224104:	10800017 	ldw	r2,0(r2)
  224108:	10800104 	addi	r2,r2,4
  22410c:	1007883a 	mov	r3,r2
  224110:	e0bffd17 	ldw	r2,-12(fp)
  224114:	10800817 	ldw	r2,32(r2)
  224118:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
  22411c:	e0fffe17 	ldw	r3,-8(fp)
  224120:	e0bfff17 	ldw	r2,-4(fp)
  224124:	d8000015 	stw	zero,0(sp)
  224128:	1809883a 	mov	r4,r3
  22412c:	100b883a 	mov	r5,r2
  224130:	018008b4 	movhi	r6,34
  224134:	31906704 	addi	r6,r6,16796
  224138:	e1fffd17 	ldw	r7,-12(fp)
  22413c:	0225c600 	call	225c60 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
  224140:	e0bffd17 	ldw	r2,-12(fp)
  224144:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
  224148:	e0bffd17 	ldw	r2,-12(fp)
  22414c:	10c00204 	addi	r3,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
  224150:	008008f4 	movhi	r2,35
  224154:	10a9cf04 	addi	r2,r2,-22724
  224158:	10800017 	ldw	r2,0(r2)
  22415c:	1809883a 	mov	r4,r3
  224160:	100b883a 	mov	r5,r2
  224164:	018008b4 	movhi	r6,34
  224168:	3190e804 	addi	r6,r6,17312
  22416c:	e1fffd17 	ldw	r7,-12(fp)
  224170:	02258700 	call	225870 <alt_alarm_start>
  224174:	1000040e 	bge	r2,zero,224188 <altera_avalon_jtag_uart_init+0xb0>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
  224178:	e0fffd17 	ldw	r3,-12(fp)
  22417c:	00a00034 	movhi	r2,32768
  224180:	10bfffc4 	addi	r2,r2,-1
  224184:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
  224188:	e037883a 	mov	sp,fp
  22418c:	dfc00117 	ldw	ra,4(sp)
  224190:	df000017 	ldw	fp,0(sp)
  224194:	dec00204 	addi	sp,sp,8
  224198:	f800283a 	ret

0022419c <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
  22419c:	defff804 	addi	sp,sp,-32
  2241a0:	df000715 	stw	fp,28(sp)
  2241a4:	df000704 	addi	fp,sp,28
  2241a8:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
  2241ac:	e0bfff17 	ldw	r2,-4(fp)
  2241b0:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
  2241b4:	e0bffb17 	ldw	r2,-20(fp)
  2241b8:	10800017 	ldw	r2,0(r2)
  2241bc:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  2241c0:	e0bffc17 	ldw	r2,-16(fp)
  2241c4:	10800104 	addi	r2,r2,4
  2241c8:	10800037 	ldwio	r2,0(r2)
  2241cc:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
  2241d0:	e0bffd17 	ldw	r2,-12(fp)
  2241d4:	1080c00c 	andi	r2,r2,768
  2241d8:	1000011e 	bne	r2,zero,2241e0 <altera_avalon_jtag_uart_irq+0x44>
      break;
  2241dc:	00006c06 	br	224390 <altera_avalon_jtag_uart_irq+0x1f4>

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
  2241e0:	e0bffd17 	ldw	r2,-12(fp)
  2241e4:	1080400c 	andi	r2,r2,256
  2241e8:	10003426 	beq	r2,zero,2242bc <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
  2241ec:	00800074 	movhi	r2,1
  2241f0:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  2241f4:	e0bffb17 	ldw	r2,-20(fp)
  2241f8:	10800a17 	ldw	r2,40(r2)
  2241fc:	10800044 	addi	r2,r2,1
  224200:	1081ffcc 	andi	r2,r2,2047
  224204:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
  224208:	e0bffb17 	ldw	r2,-20(fp)
  22420c:	10c00b17 	ldw	r3,44(r2)
  224210:	e0bffe17 	ldw	r2,-8(fp)
  224214:	1880011e 	bne	r3,r2,22421c <altera_avalon_jtag_uart_irq+0x80>
          break;
  224218:	00001606 	br	224274 <altera_avalon_jtag_uart_irq+0xd8>

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
  22421c:	e0bffc17 	ldw	r2,-16(fp)
  224220:	10800037 	ldwio	r2,0(r2)
  224224:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
  224228:	e0bff917 	ldw	r2,-28(fp)
  22422c:	10a0000c 	andi	r2,r2,32768
  224230:	1000011e 	bne	r2,zero,224238 <altera_avalon_jtag_uart_irq+0x9c>
          break;
  224234:	00000f06 	br	224274 <altera_avalon_jtag_uart_irq+0xd8>

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
  224238:	e0bffb17 	ldw	r2,-20(fp)
  22423c:	10800a17 	ldw	r2,40(r2)
  224240:	e0fff917 	ldw	r3,-28(fp)
  224244:	1809883a 	mov	r4,r3
  224248:	e0fffb17 	ldw	r3,-20(fp)
  22424c:	1885883a 	add	r2,r3,r2
  224250:	10800e04 	addi	r2,r2,56
  224254:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  224258:	e0bffb17 	ldw	r2,-20(fp)
  22425c:	10800a17 	ldw	r2,40(r2)
  224260:	10800044 	addi	r2,r2,1
  224264:	10c1ffcc 	andi	r3,r2,2047
  224268:	e0bffb17 	ldw	r2,-20(fp)
  22426c:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
  224270:	003fe006 	br	2241f4 <__alt_data_end+0xffff0974>

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
  224274:	e0bff917 	ldw	r2,-28(fp)
  224278:	10bfffec 	andhi	r2,r2,65535
  22427c:	10000f26 	beq	r2,zero,2242bc <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  224280:	e0bffb17 	ldw	r2,-20(fp)
  224284:	10c00817 	ldw	r3,32(r2)
  224288:	00bfff84 	movi	r2,-2
  22428c:	1886703a 	and	r3,r3,r2
  224290:	e0bffb17 	ldw	r2,-20(fp)
  224294:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
  224298:	e0bffc17 	ldw	r2,-16(fp)
  22429c:	10800104 	addi	r2,r2,4
  2242a0:	1007883a 	mov	r3,r2
  2242a4:	e0bffb17 	ldw	r2,-20(fp)
  2242a8:	10800817 	ldw	r2,32(r2)
  2242ac:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  2242b0:	e0bffc17 	ldw	r2,-16(fp)
  2242b4:	10800104 	addi	r2,r2,4
  2242b8:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
  2242bc:	e0bffd17 	ldw	r2,-12(fp)
  2242c0:	1080800c 	andi	r2,r2,512
  2242c4:	10003126 	beq	r2,zero,22438c <altera_avalon_jtag_uart_irq+0x1f0>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
  2242c8:	e0bffd17 	ldw	r2,-12(fp)
  2242cc:	1004d43a 	srli	r2,r2,16
  2242d0:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
  2242d4:	00001406 	br	224328 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
  2242d8:	e0bffc17 	ldw	r2,-16(fp)
  2242dc:	e0fffb17 	ldw	r3,-20(fp)
  2242e0:	18c00d17 	ldw	r3,52(r3)
  2242e4:	e13ffb17 	ldw	r4,-20(fp)
  2242e8:	20c7883a 	add	r3,r4,r3
  2242ec:	18c20e04 	addi	r3,r3,2104
  2242f0:	18c00003 	ldbu	r3,0(r3)
  2242f4:	18c03fcc 	andi	r3,r3,255
  2242f8:	18c0201c 	xori	r3,r3,128
  2242fc:	18ffe004 	addi	r3,r3,-128
  224300:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  224304:	e0bffb17 	ldw	r2,-20(fp)
  224308:	10800d17 	ldw	r2,52(r2)
  22430c:	10800044 	addi	r2,r2,1
  224310:	10c1ffcc 	andi	r3,r2,2047
  224314:	e0bffb17 	ldw	r2,-20(fp)
  224318:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
  22431c:	e0bffa17 	ldw	r2,-24(fp)
  224320:	10bfffc4 	addi	r2,r2,-1
  224324:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
  224328:	e0bffa17 	ldw	r2,-24(fp)
  22432c:	10000526 	beq	r2,zero,224344 <altera_avalon_jtag_uart_irq+0x1a8>
  224330:	e0bffb17 	ldw	r2,-20(fp)
  224334:	10c00d17 	ldw	r3,52(r2)
  224338:	e0bffb17 	ldw	r2,-20(fp)
  22433c:	10800c17 	ldw	r2,48(r2)
  224340:	18bfe51e 	bne	r3,r2,2242d8 <__alt_data_end+0xffff0a58>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
  224344:	e0bffa17 	ldw	r2,-24(fp)
  224348:	10001026 	beq	r2,zero,22438c <altera_avalon_jtag_uart_irq+0x1f0>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  22434c:	e0bffb17 	ldw	r2,-20(fp)
  224350:	10c00817 	ldw	r3,32(r2)
  224354:	00bfff44 	movi	r2,-3
  224358:	1886703a 	and	r3,r3,r2
  22435c:	e0bffb17 	ldw	r2,-20(fp)
  224360:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  224364:	e0bffb17 	ldw	r2,-20(fp)
  224368:	10800017 	ldw	r2,0(r2)
  22436c:	10800104 	addi	r2,r2,4
  224370:	1007883a 	mov	r3,r2
  224374:	e0bffb17 	ldw	r2,-20(fp)
  224378:	10800817 	ldw	r2,32(r2)
  22437c:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
  224380:	e0bffc17 	ldw	r2,-16(fp)
  224384:	10800104 	addi	r2,r2,4
  224388:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
  22438c:	003f8c06 	br	2241c0 <__alt_data_end+0xffff0940>
}
  224390:	e037883a 	mov	sp,fp
  224394:	df000017 	ldw	fp,0(sp)
  224398:	dec00104 	addi	sp,sp,4
  22439c:	f800283a 	ret

002243a0 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
  2243a0:	defff804 	addi	sp,sp,-32
  2243a4:	df000715 	stw	fp,28(sp)
  2243a8:	df000704 	addi	fp,sp,28
  2243ac:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
  2243b0:	e0bffb17 	ldw	r2,-20(fp)
  2243b4:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
  2243b8:	e0bff917 	ldw	r2,-28(fp)
  2243bc:	10800017 	ldw	r2,0(r2)
  2243c0:	10800104 	addi	r2,r2,4
  2243c4:	10800037 	ldwio	r2,0(r2)
  2243c8:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
  2243cc:	e0bffa17 	ldw	r2,-24(fp)
  2243d0:	1081000c 	andi	r2,r2,1024
  2243d4:	10000b26 	beq	r2,zero,224404 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
  2243d8:	e0bff917 	ldw	r2,-28(fp)
  2243dc:	10800017 	ldw	r2,0(r2)
  2243e0:	10800104 	addi	r2,r2,4
  2243e4:	1007883a 	mov	r3,r2
  2243e8:	e0bff917 	ldw	r2,-28(fp)
  2243ec:	10800817 	ldw	r2,32(r2)
  2243f0:	10810014 	ori	r2,r2,1024
  2243f4:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
  2243f8:	e0bff917 	ldw	r2,-28(fp)
  2243fc:	10000915 	stw	zero,36(r2)
  224400:	00000a06 	br	22442c <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
  224404:	e0bff917 	ldw	r2,-28(fp)
  224408:	10c00917 	ldw	r3,36(r2)
  22440c:	00a00034 	movhi	r2,32768
  224410:	10bfff04 	addi	r2,r2,-4
  224414:	10c00536 	bltu	r2,r3,22442c <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
  224418:	e0bff917 	ldw	r2,-28(fp)
  22441c:	10800917 	ldw	r2,36(r2)
  224420:	10c00044 	addi	r3,r2,1
  224424:	e0bff917 	ldw	r2,-28(fp)
  224428:	10c00915 	stw	r3,36(r2)
  22442c:	008008f4 	movhi	r2,35
  224430:	10a9cf04 	addi	r2,r2,-22724
  224434:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
  224438:	e037883a 	mov	sp,fp
  22443c:	df000017 	ldw	fp,0(sp)
  224440:	dec00104 	addi	sp,sp,4
  224444:	f800283a 	ret

00224448 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
  224448:	defffd04 	addi	sp,sp,-12
  22444c:	df000215 	stw	fp,8(sp)
  224450:	df000204 	addi	fp,sp,8
  224454:	e13ffe15 	stw	r4,-8(fp)
  224458:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  22445c:	00000506 	br	224474 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
  224460:	e0bfff17 	ldw	r2,-4(fp)
  224464:	1090000c 	andi	r2,r2,16384
  224468:	10000226 	beq	r2,zero,224474 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
  22446c:	00bffd44 	movi	r2,-11
  224470:	00000b06 	br	2244a0 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
  224474:	e0bffe17 	ldw	r2,-8(fp)
  224478:	10c00d17 	ldw	r3,52(r2)
  22447c:	e0bffe17 	ldw	r2,-8(fp)
  224480:	10800c17 	ldw	r2,48(r2)
  224484:	18800526 	beq	r3,r2,22449c <altera_avalon_jtag_uart_close+0x54>
  224488:	e0bffe17 	ldw	r2,-8(fp)
  22448c:	10c00917 	ldw	r3,36(r2)
  224490:	e0bffe17 	ldw	r2,-8(fp)
  224494:	10800117 	ldw	r2,4(r2)
  224498:	18bff136 	bltu	r3,r2,224460 <__alt_data_end+0xffff0be0>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
  22449c:	0005883a 	mov	r2,zero
}
  2244a0:	e037883a 	mov	sp,fp
  2244a4:	df000017 	ldw	fp,0(sp)
  2244a8:	dec00104 	addi	sp,sp,4
  2244ac:	f800283a 	ret

002244b0 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
  2244b0:	defffa04 	addi	sp,sp,-24
  2244b4:	df000515 	stw	fp,20(sp)
  2244b8:	df000504 	addi	fp,sp,20
  2244bc:	e13ffd15 	stw	r4,-12(fp)
  2244c0:	e17ffe15 	stw	r5,-8(fp)
  2244c4:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
  2244c8:	00bff9c4 	movi	r2,-25
  2244cc:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
  2244d0:	e0bffe17 	ldw	r2,-8(fp)
  2244d4:	10da8060 	cmpeqi	r3,r2,27137
  2244d8:	1800031e 	bne	r3,zero,2244e8 <altera_avalon_jtag_uart_ioctl+0x38>
  2244dc:	109a80a0 	cmpeqi	r2,r2,27138
  2244e0:	1000191e 	bne	r2,zero,224548 <altera_avalon_jtag_uart_ioctl+0x98>
      rc = 0;
    }
    break;

  default:
    break;
  2244e4:	00002806 	br	224588 <altera_avalon_jtag_uart_ioctl+0xd8>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
  2244e8:	e0bffd17 	ldw	r2,-12(fp)
  2244ec:	10c00117 	ldw	r3,4(r2)
  2244f0:	00a00034 	movhi	r2,32768
  2244f4:	10bfffc4 	addi	r2,r2,-1
  2244f8:	18801226 	beq	r3,r2,224544 <altera_avalon_jtag_uart_ioctl+0x94>
    {
      int timeout = *((int *)arg);
  2244fc:	e0bfff17 	ldw	r2,-4(fp)
  224500:	10800017 	ldw	r2,0(r2)
  224504:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
  224508:	e0bffc17 	ldw	r2,-16(fp)
  22450c:	10800090 	cmplti	r2,r2,2
  224510:	1000061e 	bne	r2,zero,22452c <altera_avalon_jtag_uart_ioctl+0x7c>
  224514:	e0fffc17 	ldw	r3,-16(fp)
  224518:	00a00034 	movhi	r2,32768
  22451c:	10bfffc4 	addi	r2,r2,-1
  224520:	18800226 	beq	r3,r2,22452c <altera_avalon_jtag_uart_ioctl+0x7c>
  224524:	e0bffc17 	ldw	r2,-16(fp)
  224528:	00000206 	br	224534 <altera_avalon_jtag_uart_ioctl+0x84>
  22452c:	00a00034 	movhi	r2,32768
  224530:	10bfff84 	addi	r2,r2,-2
  224534:	e0fffd17 	ldw	r3,-12(fp)
  224538:	18800115 	stw	r2,4(r3)
      rc = 0;
  22453c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
  224540:	00001106 	br	224588 <altera_avalon_jtag_uart_ioctl+0xd8>
  224544:	00001006 	br	224588 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
  224548:	e0bffd17 	ldw	r2,-12(fp)
  22454c:	10c00117 	ldw	r3,4(r2)
  224550:	00a00034 	movhi	r2,32768
  224554:	10bfffc4 	addi	r2,r2,-1
  224558:	18800a26 	beq	r3,r2,224584 <altera_avalon_jtag_uart_ioctl+0xd4>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
  22455c:	e0bffd17 	ldw	r2,-12(fp)
  224560:	10c00917 	ldw	r3,36(r2)
  224564:	e0bffd17 	ldw	r2,-12(fp)
  224568:	10800117 	ldw	r2,4(r2)
  22456c:	1885803a 	cmpltu	r2,r3,r2
  224570:	10c03fcc 	andi	r3,r2,255
  224574:	e0bfff17 	ldw	r2,-4(fp)
  224578:	10c00015 	stw	r3,0(r2)
      rc = 0;
  22457c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
  224580:	00000006 	br	224584 <altera_avalon_jtag_uart_ioctl+0xd4>
  224584:	0001883a 	nop

  default:
    break;
  }

  return rc;
  224588:	e0bffb17 	ldw	r2,-20(fp)
}
  22458c:	e037883a 	mov	sp,fp
  224590:	df000017 	ldw	fp,0(sp)
  224594:	dec00104 	addi	sp,sp,4
  224598:	f800283a 	ret

0022459c <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
  22459c:	defff304 	addi	sp,sp,-52
  2245a0:	dfc00c15 	stw	ra,48(sp)
  2245a4:	df000b15 	stw	fp,44(sp)
  2245a8:	df000b04 	addi	fp,sp,44
  2245ac:	e13ffc15 	stw	r4,-16(fp)
  2245b0:	e17ffd15 	stw	r5,-12(fp)
  2245b4:	e1bffe15 	stw	r6,-8(fp)
  2245b8:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
  2245bc:	e0bffd17 	ldw	r2,-12(fp)
  2245c0:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  2245c4:	00004906 	br	2246ec <altera_avalon_jtag_uart_read+0x150>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
  2245c8:	e0bffc17 	ldw	r2,-16(fp)
  2245cc:	10800a17 	ldw	r2,40(r2)
  2245d0:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
  2245d4:	e0bffc17 	ldw	r2,-16(fp)
  2245d8:	10800b17 	ldw	r2,44(r2)
  2245dc:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
  2245e0:	e0fff717 	ldw	r3,-36(fp)
  2245e4:	e0bff817 	ldw	r2,-32(fp)
  2245e8:	18800536 	bltu	r3,r2,224600 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
  2245ec:	e0fff717 	ldw	r3,-36(fp)
  2245f0:	e0bff817 	ldw	r2,-32(fp)
  2245f4:	1885c83a 	sub	r2,r3,r2
  2245f8:	e0bff615 	stw	r2,-40(fp)
  2245fc:	00000406 	br	224610 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
  224600:	00c20004 	movi	r3,2048
  224604:	e0bff817 	ldw	r2,-32(fp)
  224608:	1885c83a 	sub	r2,r3,r2
  22460c:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
  224610:	e0bff617 	ldw	r2,-40(fp)
  224614:	1000011e 	bne	r2,zero,22461c <altera_avalon_jtag_uart_read+0x80>
        break; /* No more data available */
  224618:	00001d06 	br	224690 <altera_avalon_jtag_uart_read+0xf4>

      if (n > space)
  22461c:	e0fffe17 	ldw	r3,-8(fp)
  224620:	e0bff617 	ldw	r2,-40(fp)
  224624:	1880022e 	bgeu	r3,r2,224630 <altera_avalon_jtag_uart_read+0x94>
        n = space;
  224628:	e0bffe17 	ldw	r2,-8(fp)
  22462c:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
  224630:	e0bff817 	ldw	r2,-32(fp)
  224634:	10800e04 	addi	r2,r2,56
  224638:	e0fffc17 	ldw	r3,-16(fp)
  22463c:	1885883a 	add	r2,r3,r2
  224640:	e13ff517 	ldw	r4,-44(fp)
  224644:	100b883a 	mov	r5,r2
  224648:	e1bff617 	ldw	r6,-40(fp)
  22464c:	02214a00 	call	2214a0 <memcpy>
      ptr   += n;
  224650:	e0fff517 	ldw	r3,-44(fp)
  224654:	e0bff617 	ldw	r2,-40(fp)
  224658:	1885883a 	add	r2,r3,r2
  22465c:	e0bff515 	stw	r2,-44(fp)
      space -= n;
  224660:	e0fffe17 	ldw	r3,-8(fp)
  224664:	e0bff617 	ldw	r2,-40(fp)
  224668:	1885c83a 	sub	r2,r3,r2
  22466c:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  224670:	e0fff817 	ldw	r3,-32(fp)
  224674:	e0bff617 	ldw	r2,-40(fp)
  224678:	1885883a 	add	r2,r3,r2
  22467c:	10c1ffcc 	andi	r3,r2,2047
  224680:	e0bffc17 	ldw	r2,-16(fp)
  224684:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
  224688:	e0bffe17 	ldw	r2,-8(fp)
  22468c:	00bfce16 	blt	zero,r2,2245c8 <__alt_data_end+0xffff0d48>

    /* If we read any data then return it */
    if (ptr != buffer)
  224690:	e0fff517 	ldw	r3,-44(fp)
  224694:	e0bffd17 	ldw	r2,-12(fp)
  224698:	18800126 	beq	r3,r2,2246a0 <altera_avalon_jtag_uart_read+0x104>
      break;
  22469c:	00001506 	br	2246f4 <altera_avalon_jtag_uart_read+0x158>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
  2246a0:	e0bfff17 	ldw	r2,-4(fp)
  2246a4:	1090000c 	andi	r2,r2,16384
  2246a8:	10000126 	beq	r2,zero,2246b0 <altera_avalon_jtag_uart_read+0x114>
      break;
  2246ac:	00001106 	br	2246f4 <altera_avalon_jtag_uart_read+0x158>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
  2246b0:	0001883a 	nop
  2246b4:	e0bffc17 	ldw	r2,-16(fp)
  2246b8:	10c00a17 	ldw	r3,40(r2)
  2246bc:	e0bff717 	ldw	r2,-36(fp)
  2246c0:	1880051e 	bne	r3,r2,2246d8 <altera_avalon_jtag_uart_read+0x13c>
  2246c4:	e0bffc17 	ldw	r2,-16(fp)
  2246c8:	10c00917 	ldw	r3,36(r2)
  2246cc:	e0bffc17 	ldw	r2,-16(fp)
  2246d0:	10800117 	ldw	r2,4(r2)
  2246d4:	18bff736 	bltu	r3,r2,2246b4 <__alt_data_end+0xffff0e34>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
  2246d8:	e0bffc17 	ldw	r2,-16(fp)
  2246dc:	10c00a17 	ldw	r3,40(r2)
  2246e0:	e0bff717 	ldw	r2,-36(fp)
  2246e4:	1880011e 	bne	r3,r2,2246ec <altera_avalon_jtag_uart_read+0x150>
      break;
  2246e8:	00000206 	br	2246f4 <altera_avalon_jtag_uart_read+0x158>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
  2246ec:	e0bffe17 	ldw	r2,-8(fp)
  2246f0:	00bfb516 	blt	zero,r2,2245c8 <__alt_data_end+0xffff0d48>
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
  2246f4:	e0fff517 	ldw	r3,-44(fp)
  2246f8:	e0bffd17 	ldw	r2,-12(fp)
  2246fc:	18801826 	beq	r3,r2,224760 <altera_avalon_jtag_uart_read+0x1c4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  224700:	0005303a 	rdctl	r2,status
  224704:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  224708:	e0fffa17 	ldw	r3,-24(fp)
  22470c:	00bfff84 	movi	r2,-2
  224710:	1884703a 	and	r2,r3,r2
  224714:	1001703a 	wrctl	status,r2
  
  return context;
  224718:	e0bffa17 	ldw	r2,-24(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
  22471c:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
  224720:	e0bffc17 	ldw	r2,-16(fp)
  224724:	10800817 	ldw	r2,32(r2)
  224728:	10c00054 	ori	r3,r2,1
  22472c:	e0bffc17 	ldw	r2,-16(fp)
  224730:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  224734:	e0bffc17 	ldw	r2,-16(fp)
  224738:	10800017 	ldw	r2,0(r2)
  22473c:	10800104 	addi	r2,r2,4
  224740:	1007883a 	mov	r3,r2
  224744:	e0bffc17 	ldw	r2,-16(fp)
  224748:	10800817 	ldw	r2,32(r2)
  22474c:	18800035 	stwio	r2,0(r3)
  224750:	e0bff917 	ldw	r2,-28(fp)
  224754:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  224758:	e0bffb17 	ldw	r2,-20(fp)
  22475c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
  224760:	e0fff517 	ldw	r3,-44(fp)
  224764:	e0bffd17 	ldw	r2,-12(fp)
  224768:	18800426 	beq	r3,r2,22477c <altera_avalon_jtag_uart_read+0x1e0>
    return ptr - buffer;
  22476c:	e0fff517 	ldw	r3,-44(fp)
  224770:	e0bffd17 	ldw	r2,-12(fp)
  224774:	1885c83a 	sub	r2,r3,r2
  224778:	00000606 	br	224794 <altera_avalon_jtag_uart_read+0x1f8>
  else if (flags & O_NONBLOCK)
  22477c:	e0bfff17 	ldw	r2,-4(fp)
  224780:	1090000c 	andi	r2,r2,16384
  224784:	10000226 	beq	r2,zero,224790 <altera_avalon_jtag_uart_read+0x1f4>
    return -EWOULDBLOCK;
  224788:	00bffd44 	movi	r2,-11
  22478c:	00000106 	br	224794 <altera_avalon_jtag_uart_read+0x1f8>
  else
    return -EIO;
  224790:	00bffec4 	movi	r2,-5
}
  224794:	e037883a 	mov	sp,fp
  224798:	dfc00117 	ldw	ra,4(sp)
  22479c:	df000017 	ldw	fp,0(sp)
  2247a0:	dec00204 	addi	sp,sp,8
  2247a4:	f800283a 	ret

002247a8 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  2247a8:	defff304 	addi	sp,sp,-52
  2247ac:	dfc00c15 	stw	ra,48(sp)
  2247b0:	df000b15 	stw	fp,44(sp)
  2247b4:	df000b04 	addi	fp,sp,44
  2247b8:	e13ffc15 	stw	r4,-16(fp)
  2247bc:	e17ffd15 	stw	r5,-12(fp)
  2247c0:	e1bffe15 	stw	r6,-8(fp)
  2247c4:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
  2247c8:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
  2247cc:	e0bffd17 	ldw	r2,-12(fp)
  2247d0:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  2247d4:	00003806 	br	2248b8 <altera_avalon_jtag_uart_write+0x110>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
  2247d8:	e0bffc17 	ldw	r2,-16(fp)
  2247dc:	10800c17 	ldw	r2,48(r2)
  2247e0:	e0bff815 	stw	r2,-32(fp)
      out = sp->tx_out;
  2247e4:	e0bffc17 	ldw	r2,-16(fp)
  2247e8:	10800d17 	ldw	r2,52(r2)
  2247ec:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
  2247f0:	e0fff817 	ldw	r3,-32(fp)
  2247f4:	e0bff517 	ldw	r2,-44(fp)
  2247f8:	1880062e 	bgeu	r3,r2,224814 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
  2247fc:	e0fff517 	ldw	r3,-44(fp)
  224800:	e0bff817 	ldw	r2,-32(fp)
  224804:	1885c83a 	sub	r2,r3,r2
  224808:	10bfffc4 	addi	r2,r2,-1
  22480c:	e0bff615 	stw	r2,-40(fp)
  224810:	00000b06 	br	224840 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
  224814:	e0bff517 	ldw	r2,-44(fp)
  224818:	10000526 	beq	r2,zero,224830 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
  22481c:	00c20004 	movi	r3,2048
  224820:	e0bff817 	ldw	r2,-32(fp)
  224824:	1885c83a 	sub	r2,r3,r2
  224828:	e0bff615 	stw	r2,-40(fp)
  22482c:	00000406 	br	224840 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
  224830:	00c1ffc4 	movi	r3,2047
  224834:	e0bff817 	ldw	r2,-32(fp)
  224838:	1885c83a 	sub	r2,r3,r2
  22483c:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
  224840:	e0bff617 	ldw	r2,-40(fp)
  224844:	1000011e 	bne	r2,zero,22484c <altera_avalon_jtag_uart_write+0xa4>
        break;
  224848:	00001d06 	br	2248c0 <altera_avalon_jtag_uart_write+0x118>

      if (n > count)
  22484c:	e0fffe17 	ldw	r3,-8(fp)
  224850:	e0bff617 	ldw	r2,-40(fp)
  224854:	1880022e 	bgeu	r3,r2,224860 <altera_avalon_jtag_uart_write+0xb8>
        n = count;
  224858:	e0bffe17 	ldw	r2,-8(fp)
  22485c:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
  224860:	e0bff817 	ldw	r2,-32(fp)
  224864:	10820e04 	addi	r2,r2,2104
  224868:	e0fffc17 	ldw	r3,-16(fp)
  22486c:	1885883a 	add	r2,r3,r2
  224870:	1009883a 	mov	r4,r2
  224874:	e17ffd17 	ldw	r5,-12(fp)
  224878:	e1bff617 	ldw	r6,-40(fp)
  22487c:	02214a00 	call	2214a0 <memcpy>
      ptr   += n;
  224880:	e0fffd17 	ldw	r3,-12(fp)
  224884:	e0bff617 	ldw	r2,-40(fp)
  224888:	1885883a 	add	r2,r3,r2
  22488c:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
  224890:	e0fffe17 	ldw	r3,-8(fp)
  224894:	e0bff617 	ldw	r2,-40(fp)
  224898:	1885c83a 	sub	r2,r3,r2
  22489c:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
  2248a0:	e0fff817 	ldw	r3,-32(fp)
  2248a4:	e0bff617 	ldw	r2,-40(fp)
  2248a8:	1885883a 	add	r2,r3,r2
  2248ac:	10c1ffcc 	andi	r3,r2,2047
  2248b0:	e0bffc17 	ldw	r2,-16(fp)
  2248b4:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
  2248b8:	e0bffe17 	ldw	r2,-8(fp)
  2248bc:	00bfc616 	blt	zero,r2,2247d8 <__alt_data_end+0xffff0f58>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  2248c0:	0005303a 	rdctl	r2,status
  2248c4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  2248c8:	e0fffa17 	ldw	r3,-24(fp)
  2248cc:	00bfff84 	movi	r2,-2
  2248d0:	1884703a 	and	r2,r3,r2
  2248d4:	1001703a 	wrctl	status,r2
  
  return context;
  2248d8:	e0bffa17 	ldw	r2,-24(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
  2248dc:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
  2248e0:	e0bffc17 	ldw	r2,-16(fp)
  2248e4:	10800817 	ldw	r2,32(r2)
  2248e8:	10c00094 	ori	r3,r2,2
  2248ec:	e0bffc17 	ldw	r2,-16(fp)
  2248f0:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
  2248f4:	e0bffc17 	ldw	r2,-16(fp)
  2248f8:	10800017 	ldw	r2,0(r2)
  2248fc:	10800104 	addi	r2,r2,4
  224900:	1007883a 	mov	r3,r2
  224904:	e0bffc17 	ldw	r2,-16(fp)
  224908:	10800817 	ldw	r2,32(r2)
  22490c:	18800035 	stwio	r2,0(r3)
  224910:	e0bff917 	ldw	r2,-28(fp)
  224914:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  224918:	e0bffb17 	ldw	r2,-20(fp)
  22491c:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
  224920:	e0bffe17 	ldw	r2,-8(fp)
  224924:	0080120e 	bge	zero,r2,224970 <altera_avalon_jtag_uart_write+0x1c8>
    {
      if (flags & O_NONBLOCK)
  224928:	e0bfff17 	ldw	r2,-4(fp)
  22492c:	1090000c 	andi	r2,r2,16384
  224930:	10000126 	beq	r2,zero,224938 <altera_avalon_jtag_uart_write+0x190>
        break;
  224934:	00001006 	br	224978 <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
  224938:	0001883a 	nop
  22493c:	e0bffc17 	ldw	r2,-16(fp)
  224940:	10c00d17 	ldw	r3,52(r2)
  224944:	e0bff517 	ldw	r2,-44(fp)
  224948:	1880051e 	bne	r3,r2,224960 <altera_avalon_jtag_uart_write+0x1b8>
  22494c:	e0bffc17 	ldw	r2,-16(fp)
  224950:	10c00917 	ldw	r3,36(r2)
  224954:	e0bffc17 	ldw	r2,-16(fp)
  224958:	10800117 	ldw	r2,4(r2)
  22495c:	18bff736 	bltu	r3,r2,22493c <__alt_data_end+0xffff10bc>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
  224960:	e0bffc17 	ldw	r2,-16(fp)
  224964:	10800917 	ldw	r2,36(r2)
  224968:	10000126 	beq	r2,zero,224970 <altera_avalon_jtag_uart_write+0x1c8>
         break;
  22496c:	00000206 	br	224978 <altera_avalon_jtag_uart_write+0x1d0>
    }
  }
  while (count > 0);
  224970:	e0bffe17 	ldw	r2,-8(fp)
  224974:	00bf9716 	blt	zero,r2,2247d4 <__alt_data_end+0xffff0f54>
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
  224978:	e0fffd17 	ldw	r3,-12(fp)
  22497c:	e0bff717 	ldw	r2,-36(fp)
  224980:	18800426 	beq	r3,r2,224994 <altera_avalon_jtag_uart_write+0x1ec>
    return ptr - start;
  224984:	e0fffd17 	ldw	r3,-12(fp)
  224988:	e0bff717 	ldw	r2,-36(fp)
  22498c:	1885c83a 	sub	r2,r3,r2
  224990:	00000606 	br	2249ac <altera_avalon_jtag_uart_write+0x204>
  else if (flags & O_NONBLOCK)
  224994:	e0bfff17 	ldw	r2,-4(fp)
  224998:	1090000c 	andi	r2,r2,16384
  22499c:	10000226 	beq	r2,zero,2249a8 <altera_avalon_jtag_uart_write+0x200>
    return -EWOULDBLOCK;
  2249a0:	00bffd44 	movi	r2,-11
  2249a4:	00000106 	br	2249ac <altera_avalon_jtag_uart_write+0x204>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
  2249a8:	00bffec4 	movi	r2,-5
}
  2249ac:	e037883a 	mov	sp,fp
  2249b0:	dfc00117 	ldw	ra,4(sp)
  2249b4:	df000017 	ldw	fp,0(sp)
  2249b8:	dec00204 	addi	sp,sp,8
  2249bc:	f800283a 	ret

002249c0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  2249c0:	defffe04 	addi	sp,sp,-8
  2249c4:	dfc00115 	stw	ra,4(sp)
  2249c8:	df000015 	stw	fp,0(sp)
  2249cc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  2249d0:	008008f4 	movhi	r2,35
  2249d4:	10a2dc04 	addi	r2,r2,-29840
  2249d8:	10800017 	ldw	r2,0(r2)
  2249dc:	10000526 	beq	r2,zero,2249f4 <alt_get_errno+0x34>
  2249e0:	008008f4 	movhi	r2,35
  2249e4:	10a2dc04 	addi	r2,r2,-29840
  2249e8:	10800017 	ldw	r2,0(r2)
  2249ec:	103ee83a 	callr	r2
  2249f0:	00000206 	br	2249fc <alt_get_errno+0x3c>
  2249f4:	008008f4 	movhi	r2,35
  2249f8:	10a9ca04 	addi	r2,r2,-22744
}
  2249fc:	e037883a 	mov	sp,fp
  224a00:	dfc00117 	ldw	ra,4(sp)
  224a04:	df000017 	ldw	fp,0(sp)
  224a08:	dec00204 	addi	sp,sp,8
  224a0c:	f800283a 	ret

00224a10 <alt_mutex_trylock>:
 *
 * returns 0 on success -1 otherwise
 *
 */
static int alt_mutex_trylock( alt_mutex_dev* dev, alt_u32 value )
{
  224a10:	defff904 	addi	sp,sp,-28
  224a14:	df000615 	stw	fp,24(sp)
  224a18:	df000604 	addi	fp,sp,24
  224a1c:	e13ffe15 	stw	r4,-8(fp)
  224a20:	e17fff15 	stw	r5,-4(fp)
  alt_u32 id, data, check;
  int ret_code = -1;
  224a24:	00bfffc4 	movi	r2,-1
  224a28:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_READ_CPUID(id);
  224a2c:	0005317a 	rdctl	r2,cpuid
  224a30:	e0bffb15 	stw	r2,-20(fp)

  /* the data we want the mutex to hold */
  data = (id << ALTERA_AVALON_MUTEX_MUTEX_OWNER_OFST) | value;
  224a34:	e0bffb17 	ldw	r2,-20(fp)
  224a38:	1006943a 	slli	r3,r2,16
  224a3c:	e0bfff17 	ldw	r2,-4(fp)
  224a40:	1884b03a 	or	r2,r3,r2
  224a44:	e0bffc15 	stw	r2,-16(fp)

  /* attempt to write to the mutex */
  IOWR_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base, data);
  224a48:	e0bffe17 	ldw	r2,-8(fp)
  224a4c:	10800317 	ldw	r2,12(r2)
  224a50:	e0fffc17 	ldw	r3,-16(fp)
  224a54:	10c00035 	stwio	r3,0(r2)
  
  check = IORD_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base);
  224a58:	e0bffe17 	ldw	r2,-8(fp)
  224a5c:	10800317 	ldw	r2,12(r2)
  224a60:	10800037 	ldwio	r2,0(r2)
  224a64:	e0bffd15 	stw	r2,-12(fp)

  if ( check == data)
  224a68:	e0fffd17 	ldw	r3,-12(fp)
  224a6c:	e0bffc17 	ldw	r2,-16(fp)
  224a70:	1880011e 	bne	r3,r2,224a78 <alt_mutex_trylock+0x68>
  {
    ret_code = 0;
  224a74:	e03ffa15 	stw	zero,-24(fp)
  }

  return ret_code;
  224a78:	e0bffa17 	ldw	r2,-24(fp)
}
  224a7c:	e037883a 	mov	sp,fp
  224a80:	df000017 	ldw	fp,0(sp)
  224a84:	dec00104 	addi	sp,sp,4
  224a88:	f800283a 	ret

00224a8c <altera_avalon_mutex_open>:
 * Search the list of registered mutexes for one with the supplied name.
 *
 * The return value will be NULL on failure, and non-NULL otherwise.
 */
alt_mutex_dev* altera_avalon_mutex_open (const char* name)
{
  224a8c:	defffc04 	addi	sp,sp,-16
  224a90:	dfc00315 	stw	ra,12(sp)
  224a94:	df000215 	stw	fp,8(sp)
  224a98:	df000204 	addi	fp,sp,8
  224a9c:	e13fff15 	stw	r4,-4(fp)
  alt_mutex_dev* dev;

  dev = (alt_mutex_dev*) alt_find_dev (name, &alt_mutex_list);
  224aa0:	e13fff17 	ldw	r4,-4(fp)
  224aa4:	d1600b04 	addi	r5,gp,-32724
  224aa8:	0225ba00 	call	225ba0 <alt_find_dev>
  224aac:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev)
  224ab0:	e0bffe17 	ldw	r2,-8(fp)
  224ab4:	1000041e 	bne	r2,zero,224ac8 <altera_avalon_mutex_open+0x3c>
  {
    ALT_ERRNO = ENODEV;
  224ab8:	02249c00 	call	2249c0 <alt_get_errno>
  224abc:	1007883a 	mov	r3,r2
  224ac0:	008004c4 	movi	r2,19
  224ac4:	18800015 	stw	r2,0(r3)
  }

  return dev;
  224ac8:	e0bffe17 	ldw	r2,-8(fp)
}
  224acc:	e037883a 	mov	sp,fp
  224ad0:	dfc00117 	ldw	ra,4(sp)
  224ad4:	df000017 	ldw	fp,0(sp)
  224ad8:	dec00204 	addi	sp,sp,8
  224adc:	f800283a 	ret

00224ae0 <altera_avalon_mutex_close>:
 * altera_avalon_mutex_close - Does nothing at the moment, but included for 
 * completeness
 *
 */
void altera_avalon_mutex_close (alt_mutex_dev* dev)
{
  224ae0:	defffe04 	addi	sp,sp,-8
  224ae4:	df000115 	stw	fp,4(sp)
  224ae8:	df000104 	addi	fp,sp,4
  224aec:	e13fff15 	stw	r4,-4(fp)
  return;
  224af0:	0001883a 	nop
}
  224af4:	e037883a 	mov	sp,fp
  224af8:	df000017 	ldw	fp,0(sp)
  224afc:	dec00104 	addi	sp,sp,4
  224b00:	f800283a 	ret

00224b04 <altera_avalon_mutex_lock>:
/*
 * altera_avalon_mutex_lock - Lock the hardware mutex
 *
 */
void altera_avalon_mutex_lock( alt_mutex_dev* dev, alt_u32 value )
{
  224b04:	defffc04 	addi	sp,sp,-16
  224b08:	dfc00315 	stw	ra,12(sp)
  224b0c:	df000215 	stw	fp,8(sp)
  224b10:	df000204 	addi	fp,sp,8
  224b14:	e13ffe15 	stw	r4,-8(fp)
  224b18:	e17fff15 	stw	r5,-4(fp)
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (dev->lock, 0);

  while ( alt_mutex_trylock( dev, value ) != 0);
  224b1c:	0001883a 	nop
  224b20:	e13ffe17 	ldw	r4,-8(fp)
  224b24:	e17fff17 	ldw	r5,-4(fp)
  224b28:	0224a100 	call	224a10 <alt_mutex_trylock>
  224b2c:	103ffc1e 	bne	r2,zero,224b20 <__alt_data_end+0xffff12a0>
}
  224b30:	e037883a 	mov	sp,fp
  224b34:	dfc00117 	ldw	ra,4(sp)
  224b38:	df000017 	ldw	fp,0(sp)
  224b3c:	dec00204 	addi	sp,sp,8
  224b40:	f800283a 	ret

00224b44 <altera_avalon_mutex_trylock>:
 *
 * returns 0 on success -1 otherwise
 *
 */
int altera_avalon_mutex_trylock( alt_mutex_dev* dev, alt_u32 value )
{
  224b44:	defffa04 	addi	sp,sp,-24
  224b48:	dfc00515 	stw	ra,20(sp)
  224b4c:	df000415 	stw	fp,16(sp)
  224b50:	df000404 	addi	fp,sp,16
  224b54:	e13ffd15 	stw	r4,-12(fp)
  224b58:	e17ffe15 	stw	r5,-8(fp)
  int ret_code;

  ALT_SEM_PEND (dev->lock, 0);

  ret_code = alt_mutex_trylock( dev, value);
  224b5c:	e13ffd17 	ldw	r4,-12(fp)
  224b60:	e17ffe17 	ldw	r5,-8(fp)
  224b64:	0224a100 	call	224a10 <alt_mutex_trylock>
  224b68:	e0bffc15 	stw	r2,-16(fp)
  if (ret_code)
  {
    ALT_SEM_POST (dev->lock);
  }

  return ret_code;
  224b6c:	e0bffc17 	ldw	r2,-16(fp)
}
  224b70:	e037883a 	mov	sp,fp
  224b74:	dfc00117 	ldw	ra,4(sp)
  224b78:	df000017 	ldw	fp,0(sp)
  224b7c:	dec00204 	addi	sp,sp,8
  224b80:	f800283a 	ret

00224b84 <altera_avalon_mutex_unlock>:
 * This function does not check that you own the Mutex if you try to release
 * a Mutex you do not own the behaviour is undefined
 *
 */
void altera_avalon_mutex_unlock( alt_mutex_dev* dev )
{
  224b84:	defffd04 	addi	sp,sp,-12
  224b88:	df000215 	stw	fp,8(sp)
  224b8c:	df000204 	addi	fp,sp,8
  224b90:	e13fff15 	stw	r4,-4(fp)
  alt_u32 id;
  NIOS2_READ_CPUID(id);
  224b94:	0005317a 	rdctl	r2,cpuid
  224b98:	e0bffe15 	stw	r2,-8(fp)

  /*
  * This Mutex has been claimed and released since Reset so clear the Reset bit
  * This MUST happen before we release the MUTEX
  */
  IOWR_ALTERA_AVALON_MUTEX_RESET(dev->mutex_base, 
  224b9c:	e0bfff17 	ldw	r2,-4(fp)
  224ba0:	10800317 	ldw	r2,12(r2)
  224ba4:	10800104 	addi	r2,r2,4
  224ba8:	00c00044 	movi	r3,1
  224bac:	10c00035 	stwio	r3,0(r2)
                                  ALTERA_AVALON_MUTEX_RESET_RESET_MSK);
  IOWR_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base, 
  224bb0:	e0bfff17 	ldw	r2,-4(fp)
  224bb4:	10800317 	ldw	r2,12(r2)
  224bb8:	e0fffe17 	ldw	r3,-8(fp)
  224bbc:	1806943a 	slli	r3,r3,16
  224bc0:	10c00035 	stwio	r3,0(r2)

  /*
  * Now that access to the hardware Mutex is complete, release the thread lock
  */
  ALT_SEM_POST (dev->lock);
}
  224bc4:	e037883a 	mov	sp,fp
  224bc8:	df000017 	ldw	fp,0(sp)
  224bcc:	dec00104 	addi	sp,sp,4
  224bd0:	f800283a 	ret

00224bd4 <altera_avalon_mutex_is_mine>:
 * altera_avalon_mutex_is_mine - Do I own the Mutex?
 *
 *  returns non zero if the mutex is owned by this CPU
 */
int altera_avalon_mutex_is_mine( alt_mutex_dev* dev )
{
  224bd4:	defff904 	addi	sp,sp,-28
  224bd8:	df000615 	stw	fp,24(sp)
  224bdc:	df000604 	addi	fp,sp,24
  224be0:	e13fff15 	stw	r4,-4(fp)
  alt_u32 id, data, owner, value;
  int ret_code = 0;
  224be4:	e03ffa15 	stw	zero,-24(fp)

  NIOS2_READ_CPUID(id);
  224be8:	0005317a 	rdctl	r2,cpuid
  224bec:	e0bffb15 	stw	r2,-20(fp)

  /* retrieve the contents of the mutex */
  data = IORD_ALTERA_AVALON_MUTEX_MUTEX(dev->mutex_base);
  224bf0:	e0bfff17 	ldw	r2,-4(fp)
  224bf4:	10800317 	ldw	r2,12(r2)
  224bf8:	10800037 	ldwio	r2,0(r2)
  224bfc:	e0bffc15 	stw	r2,-16(fp)
  owner = (data & ALTERA_AVALON_MUTEX_MUTEX_OWNER_MSK) >> 
  224c00:	e0bffc17 	ldw	r2,-16(fp)
  224c04:	1004d43a 	srli	r2,r2,16
  224c08:	e0bffd15 	stw	r2,-12(fp)
              ALTERA_AVALON_MUTEX_MUTEX_OWNER_OFST;

  if (owner == id) 
  224c0c:	e0fffd17 	ldw	r3,-12(fp)
  224c10:	e0bffb17 	ldw	r2,-20(fp)
  224c14:	1880071e 	bne	r3,r2,224c34 <altera_avalon_mutex_is_mine+0x60>
  {
    value = (data & ALTERA_AVALON_MUTEX_MUTEX_VALUE_MSK) >> 
  224c18:	e0bffc17 	ldw	r2,-16(fp)
  224c1c:	10bfffcc 	andi	r2,r2,65535
  224c20:	e0bffe15 	stw	r2,-8(fp)
                  ALTERA_AVALON_MUTEX_MUTEX_VALUE_OFST;
    if (value != 0)
  224c24:	e0bffe17 	ldw	r2,-8(fp)
  224c28:	10000226 	beq	r2,zero,224c34 <altera_avalon_mutex_is_mine+0x60>
    {
      ret_code = 1;
  224c2c:	00800044 	movi	r2,1
  224c30:	e0bffa15 	stw	r2,-24(fp)
    }
  }

  return ret_code;
  224c34:	e0bffa17 	ldw	r2,-24(fp)
}
  224c38:	e037883a 	mov	sp,fp
  224c3c:	df000017 	ldw	fp,0(sp)
  224c40:	dec00104 	addi	sp,sp,4
  224c44:	f800283a 	ret

00224c48 <altera_avalon_mutex_first_lock>:
 *
 * Has this Mutex been released since reset if not return 1
 * otherwise return 0
 */
int altera_avalon_mutex_first_lock( alt_mutex_dev* dev )
{
  224c48:	defffc04 	addi	sp,sp,-16
  224c4c:	df000315 	stw	fp,12(sp)
  224c50:	df000304 	addi	fp,sp,12
  224c54:	e13fff15 	stw	r4,-4(fp)
  alt_u32 data;
  int ret_code = 0;
  224c58:	e03ffd15 	stw	zero,-12(fp)

  data = IORD_ALTERA_AVALON_MUTEX_RESET(dev->mutex_base);
  224c5c:	e0bfff17 	ldw	r2,-4(fp)
  224c60:	10800317 	ldw	r2,12(r2)
  224c64:	10800104 	addi	r2,r2,4
  224c68:	10800037 	ldwio	r2,0(r2)
  224c6c:	e0bffe15 	stw	r2,-8(fp)

  if (data & ALTERA_AVALON_MUTEX_RESET_RESET_MSK) 
  224c70:	e0bffe17 	ldw	r2,-8(fp)
  224c74:	1080004c 	andi	r2,r2,1
  224c78:	10000226 	beq	r2,zero,224c84 <altera_avalon_mutex_first_lock+0x3c>
  {
    ret_code = 1;
  224c7c:	00800044 	movi	r2,1
  224c80:	e0bffd15 	stw	r2,-12(fp)
  }

  return ret_code;
  224c84:	e0bffd17 	ldw	r2,-12(fp)
}
  224c88:	e037883a 	mov	sp,fp
  224c8c:	df000017 	ldw	fp,0(sp)
  224c90:	dec00104 	addi	sp,sp,4
  224c94:	f800283a 	ret

00224c98 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
  224c98:	defffa04 	addi	sp,sp,-24
  224c9c:	dfc00515 	stw	ra,20(sp)
  224ca0:	df000415 	stw	fp,16(sp)
  224ca4:	df000404 	addi	fp,sp,16
  224ca8:	e13ffd15 	stw	r4,-12(fp)
  224cac:	e17ffe15 	stw	r5,-8(fp)
  224cb0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  224cb4:	e0bffd17 	ldw	r2,-12(fp)
  224cb8:	10800017 	ldw	r2,0(r2)
  224cbc:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
  224cc0:	e0bffc17 	ldw	r2,-16(fp)
  224cc4:	10c00a04 	addi	r3,r2,40
  224cc8:	e0bffd17 	ldw	r2,-12(fp)
  224ccc:	10800217 	ldw	r2,8(r2)
  224cd0:	1809883a 	mov	r4,r3
  224cd4:	e17ffe17 	ldw	r5,-8(fp)
  224cd8:	e1bfff17 	ldw	r6,-4(fp)
  224cdc:	100f883a 	mov	r7,r2
  224ce0:	02251b00 	call	2251b0 <altera_avalon_uart_read>
      fd->fd_flags);
}
  224ce4:	e037883a 	mov	sp,fp
  224ce8:	dfc00117 	ldw	ra,4(sp)
  224cec:	df000017 	ldw	fp,0(sp)
  224cf0:	dec00204 	addi	sp,sp,8
  224cf4:	f800283a 	ret

00224cf8 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
  224cf8:	defffa04 	addi	sp,sp,-24
  224cfc:	dfc00515 	stw	ra,20(sp)
  224d00:	df000415 	stw	fp,16(sp)
  224d04:	df000404 	addi	fp,sp,16
  224d08:	e13ffd15 	stw	r4,-12(fp)
  224d0c:	e17ffe15 	stw	r5,-8(fp)
  224d10:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  224d14:	e0bffd17 	ldw	r2,-12(fp)
  224d18:	10800017 	ldw	r2,0(r2)
  224d1c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
  224d20:	e0bffc17 	ldw	r2,-16(fp)
  224d24:	10c00a04 	addi	r3,r2,40
  224d28:	e0bffd17 	ldw	r2,-12(fp)
  224d2c:	10800217 	ldw	r2,8(r2)
  224d30:	1809883a 	mov	r4,r3
  224d34:	e17ffe17 	ldw	r5,-8(fp)
  224d38:	e1bfff17 	ldw	r6,-4(fp)
  224d3c:	100f883a 	mov	r7,r2
  224d40:	02253dc0 	call	2253dc <altera_avalon_uart_write>
      fd->fd_flags);
}
  224d44:	e037883a 	mov	sp,fp
  224d48:	dfc00117 	ldw	ra,4(sp)
  224d4c:	df000017 	ldw	fp,0(sp)
  224d50:	dec00204 	addi	sp,sp,8
  224d54:	f800283a 	ret

00224d58 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
  224d58:	defffc04 	addi	sp,sp,-16
  224d5c:	dfc00315 	stw	ra,12(sp)
  224d60:	df000215 	stw	fp,8(sp)
  224d64:	df000204 	addi	fp,sp,8
  224d68:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
  224d6c:	e0bfff17 	ldw	r2,-4(fp)
  224d70:	10800017 	ldw	r2,0(r2)
  224d74:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
  224d78:	e0bffe17 	ldw	r2,-8(fp)
  224d7c:	10c00a04 	addi	r3,r2,40
  224d80:	e0bfff17 	ldw	r2,-4(fp)
  224d84:	10800217 	ldw	r2,8(r2)
  224d88:	1809883a 	mov	r4,r3
  224d8c:	100b883a 	mov	r5,r2
  224d90:	022510c0 	call	22510c <altera_avalon_uart_close>
}
  224d94:	e037883a 	mov	sp,fp
  224d98:	dfc00117 	ldw	ra,4(sp)
  224d9c:	df000017 	ldw	fp,0(sp)
  224da0:	dec00204 	addi	sp,sp,8
  224da4:	f800283a 	ret

00224da8 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
  224da8:	defff804 	addi	sp,sp,-32
  224dac:	dfc00715 	stw	ra,28(sp)
  224db0:	df000615 	stw	fp,24(sp)
  224db4:	df000604 	addi	fp,sp,24
  224db8:	e13ffd15 	stw	r4,-12(fp)
  224dbc:	e17ffe15 	stw	r5,-8(fp)
  224dc0:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
  224dc4:	e0bffd17 	ldw	r2,-12(fp)
  224dc8:	10800017 	ldw	r2,0(r2)
  224dcc:	e0bffb15 	stw	r2,-20(fp)
  224dd0:	0005883a 	mov	r2,zero
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
  224dd4:	1000041e 	bne	r2,zero,224de8 <altera_avalon_uart_init+0x40>
  224dd8:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
  224ddc:	1000021e 	bne	r2,zero,224de8 <altera_avalon_uart_init+0x40>
  224de0:	0005883a 	mov	r2,zero
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
  224de4:	10000226 	beq	r2,zero,224df0 <altera_avalon_uart_init+0x48>
  224de8:	00800044 	movi	r2,1
  224dec:	00000106 	br	224df4 <altera_avalon_uart_init+0x4c>
  224df0:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
  224df4:	e0bffc15 	stw	r2,-16(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
  224df8:	e0bffc17 	ldw	r2,-16(fp)
  224dfc:	10000f1e 	bne	r2,zero,224e3c <altera_avalon_uart_init+0x94>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
  224e00:	e0bffd17 	ldw	r2,-12(fp)
  224e04:	00c32004 	movi	r3,3200
  224e08:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
  224e0c:	e0bffb17 	ldw	r2,-20(fp)
  224e10:	10800304 	addi	r2,r2,12
  224e14:	e0fffd17 	ldw	r3,-12(fp)
  224e18:	18c00117 	ldw	r3,4(r3)
  224e1c:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
  224e20:	d8000015 	stw	zero,0(sp)
  224e24:	e13ffe17 	ldw	r4,-8(fp)
  224e28:	e17fff17 	ldw	r5,-4(fp)
  224e2c:	018008b4 	movhi	r6,34
  224e30:	31939404 	addi	r6,r6,20048
  224e34:	e1fffd17 	ldw	r7,-12(fp)
  224e38:	0225c600 	call	225c60 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
  224e3c:	e037883a 	mov	sp,fp
  224e40:	dfc00117 	ldw	ra,4(sp)
  224e44:	df000017 	ldw	fp,0(sp)
  224e48:	dec00204 	addi	sp,sp,8
  224e4c:	f800283a 	ret

00224e50 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
  224e50:	defffa04 	addi	sp,sp,-24
  224e54:	dfc00515 	stw	ra,20(sp)
  224e58:	df000415 	stw	fp,16(sp)
  224e5c:	df000404 	addi	fp,sp,16
  224e60:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
  224e64:	e0bfff17 	ldw	r2,-4(fp)
  224e68:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
  224e6c:	e0bffc17 	ldw	r2,-16(fp)
  224e70:	10800017 	ldw	r2,0(r2)
  224e74:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
  224e78:	e0bffd17 	ldw	r2,-12(fp)
  224e7c:	10800204 	addi	r2,r2,8
  224e80:	10800037 	ldwio	r2,0(r2)
  224e84:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
  224e88:	e0bffd17 	ldw	r2,-12(fp)
  224e8c:	10800204 	addi	r2,r2,8
  224e90:	0007883a 	mov	r3,zero
  224e94:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
  224e98:	e0bffd17 	ldw	r2,-12(fp)
  224e9c:	10800204 	addi	r2,r2,8
  224ea0:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
  224ea4:	e0bffe17 	ldw	r2,-8(fp)
  224ea8:	1080200c 	andi	r2,r2,128
  224eac:	10000326 	beq	r2,zero,224ebc <altera_avalon_uart_irq+0x6c>
  {
    altera_avalon_uart_rxirq(sp, status);
  224eb0:	e13ffc17 	ldw	r4,-16(fp)
  224eb4:	e17ffe17 	ldw	r5,-8(fp)
  224eb8:	0224ee80 	call	224ee8 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
  224ebc:	e0bffe17 	ldw	r2,-8(fp)
  224ec0:	1081100c 	andi	r2,r2,1088
  224ec4:	10000326 	beq	r2,zero,224ed4 <altera_avalon_uart_irq+0x84>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
  224ec8:	e13ffc17 	ldw	r4,-16(fp)
  224ecc:	e17ffe17 	ldw	r5,-8(fp)
  224ed0:	0224fc80 	call	224fc8 <altera_avalon_uart_txirq>
  }
  

}
  224ed4:	e037883a 	mov	sp,fp
  224ed8:	dfc00117 	ldw	ra,4(sp)
  224edc:	df000017 	ldw	fp,0(sp)
  224ee0:	dec00204 	addi	sp,sp,8
  224ee4:	f800283a 	ret

00224ee8 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
  224ee8:	defffc04 	addi	sp,sp,-16
  224eec:	df000315 	stw	fp,12(sp)
  224ef0:	df000304 	addi	fp,sp,12
  224ef4:	e13ffe15 	stw	r4,-8(fp)
  224ef8:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
  224efc:	e0bfff17 	ldw	r2,-4(fp)
  224f00:	108000cc 	andi	r2,r2,3
  224f04:	10000126 	beq	r2,zero,224f0c <altera_avalon_uart_rxirq+0x24>
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
  224f08:	00002b06 	br	224fb8 <altera_avalon_uart_rxirq+0xd0>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
  224f0c:	e0bffe17 	ldw	r2,-8(fp)
  224f10:	10800317 	ldw	r2,12(r2)
  224f14:	e0bffe17 	ldw	r2,-8(fp)
  224f18:	10800217 	ldw	r2,8(r2)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  224f1c:	e0bffe17 	ldw	r2,-8(fp)
  224f20:	10800317 	ldw	r2,12(r2)
  224f24:	10800044 	addi	r2,r2,1
  224f28:	10800fcc 	andi	r2,r2,63
  224f2c:	e0bffd15 	stw	r2,-12(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
  224f30:	e0bffe17 	ldw	r2,-8(fp)
  224f34:	10800317 	ldw	r2,12(r2)
  224f38:	e0fffe17 	ldw	r3,-8(fp)
  224f3c:	18c00017 	ldw	r3,0(r3)
  224f40:	18c00037 	ldwio	r3,0(r3)
  224f44:	1809883a 	mov	r4,r3
  224f48:	e0fffe17 	ldw	r3,-8(fp)
  224f4c:	1885883a 	add	r2,r3,r2
  224f50:	10800704 	addi	r2,r2,28
  224f54:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
  224f58:	e0bffe17 	ldw	r2,-8(fp)
  224f5c:	e0fffd17 	ldw	r3,-12(fp)
  224f60:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  224f64:	e0bffe17 	ldw	r2,-8(fp)
  224f68:	10800317 	ldw	r2,12(r2)
  224f6c:	10800044 	addi	r2,r2,1
  224f70:	10800fcc 	andi	r2,r2,63
  224f74:	e0bffd15 	stw	r2,-12(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
  224f78:	e0bffe17 	ldw	r2,-8(fp)
  224f7c:	10c00217 	ldw	r3,8(r2)
  224f80:	e0bffd17 	ldw	r2,-12(fp)
  224f84:	18800c1e 	bne	r3,r2,224fb8 <altera_avalon_uart_rxirq+0xd0>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  224f88:	e0bffe17 	ldw	r2,-8(fp)
  224f8c:	10c00117 	ldw	r3,4(r2)
  224f90:	00bfdfc4 	movi	r2,-129
  224f94:	1886703a 	and	r3,r3,r2
  224f98:	e0bffe17 	ldw	r2,-8(fp)
  224f9c:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  224fa0:	e0bffe17 	ldw	r2,-8(fp)
  224fa4:	10800017 	ldw	r2,0(r2)
  224fa8:	10800304 	addi	r2,r2,12
  224fac:	e0fffe17 	ldw	r3,-8(fp)
  224fb0:	18c00117 	ldw	r3,4(r3)
  224fb4:	10c00035 	stwio	r3,0(r2)
  }   
}
  224fb8:	e037883a 	mov	sp,fp
  224fbc:	df000017 	ldw	fp,0(sp)
  224fc0:	dec00104 	addi	sp,sp,4
  224fc4:	f800283a 	ret

00224fc8 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
  224fc8:	defffb04 	addi	sp,sp,-20
  224fcc:	df000415 	stw	fp,16(sp)
  224fd0:	df000404 	addi	fp,sp,16
  224fd4:	e13ffc15 	stw	r4,-16(fp)
  224fd8:	e17ffd15 	stw	r5,-12(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
  224fdc:	e0bffc17 	ldw	r2,-16(fp)
  224fe0:	10c00417 	ldw	r3,16(r2)
  224fe4:	e0bffc17 	ldw	r2,-16(fp)
  224fe8:	10800517 	ldw	r2,20(r2)
  224fec:	18803226 	beq	r3,r2,2250b8 <altera_avalon_uart_txirq+0xf0>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
  224ff0:	e0bffc17 	ldw	r2,-16(fp)
  224ff4:	10800617 	ldw	r2,24(r2)
  224ff8:	1080008c 	andi	r2,r2,2
  224ffc:	10000326 	beq	r2,zero,22500c <altera_avalon_uart_txirq+0x44>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
  225000:	e0bffd17 	ldw	r2,-12(fp)
  225004:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
  225008:	10001d26 	beq	r2,zero,225080 <altera_avalon_uart_txirq+0xb8>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
  22500c:	e0bffc17 	ldw	r2,-16(fp)
  225010:	10800417 	ldw	r2,16(r2)
  225014:	e0bffc17 	ldw	r2,-16(fp)
  225018:	10800517 	ldw	r2,20(r2)
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
  22501c:	e0bffc17 	ldw	r2,-16(fp)
  225020:	10800017 	ldw	r2,0(r2)
  225024:	10800104 	addi	r2,r2,4
  225028:	e0fffc17 	ldw	r3,-16(fp)
  22502c:	18c00417 	ldw	r3,16(r3)
  225030:	e13ffc17 	ldw	r4,-16(fp)
  225034:	20c7883a 	add	r3,r4,r3
  225038:	18c01704 	addi	r3,r3,92
  22503c:	18c00003 	ldbu	r3,0(r3)
  225040:	18c03fcc 	andi	r3,r3,255
  225044:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
  225048:	e0bffc17 	ldw	r2,-16(fp)
  22504c:	10800417 	ldw	r2,16(r2)
  225050:	10800044 	addi	r2,r2,1
  225054:	e0fffc17 	ldw	r3,-16(fp)
  225058:	18800415 	stw	r2,16(r3)
  22505c:	10c00fcc 	andi	r3,r2,63
  225060:	e0bffc17 	ldw	r2,-16(fp)
  225064:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
  225068:	e0bffc17 	ldw	r2,-16(fp)
  22506c:	10800117 	ldw	r2,4(r2)
  225070:	10c01014 	ori	r3,r2,64
  225074:	e0bffc17 	ldw	r2,-16(fp)
  225078:	10c00115 	stw	r3,4(r2)
  22507c:	00000e06 	br	2250b8 <altera_avalon_uart_txirq+0xf0>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
  225080:	e0bffc17 	ldw	r2,-16(fp)
  225084:	10800017 	ldw	r2,0(r2)
  225088:	10800204 	addi	r2,r2,8
  22508c:	10800037 	ldwio	r2,0(r2)
  225090:	e0bffd15 	stw	r2,-12(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
  225094:	e0bffd17 	ldw	r2,-12(fp)
  225098:	1082000c 	andi	r2,r2,2048
  22509c:	1000061e 	bne	r2,zero,2250b8 <altera_avalon_uart_txirq+0xf0>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
  2250a0:	e0bffc17 	ldw	r2,-16(fp)
  2250a4:	10c00117 	ldw	r3,4(r2)
  2250a8:	00bfefc4 	movi	r2,-65
  2250ac:	1886703a 	and	r3,r3,r2
  2250b0:	e0bffc17 	ldw	r2,-16(fp)
  2250b4:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
  2250b8:	e0bffc17 	ldw	r2,-16(fp)
  2250bc:	10c00417 	ldw	r3,16(r2)
  2250c0:	e0bffc17 	ldw	r2,-16(fp)
  2250c4:	10800517 	ldw	r2,20(r2)
  2250c8:	1880061e 	bne	r3,r2,2250e4 <altera_avalon_uart_txirq+0x11c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  2250cc:	e0bffc17 	ldw	r2,-16(fp)
  2250d0:	10c00117 	ldw	r3,4(r2)
  2250d4:	00beefc4 	movi	r2,-1089
  2250d8:	1886703a 	and	r3,r3,r2
  2250dc:	e0bffc17 	ldw	r2,-16(fp)
  2250e0:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  2250e4:	e0bffc17 	ldw	r2,-16(fp)
  2250e8:	10800017 	ldw	r2,0(r2)
  2250ec:	10800304 	addi	r2,r2,12
  2250f0:	e0fffc17 	ldw	r3,-16(fp)
  2250f4:	18c00117 	ldw	r3,4(r3)
  2250f8:	10c00035 	stwio	r3,0(r2)
}
  2250fc:	e037883a 	mov	sp,fp
  225100:	df000017 	ldw	fp,0(sp)
  225104:	dec00104 	addi	sp,sp,4
  225108:	f800283a 	ret

0022510c <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  22510c:	defffd04 	addi	sp,sp,-12
  225110:	df000215 	stw	fp,8(sp)
  225114:	df000204 	addi	fp,sp,8
  225118:	e13ffe15 	stw	r4,-8(fp)
  22511c:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
  225120:	00000506 	br	225138 <altera_avalon_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
  225124:	e0bfff17 	ldw	r2,-4(fp)
  225128:	1090000c 	andi	r2,r2,16384
  22512c:	10000226 	beq	r2,zero,225138 <altera_avalon_uart_close+0x2c>
      return -EWOULDBLOCK; 
  225130:	00bffd44 	movi	r2,-11
  225134:	00000606 	br	225150 <altera_avalon_uart_close+0x44>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
  225138:	e0bffe17 	ldw	r2,-8(fp)
  22513c:	10c00417 	ldw	r3,16(r2)
  225140:	e0bffe17 	ldw	r2,-8(fp)
  225144:	10800517 	ldw	r2,20(r2)
  225148:	18bff61e 	bne	r3,r2,225124 <__alt_data_end+0xffff18a4>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
  22514c:	0005883a 	mov	r2,zero
}
  225150:	e037883a 	mov	sp,fp
  225154:	df000017 	ldw	fp,0(sp)
  225158:	dec00104 	addi	sp,sp,4
  22515c:	f800283a 	ret

00225160 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  225160:	defffe04 	addi	sp,sp,-8
  225164:	dfc00115 	stw	ra,4(sp)
  225168:	df000015 	stw	fp,0(sp)
  22516c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  225170:	008008f4 	movhi	r2,35
  225174:	10a2dc04 	addi	r2,r2,-29840
  225178:	10800017 	ldw	r2,0(r2)
  22517c:	10000526 	beq	r2,zero,225194 <alt_get_errno+0x34>
  225180:	008008f4 	movhi	r2,35
  225184:	10a2dc04 	addi	r2,r2,-29840
  225188:	10800017 	ldw	r2,0(r2)
  22518c:	103ee83a 	callr	r2
  225190:	00000206 	br	22519c <alt_get_errno+0x3c>
  225194:	008008f4 	movhi	r2,35
  225198:	10a9ca04 	addi	r2,r2,-22744
}
  22519c:	e037883a 	mov	sp,fp
  2251a0:	dfc00117 	ldw	ra,4(sp)
  2251a4:	df000017 	ldw	fp,0(sp)
  2251a8:	dec00204 	addi	sp,sp,8
  2251ac:	f800283a 	ret

002251b0 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
  2251b0:	defff204 	addi	sp,sp,-56
  2251b4:	dfc00d15 	stw	ra,52(sp)
  2251b8:	df000c15 	stw	fp,48(sp)
  2251bc:	df000c04 	addi	fp,sp,48
  2251c0:	e13ffc15 	stw	r4,-16(fp)
  2251c4:	e17ffd15 	stw	r5,-12(fp)
  2251c8:	e1bffe15 	stw	r6,-8(fp)
  2251cc:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
  2251d0:	e03ff405 	stb	zero,-48(fp)
  int             count = 0;
  2251d4:	e03ff515 	stw	zero,-44(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
  2251d8:	e0bfff17 	ldw	r2,-4(fp)
  2251dc:	1090000c 	andi	r2,r2,16384
  2251e0:	1005003a 	cmpeq	r2,r2,zero
  2251e4:	10803fcc 	andi	r2,r2,255
  2251e8:	e0bff615 	stw	r2,-40(fp)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
  2251ec:	00001306 	br	22523c <altera_avalon_uart_read+0x8c>
    {
      count++;
  2251f0:	e0bff517 	ldw	r2,-44(fp)
  2251f4:	10800044 	addi	r2,r2,1
  2251f8:	e0bff515 	stw	r2,-44(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
  2251fc:	e0bffd17 	ldw	r2,-12(fp)
  225200:	10c00044 	addi	r3,r2,1
  225204:	e0fffd15 	stw	r3,-12(fp)
  225208:	e0fffc17 	ldw	r3,-16(fp)
  22520c:	18c00217 	ldw	r3,8(r3)
  225210:	e13ffc17 	ldw	r4,-16(fp)
  225214:	20c7883a 	add	r3,r4,r3
  225218:	18c00704 	addi	r3,r3,28
  22521c:	18c00003 	ldbu	r3,0(r3)
  225220:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
  225224:	e0bffc17 	ldw	r2,-16(fp)
  225228:	10800217 	ldw	r2,8(r2)
  22522c:	10800044 	addi	r2,r2,1
  225230:	10c00fcc 	andi	r3,r2,63
  225234:	e0bffc17 	ldw	r2,-16(fp)
  225238:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
  22523c:	e0fff517 	ldw	r3,-44(fp)
  225240:	e0bffe17 	ldw	r2,-8(fp)
  225244:	1880050e 	bge	r3,r2,22525c <altera_avalon_uart_read+0xac>
  225248:	e0bffc17 	ldw	r2,-16(fp)
  22524c:	10c00217 	ldw	r3,8(r2)
  225250:	e0bffc17 	ldw	r2,-16(fp)
  225254:	10800317 	ldw	r2,12(r2)
  225258:	18bfe51e 	bne	r3,r2,2251f0 <__alt_data_end+0xffff1970>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
  22525c:	e0bff517 	ldw	r2,-44(fp)
  225260:	1000251e 	bne	r2,zero,2252f8 <altera_avalon_uart_read+0x148>
  225264:	e0bffc17 	ldw	r2,-16(fp)
  225268:	10c00217 	ldw	r3,8(r2)
  22526c:	e0bffc17 	ldw	r2,-16(fp)
  225270:	10800317 	ldw	r2,12(r2)
  225274:	1880201e 	bne	r3,r2,2252f8 <altera_avalon_uart_read+0x148>
    {
      if (!block)
  225278:	e0bff617 	ldw	r2,-40(fp)
  22527c:	1000071e 	bne	r2,zero,22529c <altera_avalon_uart_read+0xec>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
  225280:	02251600 	call	225160 <alt_get_errno>
  225284:	1007883a 	mov	r3,r2
  225288:	008002c4 	movi	r2,11
  22528c:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
  225290:	00800044 	movi	r2,1
  225294:	e0bff405 	stb	r2,-48(fp)
        break;
  225298:	00001b06 	br	225308 <altera_avalon_uart_read+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  22529c:	0005303a 	rdctl	r2,status
  2252a0:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  2252a4:	e0fff817 	ldw	r3,-32(fp)
  2252a8:	00bfff84 	movi	r2,-2
  2252ac:	1884703a 	and	r2,r3,r2
  2252b0:	1001703a 	wrctl	status,r2
  
  return context;
  2252b4:	e0bff817 	ldw	r2,-32(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
  2252b8:	e0bff715 	stw	r2,-36(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  2252bc:	e0bffc17 	ldw	r2,-16(fp)
  2252c0:	10800117 	ldw	r2,4(r2)
  2252c4:	10c02014 	ori	r3,r2,128
  2252c8:	e0bffc17 	ldw	r2,-16(fp)
  2252cc:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  2252d0:	e0bffc17 	ldw	r2,-16(fp)
  2252d4:	10800017 	ldw	r2,0(r2)
  2252d8:	10800304 	addi	r2,r2,12
  2252dc:	e0fffc17 	ldw	r3,-16(fp)
  2252e0:	18c00117 	ldw	r3,4(r3)
  2252e4:	10c00035 	stwio	r3,0(r2)
  2252e8:	e0bff717 	ldw	r2,-36(fp)
  2252ec:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  2252f0:	e0bff917 	ldw	r2,-28(fp)
  2252f4:	1001703a 	wrctl	status,r2
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
  2252f8:	e0bff517 	ldw	r2,-44(fp)
  2252fc:	1000021e 	bne	r2,zero,225308 <altera_avalon_uart_read+0x158>
  225300:	e0bffe17 	ldw	r2,-8(fp)
  225304:	103fb91e 	bne	r2,zero,2251ec <__alt_data_end+0xffff196c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  225308:	0005303a 	rdctl	r2,status
  22530c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  225310:	e0fffa17 	ldw	r3,-24(fp)
  225314:	00bfff84 	movi	r2,-2
  225318:	1884703a 	and	r2,r3,r2
  22531c:	1001703a 	wrctl	status,r2
  
  return context;
  225320:	e0bffa17 	ldw	r2,-24(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
  225324:	e0bff715 	stw	r2,-36(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
  225328:	e0bffc17 	ldw	r2,-16(fp)
  22532c:	10800117 	ldw	r2,4(r2)
  225330:	10c02014 	ori	r3,r2,128
  225334:	e0bffc17 	ldw	r2,-16(fp)
  225338:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  22533c:	e0bffc17 	ldw	r2,-16(fp)
  225340:	10800017 	ldw	r2,0(r2)
  225344:	10800304 	addi	r2,r2,12
  225348:	e0fffc17 	ldw	r3,-16(fp)
  22534c:	18c00117 	ldw	r3,4(r3)
  225350:	10c00035 	stwio	r3,0(r2)
  225354:	e0bff717 	ldw	r2,-36(fp)
  225358:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  22535c:	e0bffb17 	ldw	r2,-20(fp)
  225360:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
  225364:	e0bff403 	ldbu	r2,-48(fp)
  225368:	10000226 	beq	r2,zero,225374 <altera_avalon_uart_read+0x1c4>
    return -EWOULDBLOCK;
  22536c:	00bffd44 	movi	r2,-11
  225370:	00000106 	br	225378 <altera_avalon_uart_read+0x1c8>
  }
  else {
    return count;
  225374:	e0bff517 	ldw	r2,-44(fp)
  }
}
  225378:	e037883a 	mov	sp,fp
  22537c:	dfc00117 	ldw	ra,4(sp)
  225380:	df000017 	ldw	fp,0(sp)
  225384:	dec00204 	addi	sp,sp,8
  225388:	f800283a 	ret

0022538c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  22538c:	defffe04 	addi	sp,sp,-8
  225390:	dfc00115 	stw	ra,4(sp)
  225394:	df000015 	stw	fp,0(sp)
  225398:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  22539c:	008008f4 	movhi	r2,35
  2253a0:	10a2dc04 	addi	r2,r2,-29840
  2253a4:	10800017 	ldw	r2,0(r2)
  2253a8:	10000526 	beq	r2,zero,2253c0 <alt_get_errno+0x34>
  2253ac:	008008f4 	movhi	r2,35
  2253b0:	10a2dc04 	addi	r2,r2,-29840
  2253b4:	10800017 	ldw	r2,0(r2)
  2253b8:	103ee83a 	callr	r2
  2253bc:	00000206 	br	2253c8 <alt_get_errno+0x3c>
  2253c0:	008008f4 	movhi	r2,35
  2253c4:	10a9ca04 	addi	r2,r2,-22744
}
  2253c8:	e037883a 	mov	sp,fp
  2253cc:	dfc00117 	ldw	ra,4(sp)
  2253d0:	df000017 	ldw	fp,0(sp)
  2253d4:	dec00204 	addi	sp,sp,8
  2253d8:	f800283a 	ret

002253dc <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
  2253dc:	defff204 	addi	sp,sp,-56
  2253e0:	dfc00d15 	stw	ra,52(sp)
  2253e4:	df000c15 	stw	fp,48(sp)
  2253e8:	df000c04 	addi	fp,sp,48
  2253ec:	e13ffc15 	stw	r4,-16(fp)
  2253f0:	e17ffd15 	stw	r5,-12(fp)
  2253f4:	e1bffe15 	stw	r6,-8(fp)
  2253f8:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
  2253fc:	e0bffe17 	ldw	r2,-8(fp)
  225400:	e0bff415 	stw	r2,-48(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
  225404:	e0bfff17 	ldw	r2,-4(fp)
  225408:	1090000c 	andi	r2,r2,16384
  22540c:	e0bff515 	stw	r2,-44(fp)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
  225410:	00003c06 	br	225504 <altera_avalon_uart_write+0x128>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
  225414:	e0bffc17 	ldw	r2,-16(fp)
  225418:	10800517 	ldw	r2,20(r2)
  22541c:	10800044 	addi	r2,r2,1
  225420:	10800fcc 	andi	r2,r2,63
  225424:	e0bff615 	stw	r2,-40(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
  225428:	e0bffc17 	ldw	r2,-16(fp)
  22542c:	10c00417 	ldw	r3,16(r2)
  225430:	e0bff617 	ldw	r2,-40(fp)
  225434:	1880221e 	bne	r3,r2,2254c0 <altera_avalon_uart_write+0xe4>
    {
      if (no_block)
  225438:	e0bff517 	ldw	r2,-44(fp)
  22543c:	10000526 	beq	r2,zero,225454 <altera_avalon_uart_write+0x78>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
  225440:	022538c0 	call	22538c <alt_get_errno>
  225444:	1007883a 	mov	r3,r2
  225448:	008002c4 	movi	r2,11
  22544c:	18800015 	stw	r2,0(r3)
        break;
  225450:	00002e06 	br	22550c <altera_avalon_uart_write+0x130>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  225454:	0005303a 	rdctl	r2,status
  225458:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  22545c:	e0fff817 	ldw	r3,-32(fp)
  225460:	00bfff84 	movi	r2,-2
  225464:	1884703a 	and	r2,r3,r2
  225468:	1001703a 	wrctl	status,r2
  
  return context;
  22546c:	e0bff817 	ldw	r2,-32(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
  225470:	e0bff715 	stw	r2,-36(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  225474:	e0bffc17 	ldw	r2,-16(fp)
  225478:	10800117 	ldw	r2,4(r2)
  22547c:	10c11014 	ori	r3,r2,1088
  225480:	e0bffc17 	ldw	r2,-16(fp)
  225484:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  225488:	e0bffc17 	ldw	r2,-16(fp)
  22548c:	10800017 	ldw	r2,0(r2)
  225490:	10800304 	addi	r2,r2,12
  225494:	e0fffc17 	ldw	r3,-16(fp)
  225498:	18c00117 	ldw	r3,4(r3)
  22549c:	10c00035 	stwio	r3,0(r2)
  2254a0:	e0bff717 	ldw	r2,-36(fp)
  2254a4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  2254a8:	e0bff917 	ldw	r2,-28(fp)
  2254ac:	1001703a 	wrctl	status,r2
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
  2254b0:	e0bffc17 	ldw	r2,-16(fp)
  2254b4:	10c00417 	ldw	r3,16(r2)
  2254b8:	e0bff617 	ldw	r2,-40(fp)
  2254bc:	18bffc26 	beq	r3,r2,2254b0 <__alt_data_end+0xffff1c30>
      }
    }

    count--;
  2254c0:	e0bff417 	ldw	r2,-48(fp)
  2254c4:	10bfffc4 	addi	r2,r2,-1
  2254c8:	e0bff415 	stw	r2,-48(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
  2254cc:	e0bffc17 	ldw	r2,-16(fp)
  2254d0:	10c00517 	ldw	r3,20(r2)
  2254d4:	e0bffd17 	ldw	r2,-12(fp)
  2254d8:	11000044 	addi	r4,r2,1
  2254dc:	e13ffd15 	stw	r4,-12(fp)
  2254e0:	10800003 	ldbu	r2,0(r2)
  2254e4:	1009883a 	mov	r4,r2
  2254e8:	e0bffc17 	ldw	r2,-16(fp)
  2254ec:	10c5883a 	add	r2,r2,r3
  2254f0:	10801704 	addi	r2,r2,92
  2254f4:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
  2254f8:	e0bffc17 	ldw	r2,-16(fp)
  2254fc:	e0fff617 	ldw	r3,-40(fp)
  225500:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
  225504:	e0bff417 	ldw	r2,-48(fp)
  225508:	103fc21e 	bne	r2,zero,225414 <__alt_data_end+0xffff1b94>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  22550c:	0005303a 	rdctl	r2,status
  225510:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  225514:	e0fffa17 	ldw	r3,-24(fp)
  225518:	00bfff84 	movi	r2,-2
  22551c:	1884703a 	and	r2,r3,r2
  225520:	1001703a 	wrctl	status,r2
  
  return context;
  225524:	e0bffa17 	ldw	r2,-24(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
  225528:	e0bff715 	stw	r2,-36(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
  22552c:	e0bffc17 	ldw	r2,-16(fp)
  225530:	10800117 	ldw	r2,4(r2)
  225534:	10c11014 	ori	r3,r2,1088
  225538:	e0bffc17 	ldw	r2,-16(fp)
  22553c:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
  225540:	e0bffc17 	ldw	r2,-16(fp)
  225544:	10800017 	ldw	r2,0(r2)
  225548:	10800304 	addi	r2,r2,12
  22554c:	e0fffc17 	ldw	r3,-16(fp)
  225550:	18c00117 	ldw	r3,4(r3)
  225554:	10c00035 	stwio	r3,0(r2)
  225558:	e0bff717 	ldw	r2,-36(fp)
  22555c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  225560:	e0bffb17 	ldw	r2,-20(fp)
  225564:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
  225568:	e0fffe17 	ldw	r3,-8(fp)
  22556c:	e0bff417 	ldw	r2,-48(fp)
  225570:	1885c83a 	sub	r2,r3,r2
}
  225574:	e037883a 	mov	sp,fp
  225578:	dfc00117 	ldw	ra,4(sp)
  22557c:	df000017 	ldw	fp,0(sp)
  225580:	dec00204 	addi	sp,sp,8
  225584:	f800283a 	ret

00225588 <alt_up_char_buffer_init>:
#include <priv/alt_file.h>

#include "altera_up_avalon_video_character_buffer_with_dma.h"
#include "altera_up_avalon_video_character_buffer_with_dma_regs.h"

void alt_up_char_buffer_init(alt_up_char_buffer_dev *char_buffer) {
  225588:	defffc04 	addi	sp,sp,-16
  22558c:	dfc00315 	stw	ra,12(sp)
  225590:	df000215 	stw	fp,8(sp)
  225594:	df000204 	addi	fp,sp,8
  225598:	e13fff15 	stw	r4,-4(fp)
	char * name;
	name = (char *) char_buffer->dev.name;
  22559c:	e0bfff17 	ldw	r2,-4(fp)
  2255a0:	10800217 	ldw	r2,8(r2)
  2255a4:	e0bffe15 	stw	r2,-8(fp)

	for ( ; (*name) != '\0'; name++) {
  2255a8:	00000b06 	br	2255d8 <alt_up_char_buffer_init+0x50>
		if (strcmp(name, "_avalon_char_buffer_slave") == 0) {
  2255ac:	e13ffe17 	ldw	r4,-8(fp)
  2255b0:	014008b4 	movhi	r5,34
  2255b4:	295bf804 	addi	r5,r5,28640
  2255b8:	02269b80 	call	2269b8 <strcmp>
  2255bc:	1000031e 	bne	r2,zero,2255cc <alt_up_char_buffer_init+0x44>
			(*name) = '\0';
  2255c0:	e0bffe17 	ldw	r2,-8(fp)
  2255c4:	10000005 	stb	zero,0(r2)
			break;
  2255c8:	00000906 	br	2255f0 <alt_up_char_buffer_init+0x68>

void alt_up_char_buffer_init(alt_up_char_buffer_dev *char_buffer) {
	char * name;
	name = (char *) char_buffer->dev.name;

	for ( ; (*name) != '\0'; name++) {
  2255cc:	e0bffe17 	ldw	r2,-8(fp)
  2255d0:	10800044 	addi	r2,r2,1
  2255d4:	e0bffe15 	stw	r2,-8(fp)
  2255d8:	e0bffe17 	ldw	r2,-8(fp)
  2255dc:	10800003 	ldbu	r2,0(r2)
  2255e0:	10803fcc 	andi	r2,r2,255
  2255e4:	1080201c 	xori	r2,r2,128
  2255e8:	10bfe004 	addi	r2,r2,-128
  2255ec:	103fef1e 	bne	r2,zero,2255ac <__alt_data_end+0xffff1d2c>
			(*name) = '\0';
			break;
		}
	}
	
	return;
  2255f0:	0001883a 	nop
}
  2255f4:	e037883a 	mov	sp,fp
  2255f8:	dfc00117 	ldw	ra,4(sp)
  2255fc:	df000017 	ldw	fp,0(sp)
  225600:	dec00204 	addi	sp,sp,8
  225604:	f800283a 	ret

00225608 <alt_up_char_buffer_open_dev>:

alt_up_char_buffer_dev* alt_up_char_buffer_open_dev(const char* name) {
  225608:	defffc04 	addi	sp,sp,-16
  22560c:	dfc00315 	stw	ra,12(sp)
  225610:	df000215 	stw	fp,8(sp)
  225614:	df000204 	addi	fp,sp,8
  225618:	e13fff15 	stw	r4,-4(fp)
  // find the device from the device list 
  // (see altera_hal/HAL/inc/priv/alt_file.h 
  // and altera_hal/HAL/src/alt_find_dev.c 
  // for details)
  alt_up_char_buffer_dev *dev = (alt_up_char_buffer_dev *)alt_find_dev(name, &alt_dev_list);
  22561c:	e13fff17 	ldw	r4,-4(fp)
  225620:	014008f4 	movhi	r5,35
  225624:	2962d904 	addi	r5,r5,-29852
  225628:	0225ba00 	call	225ba0 <alt_find_dev>
  22562c:	e0bffe15 	stw	r2,-8(fp)

  return dev;
  225630:	e0bffe17 	ldw	r2,-8(fp)
}
  225634:	e037883a 	mov	sp,fp
  225638:	dfc00117 	ldw	ra,4(sp)
  22563c:	df000017 	ldw	fp,0(sp)
  225640:	dec00204 	addi	sp,sp,8
  225644:	f800283a 	ret

00225648 <alt_up_char_buffer_draw>:

int alt_up_char_buffer_draw(alt_up_char_buffer_dev *char_buffer, unsigned char ch, 
	unsigned int x, unsigned int y) {
  225648:	defffa04 	addi	sp,sp,-24
  22564c:	df000515 	stw	fp,20(sp)
  225650:	df000504 	addi	fp,sp,20
  225654:	e13ffc15 	stw	r4,-16(fp)
  225658:	2805883a 	mov	r2,r5
  22565c:	e1bffe15 	stw	r6,-8(fp)
  225660:	e1ffff15 	stw	r7,-4(fp)
  225664:	e0bffd05 	stb	r2,-12(fp)
	// boundary check
	if (x >= char_buffer->x_resolution || y >= char_buffer->y_resolution )
  225668:	e0bffc17 	ldw	r2,-16(fp)
  22566c:	10800c17 	ldw	r2,48(r2)
  225670:	e0fffe17 	ldw	r3,-8(fp)
  225674:	1880042e 	bgeu	r3,r2,225688 <alt_up_char_buffer_draw+0x40>
  225678:	e0bffc17 	ldw	r2,-16(fp)
  22567c:	10800d17 	ldw	r2,52(r2)
  225680:	e0ffff17 	ldw	r3,-4(fp)
  225684:	18800236 	bltu	r3,r2,225690 <alt_up_char_buffer_draw+0x48>
		return -1;
  225688:	00bfffc4 	movi	r2,-1
  22568c:	00001d06 	br	225704 <alt_up_char_buffer_draw+0xbc>
	
	unsigned int addr = 0;
  225690:	e03ffb15 	stw	zero,-20(fp)
	addr |= ((x & char_buffer->x_coord_mask) << char_buffer->x_coord_offset);
  225694:	e0bffc17 	ldw	r2,-16(fp)
  225698:	10c00f17 	ldw	r3,60(r2)
  22569c:	e0bffe17 	ldw	r2,-8(fp)
  2256a0:	1884703a 	and	r2,r3,r2
  2256a4:	e0fffc17 	ldw	r3,-16(fp)
  2256a8:	18c00e17 	ldw	r3,56(r3)
  2256ac:	10c4983a 	sll	r2,r2,r3
  2256b0:	e0fffb17 	ldw	r3,-20(fp)
  2256b4:	1884b03a 	or	r2,r3,r2
  2256b8:	e0bffb15 	stw	r2,-20(fp)
	addr |= ((y & char_buffer->y_coord_mask) << char_buffer->y_coord_offset);
  2256bc:	e0bffc17 	ldw	r2,-16(fp)
  2256c0:	10c01117 	ldw	r3,68(r2)
  2256c4:	e0bfff17 	ldw	r2,-4(fp)
  2256c8:	1884703a 	and	r2,r3,r2
  2256cc:	e0fffc17 	ldw	r3,-16(fp)
  2256d0:	18c01017 	ldw	r3,64(r3)
  2256d4:	10c4983a 	sll	r2,r2,r3
  2256d8:	e0fffb17 	ldw	r3,-20(fp)
  2256dc:	1884b03a 	or	r2,r3,r2
  2256e0:	e0bffb15 	stw	r2,-20(fp)
	IOWR_8DIRECT(char_buffer->buffer_base, addr, ch);
  2256e4:	e0bffc17 	ldw	r2,-16(fp)
  2256e8:	10c00b17 	ldw	r3,44(r2)
  2256ec:	e0bffb17 	ldw	r2,-20(fp)
  2256f0:	1885883a 	add	r2,r3,r2
  2256f4:	1007883a 	mov	r3,r2
  2256f8:	e0bffd03 	ldbu	r2,-12(fp)
  2256fc:	18800025 	stbio	r2,0(r3)

	return 0;
  225700:	0005883a 	mov	r2,zero
}
  225704:	e037883a 	mov	sp,fp
  225708:	df000017 	ldw	fp,0(sp)
  22570c:	dec00104 	addi	sp,sp,4
  225710:	f800283a 	ret

00225714 <alt_up_char_buffer_string>:

int alt_up_char_buffer_string(alt_up_char_buffer_dev *char_buffer, const char *ptr, 
	unsigned int x, unsigned int y) {
  225714:	defffa04 	addi	sp,sp,-24
  225718:	df000515 	stw	fp,20(sp)
  22571c:	df000504 	addi	fp,sp,20
  225720:	e13ffc15 	stw	r4,-16(fp)
  225724:	e17ffd15 	stw	r5,-12(fp)
  225728:	e1bffe15 	stw	r6,-8(fp)
  22572c:	e1ffff15 	stw	r7,-4(fp)
	// boundary check
	if (x >= char_buffer->x_resolution || y >= char_buffer->y_resolution )
  225730:	e0bffc17 	ldw	r2,-16(fp)
  225734:	10800c17 	ldw	r2,48(r2)
  225738:	e0fffe17 	ldw	r3,-8(fp)
  22573c:	1880042e 	bgeu	r3,r2,225750 <alt_up_char_buffer_string+0x3c>
  225740:	e0bffc17 	ldw	r2,-16(fp)
  225744:	10800d17 	ldw	r2,52(r2)
  225748:	e0ffff17 	ldw	r3,-4(fp)
  22574c:	18800236 	bltu	r3,r2,225758 <alt_up_char_buffer_string+0x44>
		return -1;
  225750:	00bfffc4 	movi	r2,-1
  225754:	00002b06 	br	225804 <alt_up_char_buffer_string+0xf0>
	
	unsigned int offset = 0;
  225758:	e03ffb15 	stw	zero,-20(fp)
	offset = (y << char_buffer->y_coord_offset) + x;
  22575c:	e0bffc17 	ldw	r2,-16(fp)
  225760:	10801017 	ldw	r2,64(r2)
  225764:	1007883a 	mov	r3,r2
  225768:	e0bfff17 	ldw	r2,-4(fp)
  22576c:	10c6983a 	sll	r3,r2,r3
  225770:	e0bffe17 	ldw	r2,-8(fp)
  225774:	1885883a 	add	r2,r3,r2
  225778:	e0bffb15 	stw	r2,-20(fp)

	while ( *ptr )
  22577c:	00001a06 	br	2257e8 <alt_up_char_buffer_string+0xd4>
	{
		IOWR_8DIRECT(char_buffer->buffer_base, offset, *ptr);
  225780:	e0bffc17 	ldw	r2,-16(fp)
  225784:	10c00b17 	ldw	r3,44(r2)
  225788:	e0bffb17 	ldw	r2,-20(fp)
  22578c:	1885883a 	add	r2,r3,r2
  225790:	1007883a 	mov	r3,r2
  225794:	e0bffd17 	ldw	r2,-12(fp)
  225798:	10800003 	ldbu	r2,0(r2)
  22579c:	10803fcc 	andi	r2,r2,255
  2257a0:	1080201c 	xori	r2,r2,128
  2257a4:	10bfe004 	addi	r2,r2,-128
  2257a8:	18800025 	stbio	r2,0(r3)
		++ptr;
  2257ac:	e0bffd17 	ldw	r2,-12(fp)
  2257b0:	10800044 	addi	r2,r2,1
  2257b4:	e0bffd15 	stw	r2,-12(fp)
		if (++x >= char_buffer->x_resolution)
  2257b8:	e0bffe17 	ldw	r2,-8(fp)
  2257bc:	10800044 	addi	r2,r2,1
  2257c0:	e0bffe15 	stw	r2,-8(fp)
  2257c4:	e0bffc17 	ldw	r2,-16(fp)
  2257c8:	10800c17 	ldw	r2,48(r2)
  2257cc:	e0fffe17 	ldw	r3,-8(fp)
  2257d0:	18800236 	bltu	r3,r2,2257dc <alt_up_char_buffer_string+0xc8>
			return -1;
  2257d4:	00bfffc4 	movi	r2,-1
  2257d8:	00000a06 	br	225804 <alt_up_char_buffer_string+0xf0>
		++offset;
  2257dc:	e0bffb17 	ldw	r2,-20(fp)
  2257e0:	10800044 	addi	r2,r2,1
  2257e4:	e0bffb15 	stw	r2,-20(fp)
		return -1;
	
	unsigned int offset = 0;
	offset = (y << char_buffer->y_coord_offset) + x;

	while ( *ptr )
  2257e8:	e0bffd17 	ldw	r2,-12(fp)
  2257ec:	10800003 	ldbu	r2,0(r2)
  2257f0:	10803fcc 	andi	r2,r2,255
  2257f4:	1080201c 	xori	r2,r2,128
  2257f8:	10bfe004 	addi	r2,r2,-128
  2257fc:	103fe01e 	bne	r2,zero,225780 <__alt_data_end+0xffff1f00>
		++ptr;
		if (++x >= char_buffer->x_resolution)
			return -1;
		++offset;
	}
	return 0;
  225800:	0005883a 	mov	r2,zero
}
  225804:	e037883a 	mov	sp,fp
  225808:	df000017 	ldw	fp,0(sp)
  22580c:	dec00104 	addi	sp,sp,4
  225810:	f800283a 	ret

00225814 <alt_up_char_buffer_clear>:

int alt_up_char_buffer_clear(alt_up_char_buffer_dev *char_buffer) {
  225814:	defffe04 	addi	sp,sp,-8
  225818:	df000115 	stw	fp,4(sp)
  22581c:	df000104 	addi	fp,sp,4
  225820:	e13fff15 	stw	r4,-4(fp)
	IOWR_ALT_UP_CHAR_BUFFER_CLR_SCRN(char_buffer->ctrl_reg_base, 1);
  225824:	e0bfff17 	ldw	r2,-4(fp)
  225828:	10800a17 	ldw	r2,40(r2)
  22582c:	10800084 	addi	r2,r2,2
  225830:	1007883a 	mov	r3,r2
  225834:	00800044 	movi	r2,1
  225838:	18800025 	stbio	r2,0(r3)
	while ((IORD_ALT_UP_CHAR_BUFFER_CLR_SCRN(char_buffer->ctrl_reg_base) & ALT_UP_CHAR_BUFFER_CLR_SCRN_MSK) >> ALT_UP_CHAR_BUFFER_CLR_SCRN_OFST);
  22583c:	0001883a 	nop
  225840:	e0bfff17 	ldw	r2,-4(fp)
  225844:	10800a17 	ldw	r2,40(r2)
  225848:	10800084 	addi	r2,r2,2
  22584c:	10800023 	ldbuio	r2,0(r2)
  225850:	10803fcc 	andi	r2,r2,255
  225854:	1080004c 	andi	r2,r2,1
  225858:	103ff91e 	bne	r2,zero,225840 <__alt_data_end+0xffff1fc0>
	return 0;
  22585c:	0005883a 	mov	r2,zero
}
  225860:	e037883a 	mov	sp,fp
  225864:	df000017 	ldw	fp,0(sp)
  225868:	dec00104 	addi	sp,sp,4
  22586c:	f800283a 	ret

00225870 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
  225870:	defff504 	addi	sp,sp,-44
  225874:	df000a15 	stw	fp,40(sp)
  225878:	df000a04 	addi	fp,sp,40
  22587c:	e13ffc15 	stw	r4,-16(fp)
  225880:	e17ffd15 	stw	r5,-12(fp)
  225884:	e1bffe15 	stw	r6,-8(fp)
  225888:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
  22588c:	e03ff615 	stw	zero,-40(fp)
  225890:	008008f4 	movhi	r2,35
  225894:	10a9cf04 	addi	r2,r2,-22724
  225898:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
  22589c:	10003f26 	beq	r2,zero,22599c <alt_alarm_start+0x12c>
  {
    if (alarm)
  2258a0:	e0bffc17 	ldw	r2,-16(fp)
  2258a4:	10003b26 	beq	r2,zero,225994 <alt_alarm_start+0x124>
    {
      alarm->callback = callback;
  2258a8:	e0bffc17 	ldw	r2,-16(fp)
  2258ac:	e0fffe17 	ldw	r3,-8(fp)
  2258b0:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
  2258b4:	e0bffc17 	ldw	r2,-16(fp)
  2258b8:	e0ffff17 	ldw	r3,-4(fp)
  2258bc:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  2258c0:	0005303a 	rdctl	r2,status
  2258c4:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  2258c8:	e0fff817 	ldw	r3,-32(fp)
  2258cc:	00bfff84 	movi	r2,-2
  2258d0:	1884703a 	and	r2,r3,r2
  2258d4:	1001703a 	wrctl	status,r2
  
  return context;
  2258d8:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
  2258dc:	e0bff715 	stw	r2,-36(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
  2258e0:	008008f4 	movhi	r2,35
  2258e4:	10a9d004 	addi	r2,r2,-22720
  2258e8:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
  2258ec:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
  2258f0:	e0fffd17 	ldw	r3,-12(fp)
  2258f4:	e0bff617 	ldw	r2,-40(fp)
  2258f8:	1885883a 	add	r2,r3,r2
  2258fc:	10c00044 	addi	r3,r2,1
  225900:	e0bffc17 	ldw	r2,-16(fp)
  225904:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
  225908:	e0bffc17 	ldw	r2,-16(fp)
  22590c:	10c00217 	ldw	r3,8(r2)
  225910:	e0bff617 	ldw	r2,-40(fp)
  225914:	1880042e 	bgeu	r3,r2,225928 <alt_alarm_start+0xb8>
      {
        alarm->rollover = 1;
  225918:	e0bffc17 	ldw	r2,-16(fp)
  22591c:	00c00044 	movi	r3,1
  225920:	10c00405 	stb	r3,16(r2)
  225924:	00000206 	br	225930 <alt_alarm_start+0xc0>
      }
      else
      {
        alarm->rollover = 0;
  225928:	e0bffc17 	ldw	r2,-16(fp)
  22592c:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
  225930:	e0fffc17 	ldw	r3,-16(fp)
  225934:	008008f4 	movhi	r2,35
  225938:	10a2e104 	addi	r2,r2,-29820
  22593c:	e0bff915 	stw	r2,-28(fp)
  225940:	e0fffa15 	stw	r3,-24(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  225944:	e0bffa17 	ldw	r2,-24(fp)
  225948:	e0fff917 	ldw	r3,-28(fp)
  22594c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  225950:	e0bff917 	ldw	r2,-28(fp)
  225954:	10c00017 	ldw	r3,0(r2)
  225958:	e0bffa17 	ldw	r2,-24(fp)
  22595c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  225960:	e0bff917 	ldw	r2,-28(fp)
  225964:	10800017 	ldw	r2,0(r2)
  225968:	e0fffa17 	ldw	r3,-24(fp)
  22596c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  225970:	e0bff917 	ldw	r2,-28(fp)
  225974:	e0fffa17 	ldw	r3,-24(fp)
  225978:	10c00015 	stw	r3,0(r2)
  22597c:	e0bff717 	ldw	r2,-36(fp)
  225980:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  225984:	e0bffb17 	ldw	r2,-20(fp)
  225988:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
  22598c:	0005883a 	mov	r2,zero
  225990:	00000306 	br	2259a0 <alt_alarm_start+0x130>
    }
    else
    {
      return -EINVAL;
  225994:	00bffa84 	movi	r2,-22
  225998:	00000106 	br	2259a0 <alt_alarm_start+0x130>
    }
  }
  else
  {
    return -ENOTSUP;
  22599c:	00bfde84 	movi	r2,-134
  }
}
  2259a0:	e037883a 	mov	sp,fp
  2259a4:	df000017 	ldw	fp,0(sp)
  2259a8:	dec00104 	addi	sp,sp,4
  2259ac:	f800283a 	ret

002259b0 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
  2259b0:	defffe04 	addi	sp,sp,-8
  2259b4:	df000115 	stw	fp,4(sp)
  2259b8:	df000104 	addi	fp,sp,4
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  2259bc:	e03fff15 	stw	zero,-4(fp)
  2259c0:	00000506 	br	2259d8 <alt_dcache_flush_all+0x28>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  2259c4:	e0bfff17 	ldw	r2,-4(fp)
  2259c8:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  2259cc:	e0bfff17 	ldw	r2,-4(fp)
  2259d0:	10800804 	addi	r2,r2,32
  2259d4:	e0bfff15 	stw	r2,-4(fp)
  2259d8:	e0bfff17 	ldw	r2,-4(fp)
  2259dc:	10820030 	cmpltui	r2,r2,2048
  2259e0:	103ff81e 	bne	r2,zero,2259c4 <__alt_data_end+0xffff2144>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
  2259e4:	e037883a 	mov	sp,fp
  2259e8:	df000017 	ldw	fp,0(sp)
  2259ec:	dec00104 	addi	sp,sp,4
  2259f0:	f800283a 	ret

002259f4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  2259f4:	defffe04 	addi	sp,sp,-8
  2259f8:	dfc00115 	stw	ra,4(sp)
  2259fc:	df000015 	stw	fp,0(sp)
  225a00:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  225a04:	008008f4 	movhi	r2,35
  225a08:	10a2dc04 	addi	r2,r2,-29840
  225a0c:	10800017 	ldw	r2,0(r2)
  225a10:	10000526 	beq	r2,zero,225a28 <alt_get_errno+0x34>
  225a14:	008008f4 	movhi	r2,35
  225a18:	10a2dc04 	addi	r2,r2,-29840
  225a1c:	10800017 	ldw	r2,0(r2)
  225a20:	103ee83a 	callr	r2
  225a24:	00000206 	br	225a30 <alt_get_errno+0x3c>
  225a28:	008008f4 	movhi	r2,35
  225a2c:	10a9ca04 	addi	r2,r2,-22744
}
  225a30:	e037883a 	mov	sp,fp
  225a34:	dfc00117 	ldw	ra,4(sp)
  225a38:	df000017 	ldw	fp,0(sp)
  225a3c:	dec00204 	addi	sp,sp,8
  225a40:	f800283a 	ret

00225a44 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
  225a44:	defffa04 	addi	sp,sp,-24
  225a48:	dfc00515 	stw	ra,20(sp)
  225a4c:	df000415 	stw	fp,16(sp)
  225a50:	df000404 	addi	fp,sp,16
  225a54:	e13ffe15 	stw	r4,-8(fp)
  225a58:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  225a5c:	e0bffe17 	ldw	r2,-8(fp)
  225a60:	10000326 	beq	r2,zero,225a70 <alt_dev_llist_insert+0x2c>
  225a64:	e0bffe17 	ldw	r2,-8(fp)
  225a68:	10800217 	ldw	r2,8(r2)
  225a6c:	1000061e 	bne	r2,zero,225a88 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
  225a70:	02259f40 	call	2259f4 <alt_get_errno>
  225a74:	1007883a 	mov	r3,r2
  225a78:	00800584 	movi	r2,22
  225a7c:	18800015 	stw	r2,0(r3)
    return -EINVAL;
  225a80:	00bffa84 	movi	r2,-22
  225a84:	00001306 	br	225ad4 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
  225a88:	e0bffe17 	ldw	r2,-8(fp)
  225a8c:	e0ffff17 	ldw	r3,-4(fp)
  225a90:	e0fffc15 	stw	r3,-16(fp)
  225a94:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  225a98:	e0bffd17 	ldw	r2,-12(fp)
  225a9c:	e0fffc17 	ldw	r3,-16(fp)
  225aa0:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
  225aa4:	e0bffc17 	ldw	r2,-16(fp)
  225aa8:	10c00017 	ldw	r3,0(r2)
  225aac:	e0bffd17 	ldw	r2,-12(fp)
  225ab0:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
  225ab4:	e0bffc17 	ldw	r2,-16(fp)
  225ab8:	10800017 	ldw	r2,0(r2)
  225abc:	e0fffd17 	ldw	r3,-12(fp)
  225ac0:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
  225ac4:	e0bffc17 	ldw	r2,-16(fp)
  225ac8:	e0fffd17 	ldw	r3,-12(fp)
  225acc:	10c00015 	stw	r3,0(r2)

  return 0;  
  225ad0:	0005883a 	mov	r2,zero
}
  225ad4:	e037883a 	mov	sp,fp
  225ad8:	dfc00117 	ldw	ra,4(sp)
  225adc:	df000017 	ldw	fp,0(sp)
  225ae0:	dec00204 	addi	sp,sp,8
  225ae4:	f800283a 	ret

00225ae8 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
  225ae8:	defffd04 	addi	sp,sp,-12
  225aec:	dfc00215 	stw	ra,8(sp)
  225af0:	df000115 	stw	fp,4(sp)
  225af4:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  225af8:	008008b4 	movhi	r2,34
  225afc:	109ba904 	addi	r2,r2,28324
  225b00:	e0bfff15 	stw	r2,-4(fp)
  225b04:	00000606 	br	225b20 <_do_ctors+0x38>
        (*ctor) (); 
  225b08:	e0bfff17 	ldw	r2,-4(fp)
  225b0c:	10800017 	ldw	r2,0(r2)
  225b10:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
  225b14:	e0bfff17 	ldw	r2,-4(fp)
  225b18:	10bfff04 	addi	r2,r2,-4
  225b1c:	e0bfff15 	stw	r2,-4(fp)
  225b20:	e0ffff17 	ldw	r3,-4(fp)
  225b24:	008008b4 	movhi	r2,34
  225b28:	109baa04 	addi	r2,r2,28328
  225b2c:	18bff62e 	bgeu	r3,r2,225b08 <__alt_data_end+0xffff2288>
        (*ctor) (); 
}
  225b30:	e037883a 	mov	sp,fp
  225b34:	dfc00117 	ldw	ra,4(sp)
  225b38:	df000017 	ldw	fp,0(sp)
  225b3c:	dec00204 	addi	sp,sp,8
  225b40:	f800283a 	ret

00225b44 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
  225b44:	defffd04 	addi	sp,sp,-12
  225b48:	dfc00215 	stw	ra,8(sp)
  225b4c:	df000115 	stw	fp,4(sp)
  225b50:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  225b54:	008008b4 	movhi	r2,34
  225b58:	109ba904 	addi	r2,r2,28324
  225b5c:	e0bfff15 	stw	r2,-4(fp)
  225b60:	00000606 	br	225b7c <_do_dtors+0x38>
        (*dtor) (); 
  225b64:	e0bfff17 	ldw	r2,-4(fp)
  225b68:	10800017 	ldw	r2,0(r2)
  225b6c:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
  225b70:	e0bfff17 	ldw	r2,-4(fp)
  225b74:	10bfff04 	addi	r2,r2,-4
  225b78:	e0bfff15 	stw	r2,-4(fp)
  225b7c:	e0ffff17 	ldw	r3,-4(fp)
  225b80:	008008b4 	movhi	r2,34
  225b84:	109baa04 	addi	r2,r2,28328
  225b88:	18bff62e 	bgeu	r3,r2,225b64 <__alt_data_end+0xffff22e4>
        (*dtor) (); 
}
  225b8c:	e037883a 	mov	sp,fp
  225b90:	dfc00117 	ldw	ra,4(sp)
  225b94:	df000017 	ldw	fp,0(sp)
  225b98:	dec00204 	addi	sp,sp,8
  225b9c:	f800283a 	ret

00225ba0 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
  225ba0:	defffa04 	addi	sp,sp,-24
  225ba4:	dfc00515 	stw	ra,20(sp)
  225ba8:	df000415 	stw	fp,16(sp)
  225bac:	df000404 	addi	fp,sp,16
  225bb0:	e13ffe15 	stw	r4,-8(fp)
  225bb4:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
  225bb8:	e0bfff17 	ldw	r2,-4(fp)
  225bbc:	10800017 	ldw	r2,0(r2)
  225bc0:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
  225bc4:	e13ffe17 	ldw	r4,-8(fp)
  225bc8:	02206d40 	call	2206d4 <strlen>
  225bcc:	10800044 	addi	r2,r2,1
  225bd0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  225bd4:	00000d06 	br	225c0c <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
  225bd8:	e0bffc17 	ldw	r2,-16(fp)
  225bdc:	10c00217 	ldw	r3,8(r2)
  225be0:	e0bffd17 	ldw	r2,-12(fp)
  225be4:	1809883a 	mov	r4,r3
  225be8:	e17ffe17 	ldw	r5,-8(fp)
  225bec:	100d883a 	mov	r6,r2
  225bf0:	02267d40 	call	2267d4 <memcmp>
  225bf4:	1000021e 	bne	r2,zero,225c00 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
  225bf8:	e0bffc17 	ldw	r2,-16(fp)
  225bfc:	00000706 	br	225c1c <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
  225c00:	e0bffc17 	ldw	r2,-16(fp)
  225c04:	10800017 	ldw	r2,0(r2)
  225c08:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
  225c0c:	e0fffc17 	ldw	r3,-16(fp)
  225c10:	e0bfff17 	ldw	r2,-4(fp)
  225c14:	18bff01e 	bne	r3,r2,225bd8 <__alt_data_end+0xffff2358>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
  225c18:	0005883a 	mov	r2,zero
}
  225c1c:	e037883a 	mov	sp,fp
  225c20:	dfc00117 	ldw	ra,4(sp)
  225c24:	df000017 	ldw	fp,0(sp)
  225c28:	dec00204 	addi	sp,sp,8
  225c2c:	f800283a 	ret

00225c30 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
  225c30:	defffe04 	addi	sp,sp,-8
  225c34:	dfc00115 	stw	ra,4(sp)
  225c38:	df000015 	stw	fp,0(sp)
  225c3c:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
  225c40:	0009883a 	mov	r4,zero
  225c44:	01440004 	movi	r5,4096
  225c48:	02266600 	call	226660 <alt_icache_flush>
#endif
}
  225c4c:	e037883a 	mov	sp,fp
  225c50:	dfc00117 	ldw	ra,4(sp)
  225c54:	df000017 	ldw	fp,0(sp)
  225c58:	dec00204 	addi	sp,sp,8
  225c5c:	f800283a 	ret

00225c60 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  225c60:	defff904 	addi	sp,sp,-28
  225c64:	dfc00615 	stw	ra,24(sp)
  225c68:	df000515 	stw	fp,20(sp)
  225c6c:	df000504 	addi	fp,sp,20
  225c70:	e13ffc15 	stw	r4,-16(fp)
  225c74:	e17ffd15 	stw	r5,-12(fp)
  225c78:	e1bffe15 	stw	r6,-8(fp)
  225c7c:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
  225c80:	e0800217 	ldw	r2,8(fp)
  225c84:	d8800015 	stw	r2,0(sp)
  225c88:	e13ffc17 	ldw	r4,-16(fp)
  225c8c:	e17ffd17 	ldw	r5,-12(fp)
  225c90:	e1bffe17 	ldw	r6,-8(fp)
  225c94:	e1ffff17 	ldw	r7,-4(fp)
  225c98:	0225e400 	call	225e40 <alt_iic_isr_register>
}  
  225c9c:	e037883a 	mov	sp,fp
  225ca0:	dfc00117 	ldw	ra,4(sp)
  225ca4:	df000017 	ldw	fp,0(sp)
  225ca8:	dec00204 	addi	sp,sp,8
  225cac:	f800283a 	ret

00225cb0 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
  225cb0:	defff904 	addi	sp,sp,-28
  225cb4:	df000615 	stw	fp,24(sp)
  225cb8:	df000604 	addi	fp,sp,24
  225cbc:	e13ffe15 	stw	r4,-8(fp)
  225cc0:	e17fff15 	stw	r5,-4(fp)
  225cc4:	e0bfff17 	ldw	r2,-4(fp)
  225cc8:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  225ccc:	0005303a 	rdctl	r2,status
  225cd0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  225cd4:	e0fffb17 	ldw	r3,-20(fp)
  225cd8:	00bfff84 	movi	r2,-2
  225cdc:	1884703a 	and	r2,r3,r2
  225ce0:	1001703a 	wrctl	status,r2
  
  return context;
  225ce4:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  225ce8:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
  225cec:	e0bffa17 	ldw	r2,-24(fp)
  225cf0:	00c00044 	movi	r3,1
  225cf4:	1884983a 	sll	r2,r3,r2
  225cf8:	1007883a 	mov	r3,r2
  225cfc:	008008f4 	movhi	r2,35
  225d00:	10a9ce04 	addi	r2,r2,-22728
  225d04:	10800017 	ldw	r2,0(r2)
  225d08:	1886b03a 	or	r3,r3,r2
  225d0c:	008008f4 	movhi	r2,35
  225d10:	10a9ce04 	addi	r2,r2,-22728
  225d14:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  225d18:	008008f4 	movhi	r2,35
  225d1c:	10a9ce04 	addi	r2,r2,-22728
  225d20:	10800017 	ldw	r2,0(r2)
  225d24:	100170fa 	wrctl	ienable,r2
  225d28:	e0bffc17 	ldw	r2,-16(fp)
  225d2c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  225d30:	e0bffd17 	ldw	r2,-12(fp)
  225d34:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  225d38:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
  225d3c:	0001883a 	nop
}
  225d40:	e037883a 	mov	sp,fp
  225d44:	df000017 	ldw	fp,0(sp)
  225d48:	dec00104 	addi	sp,sp,4
  225d4c:	f800283a 	ret

00225d50 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
  225d50:	defff904 	addi	sp,sp,-28
  225d54:	df000615 	stw	fp,24(sp)
  225d58:	df000604 	addi	fp,sp,24
  225d5c:	e13ffe15 	stw	r4,-8(fp)
  225d60:	e17fff15 	stw	r5,-4(fp)
  225d64:	e0bfff17 	ldw	r2,-4(fp)
  225d68:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  225d6c:	0005303a 	rdctl	r2,status
  225d70:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  225d74:	e0fffb17 	ldw	r3,-20(fp)
  225d78:	00bfff84 	movi	r2,-2
  225d7c:	1884703a 	and	r2,r3,r2
  225d80:	1001703a 	wrctl	status,r2
  
  return context;
  225d84:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
  225d88:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
  225d8c:	e0bffa17 	ldw	r2,-24(fp)
  225d90:	00c00044 	movi	r3,1
  225d94:	1884983a 	sll	r2,r3,r2
  225d98:	0084303a 	nor	r2,zero,r2
  225d9c:	1007883a 	mov	r3,r2
  225da0:	008008f4 	movhi	r2,35
  225da4:	10a9ce04 	addi	r2,r2,-22728
  225da8:	10800017 	ldw	r2,0(r2)
  225dac:	1886703a 	and	r3,r3,r2
  225db0:	008008f4 	movhi	r2,35
  225db4:	10a9ce04 	addi	r2,r2,-22728
  225db8:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
  225dbc:	008008f4 	movhi	r2,35
  225dc0:	10a9ce04 	addi	r2,r2,-22728
  225dc4:	10800017 	ldw	r2,0(r2)
  225dc8:	100170fa 	wrctl	ienable,r2
  225dcc:	e0bffc17 	ldw	r2,-16(fp)
  225dd0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  225dd4:	e0bffd17 	ldw	r2,-12(fp)
  225dd8:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
  225ddc:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
  225de0:	0001883a 	nop
}
  225de4:	e037883a 	mov	sp,fp
  225de8:	df000017 	ldw	fp,0(sp)
  225dec:	dec00104 	addi	sp,sp,4
  225df0:	f800283a 	ret

00225df4 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
  225df4:	defffc04 	addi	sp,sp,-16
  225df8:	df000315 	stw	fp,12(sp)
  225dfc:	df000304 	addi	fp,sp,12
  225e00:	e13ffe15 	stw	r4,-8(fp)
  225e04:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
  225e08:	000530fa 	rdctl	r2,ienable
  225e0c:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
  225e10:	e0bfff17 	ldw	r2,-4(fp)
  225e14:	00c00044 	movi	r3,1
  225e18:	1884983a 	sll	r2,r3,r2
  225e1c:	1007883a 	mov	r3,r2
  225e20:	e0bffd17 	ldw	r2,-12(fp)
  225e24:	1884703a 	and	r2,r3,r2
  225e28:	1004c03a 	cmpne	r2,r2,zero
  225e2c:	10803fcc 	andi	r2,r2,255
}
  225e30:	e037883a 	mov	sp,fp
  225e34:	df000017 	ldw	fp,0(sp)
  225e38:	dec00104 	addi	sp,sp,4
  225e3c:	f800283a 	ret

00225e40 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  225e40:	defff504 	addi	sp,sp,-44
  225e44:	dfc00a15 	stw	ra,40(sp)
  225e48:	df000915 	stw	fp,36(sp)
  225e4c:	df000904 	addi	fp,sp,36
  225e50:	e13ffc15 	stw	r4,-16(fp)
  225e54:	e17ffd15 	stw	r5,-12(fp)
  225e58:	e1bffe15 	stw	r6,-8(fp)
  225e5c:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
  225e60:	00bffa84 	movi	r2,-22
  225e64:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  225e68:	e0bffd17 	ldw	r2,-12(fp)
  225e6c:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
  225e70:	e0bff817 	ldw	r2,-32(fp)
  225e74:	10800808 	cmpgei	r2,r2,32
  225e78:	1000271e 	bne	r2,zero,225f18 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  225e7c:	0005303a 	rdctl	r2,status
  225e80:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  225e84:	e0fffa17 	ldw	r3,-24(fp)
  225e88:	00bfff84 	movi	r2,-2
  225e8c:	1884703a 	and	r2,r3,r2
  225e90:	1001703a 	wrctl	status,r2
  
  return context;
  225e94:	e0bffa17 	ldw	r2,-24(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
  225e98:	e0bff915 	stw	r2,-28(fp)

    alt_irq[id].handler = isr;
  225e9c:	008008f4 	movhi	r2,35
  225ea0:	10a9dc04 	addi	r2,r2,-22672
  225ea4:	e0fff817 	ldw	r3,-32(fp)
  225ea8:	180690fa 	slli	r3,r3,3
  225eac:	10c5883a 	add	r2,r2,r3
  225eb0:	e0fffe17 	ldw	r3,-8(fp)
  225eb4:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
  225eb8:	008008f4 	movhi	r2,35
  225ebc:	10a9dc04 	addi	r2,r2,-22672
  225ec0:	e0fff817 	ldw	r3,-32(fp)
  225ec4:	180690fa 	slli	r3,r3,3
  225ec8:	10c5883a 	add	r2,r2,r3
  225ecc:	10800104 	addi	r2,r2,4
  225ed0:	e0ffff17 	ldw	r3,-4(fp)
  225ed4:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
  225ed8:	e0bffe17 	ldw	r2,-8(fp)
  225edc:	10000526 	beq	r2,zero,225ef4 <alt_iic_isr_register+0xb4>
  225ee0:	e0bff817 	ldw	r2,-32(fp)
  225ee4:	e13ffc17 	ldw	r4,-16(fp)
  225ee8:	100b883a 	mov	r5,r2
  225eec:	0225cb00 	call	225cb0 <alt_ic_irq_enable>
  225ef0:	00000406 	br	225f04 <alt_iic_isr_register+0xc4>
  225ef4:	e0bff817 	ldw	r2,-32(fp)
  225ef8:	e13ffc17 	ldw	r4,-16(fp)
  225efc:	100b883a 	mov	r5,r2
  225f00:	0225d500 	call	225d50 <alt_ic_irq_disable>
  225f04:	e0bff715 	stw	r2,-36(fp)
  225f08:	e0bff917 	ldw	r2,-28(fp)
  225f0c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  225f10:	e0bffb17 	ldw	r2,-20(fp)
  225f14:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
  225f18:	e0bff717 	ldw	r2,-36(fp)
}
  225f1c:	e037883a 	mov	sp,fp
  225f20:	dfc00117 	ldw	ra,4(sp)
  225f24:	df000017 	ldw	fp,0(sp)
  225f28:	dec00204 	addi	sp,sp,8
  225f2c:	f800283a 	ret

00225f30 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
  225f30:	defff904 	addi	sp,sp,-28
  225f34:	dfc00615 	stw	ra,24(sp)
  225f38:	df000515 	stw	fp,20(sp)
  225f3c:	df000504 	addi	fp,sp,20
  225f40:	e13ffc15 	stw	r4,-16(fp)
  225f44:	e17ffd15 	stw	r5,-12(fp)
  225f48:	e1bffe15 	stw	r6,-8(fp)
  225f4c:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
  225f50:	e13ffd17 	ldw	r4,-12(fp)
  225f54:	e17ffe17 	ldw	r5,-8(fp)
  225f58:	e1bfff17 	ldw	r6,-4(fp)
  225f5c:	02261840 	call	226184 <open>
  225f60:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
  225f64:	e0bffb17 	ldw	r2,-20(fp)
  225f68:	10001c16 	blt	r2,zero,225fdc <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
  225f6c:	008008b4 	movhi	r2,34
  225f70:	109e1404 	addi	r2,r2,30800
  225f74:	e0fffb17 	ldw	r3,-20(fp)
  225f78:	18c00324 	muli	r3,r3,12
  225f7c:	10c5883a 	add	r2,r2,r3
  225f80:	10c00017 	ldw	r3,0(r2)
  225f84:	e0bffc17 	ldw	r2,-16(fp)
  225f88:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
  225f8c:	008008b4 	movhi	r2,34
  225f90:	109e1404 	addi	r2,r2,30800
  225f94:	e0fffb17 	ldw	r3,-20(fp)
  225f98:	18c00324 	muli	r3,r3,12
  225f9c:	10c5883a 	add	r2,r2,r3
  225fa0:	10800104 	addi	r2,r2,4
  225fa4:	10c00017 	ldw	r3,0(r2)
  225fa8:	e0bffc17 	ldw	r2,-16(fp)
  225fac:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
  225fb0:	008008b4 	movhi	r2,34
  225fb4:	109e1404 	addi	r2,r2,30800
  225fb8:	e0fffb17 	ldw	r3,-20(fp)
  225fbc:	18c00324 	muli	r3,r3,12
  225fc0:	10c5883a 	add	r2,r2,r3
  225fc4:	10800204 	addi	r2,r2,8
  225fc8:	10c00017 	ldw	r3,0(r2)
  225fcc:	e0bffc17 	ldw	r2,-16(fp)
  225fd0:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
  225fd4:	e13ffb17 	ldw	r4,-20(fp)
  225fd8:	0223acc0 	call	223acc <alt_release_fd>
  }
} 
  225fdc:	e037883a 	mov	sp,fp
  225fe0:	dfc00117 	ldw	ra,4(sp)
  225fe4:	df000017 	ldw	fp,0(sp)
  225fe8:	dec00204 	addi	sp,sp,8
  225fec:	f800283a 	ret

00225ff0 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
  225ff0:	defffb04 	addi	sp,sp,-20
  225ff4:	dfc00415 	stw	ra,16(sp)
  225ff8:	df000315 	stw	fp,12(sp)
  225ffc:	df000304 	addi	fp,sp,12
  226000:	e13ffd15 	stw	r4,-12(fp)
  226004:	e17ffe15 	stw	r5,-8(fp)
  226008:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
  22600c:	010008b4 	movhi	r4,34
  226010:	211e1704 	addi	r4,r4,30812
  226014:	e17ffd17 	ldw	r5,-12(fp)
  226018:	01800044 	movi	r6,1
  22601c:	01c07fc4 	movi	r7,511
  226020:	0225f300 	call	225f30 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
  226024:	010008b4 	movhi	r4,34
  226028:	211e1404 	addi	r4,r4,30800
  22602c:	e17ffe17 	ldw	r5,-8(fp)
  226030:	000d883a 	mov	r6,zero
  226034:	01c07fc4 	movi	r7,511
  226038:	0225f300 	call	225f30 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
  22603c:	010008b4 	movhi	r4,34
  226040:	211e1a04 	addi	r4,r4,30824
  226044:	e17fff17 	ldw	r5,-4(fp)
  226048:	01800044 	movi	r6,1
  22604c:	01c07fc4 	movi	r7,511
  226050:	0225f300 	call	225f30 <alt_open_fd>
}  
  226054:	e037883a 	mov	sp,fp
  226058:	dfc00117 	ldw	ra,4(sp)
  22605c:	df000017 	ldw	fp,0(sp)
  226060:	dec00204 	addi	sp,sp,8
  226064:	f800283a 	ret

00226068 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  226068:	defffe04 	addi	sp,sp,-8
  22606c:	dfc00115 	stw	ra,4(sp)
  226070:	df000015 	stw	fp,0(sp)
  226074:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
  226078:	008008f4 	movhi	r2,35
  22607c:	10a2dc04 	addi	r2,r2,-29840
  226080:	10800017 	ldw	r2,0(r2)
  226084:	10000526 	beq	r2,zero,22609c <alt_get_errno+0x34>
  226088:	008008f4 	movhi	r2,35
  22608c:	10a2dc04 	addi	r2,r2,-29840
  226090:	10800017 	ldw	r2,0(r2)
  226094:	103ee83a 	callr	r2
  226098:	00000206 	br	2260a4 <alt_get_errno+0x3c>
  22609c:	008008f4 	movhi	r2,35
  2260a0:	10a9ca04 	addi	r2,r2,-22744
}
  2260a4:	e037883a 	mov	sp,fp
  2260a8:	dfc00117 	ldw	ra,4(sp)
  2260ac:	df000017 	ldw	fp,0(sp)
  2260b0:	dec00204 	addi	sp,sp,8
  2260b4:	f800283a 	ret

002260b8 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
  2260b8:	defffd04 	addi	sp,sp,-12
  2260bc:	df000215 	stw	fp,8(sp)
  2260c0:	df000204 	addi	fp,sp,8
  2260c4:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
  2260c8:	e0bfff17 	ldw	r2,-4(fp)
  2260cc:	10800217 	ldw	r2,8(r2)
  2260d0:	10d00034 	orhi	r3,r2,16384
  2260d4:	e0bfff17 	ldw	r2,-4(fp)
  2260d8:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  2260dc:	e03ffe15 	stw	zero,-8(fp)
  2260e0:	00001d06 	br	226158 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  2260e4:	008008b4 	movhi	r2,34
  2260e8:	109e1404 	addi	r2,r2,30800
  2260ec:	e0fffe17 	ldw	r3,-8(fp)
  2260f0:	18c00324 	muli	r3,r3,12
  2260f4:	10c5883a 	add	r2,r2,r3
  2260f8:	10c00017 	ldw	r3,0(r2)
  2260fc:	e0bfff17 	ldw	r2,-4(fp)
  226100:	10800017 	ldw	r2,0(r2)
  226104:	1880111e 	bne	r3,r2,22614c <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  226108:	008008b4 	movhi	r2,34
  22610c:	109e1404 	addi	r2,r2,30800
  226110:	e0fffe17 	ldw	r3,-8(fp)
  226114:	18c00324 	muli	r3,r3,12
  226118:	10c5883a 	add	r2,r2,r3
  22611c:	10800204 	addi	r2,r2,8
  226120:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
  226124:	1000090e 	bge	r2,zero,22614c <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
  226128:	e0bffe17 	ldw	r2,-8(fp)
  22612c:	10c00324 	muli	r3,r2,12
  226130:	008008b4 	movhi	r2,34
  226134:	109e1404 	addi	r2,r2,30800
  226138:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
  22613c:	e0bfff17 	ldw	r2,-4(fp)
  226140:	18800226 	beq	r3,r2,22614c <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
  226144:	00bffcc4 	movi	r2,-13
  226148:	00000a06 	br	226174 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  22614c:	e0bffe17 	ldw	r2,-8(fp)
  226150:	10800044 	addi	r2,r2,1
  226154:	e0bffe15 	stw	r2,-8(fp)
  226158:	008008f4 	movhi	r2,35
  22615c:	10a2db04 	addi	r2,r2,-29844
  226160:	10800017 	ldw	r2,0(r2)
  226164:	1007883a 	mov	r3,r2
  226168:	e0bffe17 	ldw	r2,-8(fp)
  22616c:	18bfdd2e 	bgeu	r3,r2,2260e4 <__alt_data_end+0xffff2864>
    }
  }
  
  /* The device is not locked */
 
  return 0;
  226170:	0005883a 	mov	r2,zero
}
  226174:	e037883a 	mov	sp,fp
  226178:	df000017 	ldw	fp,0(sp)
  22617c:	dec00104 	addi	sp,sp,4
  226180:	f800283a 	ret

00226184 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
  226184:	defff604 	addi	sp,sp,-40
  226188:	dfc00915 	stw	ra,36(sp)
  22618c:	df000815 	stw	fp,32(sp)
  226190:	df000804 	addi	fp,sp,32
  226194:	e13ffd15 	stw	r4,-12(fp)
  226198:	e17ffe15 	stw	r5,-8(fp)
  22619c:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
  2261a0:	00bfffc4 	movi	r2,-1
  2261a4:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
  2261a8:	00bffb44 	movi	r2,-19
  2261ac:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
  2261b0:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
  2261b4:	e13ffd17 	ldw	r4,-12(fp)
  2261b8:	014008f4 	movhi	r5,35
  2261bc:	2962d904 	addi	r5,r5,-29852
  2261c0:	0225ba00 	call	225ba0 <alt_find_dev>
  2261c4:	e0bff815 	stw	r2,-32(fp)
  2261c8:	e0bff817 	ldw	r2,-32(fp)
  2261cc:	1000051e 	bne	r2,zero,2261e4 <open+0x60>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
  2261d0:	e13ffd17 	ldw	r4,-12(fp)
  2261d4:	02264980 	call	226498 <alt_find_file>
  2261d8:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
  2261dc:	00800044 	movi	r2,1
  2261e0:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
  2261e4:	e0bff817 	ldw	r2,-32(fp)
  2261e8:	10002926 	beq	r2,zero,226290 <open+0x10c>
  {
    if ((index = alt_get_fd (dev)) < 0)
  2261ec:	e13ff817 	ldw	r4,-32(fp)
  2261f0:	02265ac0 	call	2265ac <alt_get_fd>
  2261f4:	e0bff915 	stw	r2,-28(fp)
  2261f8:	e0bff917 	ldw	r2,-28(fp)
  2261fc:	1000030e 	bge	r2,zero,22620c <open+0x88>
    {
      status = index;
  226200:	e0bff917 	ldw	r2,-28(fp)
  226204:	e0bffa15 	stw	r2,-24(fp)
  226208:	00002306 	br	226298 <open+0x114>
    }
    else
    {
      fd = &alt_fd_list[index];
  22620c:	e0bff917 	ldw	r2,-28(fp)
  226210:	10c00324 	muli	r3,r2,12
  226214:	008008b4 	movhi	r2,34
  226218:	109e1404 	addi	r2,r2,30800
  22621c:	1885883a 	add	r2,r3,r2
  226220:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
  226224:	e0fffe17 	ldw	r3,-8(fp)
  226228:	00900034 	movhi	r2,16384
  22622c:	10bfffc4 	addi	r2,r2,-1
  226230:	1886703a 	and	r3,r3,r2
  226234:	e0bffc17 	ldw	r2,-16(fp)
  226238:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
  22623c:	e0bffb17 	ldw	r2,-20(fp)
  226240:	1000051e 	bne	r2,zero,226258 <open+0xd4>
  226244:	e13ffc17 	ldw	r4,-16(fp)
  226248:	02260b80 	call	2260b8 <alt_file_locked>
  22624c:	e0bffa15 	stw	r2,-24(fp)
  226250:	e0bffa17 	ldw	r2,-24(fp)
  226254:	10001016 	blt	r2,zero,226298 <open+0x114>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
  226258:	e0bff817 	ldw	r2,-32(fp)
  22625c:	10800317 	ldw	r2,12(r2)
  226260:	10000826 	beq	r2,zero,226284 <open+0x100>
  226264:	e0bff817 	ldw	r2,-32(fp)
  226268:	10800317 	ldw	r2,12(r2)
  22626c:	e13ffc17 	ldw	r4,-16(fp)
  226270:	e17ffd17 	ldw	r5,-12(fp)
  226274:	e1bffe17 	ldw	r6,-8(fp)
  226278:	e1ffff17 	ldw	r7,-4(fp)
  22627c:	103ee83a 	callr	r2
  226280:	00000106 	br	226288 <open+0x104>
  226284:	0005883a 	mov	r2,zero
  226288:	e0bffa15 	stw	r2,-24(fp)
  22628c:	00000206 	br	226298 <open+0x114>
      }
    }
  }
  else
  {
    status = -ENODEV;
  226290:	00bffb44 	movi	r2,-19
  226294:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
  226298:	e0bffa17 	ldw	r2,-24(fp)
  22629c:	1000090e 	bge	r2,zero,2262c4 <open+0x140>
  {
    alt_release_fd (index);  
  2262a0:	e13ff917 	ldw	r4,-28(fp)
  2262a4:	0223acc0 	call	223acc <alt_release_fd>
    ALT_ERRNO = -status;
  2262a8:	02260680 	call	226068 <alt_get_errno>
  2262ac:	1007883a 	mov	r3,r2
  2262b0:	e0bffa17 	ldw	r2,-24(fp)
  2262b4:	0085c83a 	sub	r2,zero,r2
  2262b8:	18800015 	stw	r2,0(r3)
    return -1;
  2262bc:	00bfffc4 	movi	r2,-1
  2262c0:	00000106 	br	2262c8 <open+0x144>
  }
  
  /* return the reference upon success */

  return index;
  2262c4:	e0bff917 	ldw	r2,-28(fp)
}
  2262c8:	e037883a 	mov	sp,fp
  2262cc:	dfc00117 	ldw	ra,4(sp)
  2262d0:	df000017 	ldw	fp,0(sp)
  2262d4:	dec00204 	addi	sp,sp,8
  2262d8:	f800283a 	ret

002262dc <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
  2262dc:	defffa04 	addi	sp,sp,-24
  2262e0:	df000515 	stw	fp,20(sp)
  2262e4:	df000504 	addi	fp,sp,20
  2262e8:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
  2262ec:	0005303a 	rdctl	r2,status
  2262f0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
  2262f4:	e0fffc17 	ldw	r3,-16(fp)
  2262f8:	00bfff84 	movi	r2,-2
  2262fc:	1884703a 	and	r2,r3,r2
  226300:	1001703a 	wrctl	status,r2
  
  return context;
  226304:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
  226308:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
  22630c:	e0bfff17 	ldw	r2,-4(fp)
  226310:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
  226314:	e0bffd17 	ldw	r2,-12(fp)
  226318:	10800017 	ldw	r2,0(r2)
  22631c:	e0fffd17 	ldw	r3,-12(fp)
  226320:	18c00117 	ldw	r3,4(r3)
  226324:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
  226328:	e0bffd17 	ldw	r2,-12(fp)
  22632c:	10800117 	ldw	r2,4(r2)
  226330:	e0fffd17 	ldw	r3,-12(fp)
  226334:	18c00017 	ldw	r3,0(r3)
  226338:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
  22633c:	e0bffd17 	ldw	r2,-12(fp)
  226340:	e0fffd17 	ldw	r3,-12(fp)
  226344:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
  226348:	e0bffd17 	ldw	r2,-12(fp)
  22634c:	e0fffd17 	ldw	r3,-12(fp)
  226350:	10c00015 	stw	r3,0(r2)
  226354:	e0bffb17 	ldw	r2,-20(fp)
  226358:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
  22635c:	e0bffe17 	ldw	r2,-8(fp)
  226360:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
  226364:	e037883a 	mov	sp,fp
  226368:	df000017 	ldw	fp,0(sp)
  22636c:	dec00104 	addi	sp,sp,4
  226370:	f800283a 	ret

00226374 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
  226374:	defffb04 	addi	sp,sp,-20
  226378:	dfc00415 	stw	ra,16(sp)
  22637c:	df000315 	stw	fp,12(sp)
  226380:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
  226384:	d0a00e17 	ldw	r2,-32712(gp)
  226388:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
  22638c:	d0a6fd17 	ldw	r2,-25612(gp)
  226390:	10800044 	addi	r2,r2,1
  226394:	d0a6fd15 	stw	r2,-25612(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  226398:	00002e06 	br	226454 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
  22639c:	e0bffd17 	ldw	r2,-12(fp)
  2263a0:	10800017 	ldw	r2,0(r2)
  2263a4:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
  2263a8:	e0bffd17 	ldw	r2,-12(fp)
  2263ac:	10800403 	ldbu	r2,16(r2)
  2263b0:	10803fcc 	andi	r2,r2,255
  2263b4:	10000426 	beq	r2,zero,2263c8 <alt_tick+0x54>
  2263b8:	d0a6fd17 	ldw	r2,-25612(gp)
  2263bc:	1000021e 	bne	r2,zero,2263c8 <alt_tick+0x54>
    {
      alarm->rollover = 0;
  2263c0:	e0bffd17 	ldw	r2,-12(fp)
  2263c4:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
  2263c8:	e0bffd17 	ldw	r2,-12(fp)
  2263cc:	10800217 	ldw	r2,8(r2)
  2263d0:	d0e6fd17 	ldw	r3,-25612(gp)
  2263d4:	18801d36 	bltu	r3,r2,22644c <alt_tick+0xd8>
  2263d8:	e0bffd17 	ldw	r2,-12(fp)
  2263dc:	10800403 	ldbu	r2,16(r2)
  2263e0:	10803fcc 	andi	r2,r2,255
  2263e4:	1000191e 	bne	r2,zero,22644c <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
  2263e8:	e0bffd17 	ldw	r2,-12(fp)
  2263ec:	10800317 	ldw	r2,12(r2)
  2263f0:	e0fffd17 	ldw	r3,-12(fp)
  2263f4:	18c00517 	ldw	r3,20(r3)
  2263f8:	1809883a 	mov	r4,r3
  2263fc:	103ee83a 	callr	r2
  226400:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
  226404:	e0bfff17 	ldw	r2,-4(fp)
  226408:	1000031e 	bne	r2,zero,226418 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
  22640c:	e13ffd17 	ldw	r4,-12(fp)
  226410:	02262dc0 	call	2262dc <alt_alarm_stop>
  226414:	00000d06 	br	22644c <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
  226418:	e0bffd17 	ldw	r2,-12(fp)
  22641c:	10c00217 	ldw	r3,8(r2)
  226420:	e0bfff17 	ldw	r2,-4(fp)
  226424:	1887883a 	add	r3,r3,r2
  226428:	e0bffd17 	ldw	r2,-12(fp)
  22642c:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
  226430:	e0bffd17 	ldw	r2,-12(fp)
  226434:	10c00217 	ldw	r3,8(r2)
  226438:	d0a6fd17 	ldw	r2,-25612(gp)
  22643c:	1880032e 	bgeu	r3,r2,22644c <alt_tick+0xd8>
        {
          alarm->rollover = 1;
  226440:	e0bffd17 	ldw	r2,-12(fp)
  226444:	00c00044 	movi	r3,1
  226448:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
  22644c:	e0bffe17 	ldw	r2,-8(fp)
  226450:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  226454:	e0fffd17 	ldw	r3,-12(fp)
  226458:	d0a00e04 	addi	r2,gp,-32712
  22645c:	18bfcf1e 	bne	r3,r2,22639c <__alt_data_end+0xffff2b1c>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
  226460:	0001883a 	nop
}
  226464:	e037883a 	mov	sp,fp
  226468:	dfc00117 	ldw	ra,4(sp)
  22646c:	df000017 	ldw	fp,0(sp)
  226470:	dec00204 	addi	sp,sp,8
  226474:	f800283a 	ret

00226478 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
  226478:	deffff04 	addi	sp,sp,-4
  22647c:	df000015 	stw	fp,0(sp)
  226480:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
  226484:	000170fa 	wrctl	ienable,zero
}
  226488:	e037883a 	mov	sp,fp
  22648c:	df000017 	ldw	fp,0(sp)
  226490:	dec00104 	addi	sp,sp,4
  226494:	f800283a 	ret

00226498 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
  226498:	defffb04 	addi	sp,sp,-20
  22649c:	dfc00415 	stw	ra,16(sp)
  2264a0:	df000315 	stw	fp,12(sp)
  2264a4:	df000304 	addi	fp,sp,12
  2264a8:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
  2264ac:	008008f4 	movhi	r2,35
  2264b0:	10a2d704 	addi	r2,r2,-29860
  2264b4:	10800017 	ldw	r2,0(r2)
  2264b8:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  2264bc:	00003106 	br	226584 <alt_find_file+0xec>
  {
    len = strlen(next->name);
  2264c0:	e0bffd17 	ldw	r2,-12(fp)
  2264c4:	10800217 	ldw	r2,8(r2)
  2264c8:	1009883a 	mov	r4,r2
  2264cc:	02206d40 	call	2206d4 <strlen>
  2264d0:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
  2264d4:	e0bffd17 	ldw	r2,-12(fp)
  2264d8:	10c00217 	ldw	r3,8(r2)
  2264dc:	e0bffe17 	ldw	r2,-8(fp)
  2264e0:	10bfffc4 	addi	r2,r2,-1
  2264e4:	1885883a 	add	r2,r3,r2
  2264e8:	10800003 	ldbu	r2,0(r2)
  2264ec:	10803fcc 	andi	r2,r2,255
  2264f0:	1080201c 	xori	r2,r2,128
  2264f4:	10bfe004 	addi	r2,r2,-128
  2264f8:	10800bd8 	cmpnei	r2,r2,47
  2264fc:	1000031e 	bne	r2,zero,22650c <alt_find_file+0x74>
    {
      len -= 1;
  226500:	e0bffe17 	ldw	r2,-8(fp)
  226504:	10bfffc4 	addi	r2,r2,-1
  226508:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  22650c:	e0bffe17 	ldw	r2,-8(fp)
  226510:	e0ffff17 	ldw	r3,-4(fp)
  226514:	1885883a 	add	r2,r3,r2
  226518:	10800003 	ldbu	r2,0(r2)
  22651c:	10803fcc 	andi	r2,r2,255
  226520:	1080201c 	xori	r2,r2,128
  226524:	10bfe004 	addi	r2,r2,-128
  226528:	10800be0 	cmpeqi	r2,r2,47
  22652c:	1000081e 	bne	r2,zero,226550 <alt_find_file+0xb8>
  226530:	e0bffe17 	ldw	r2,-8(fp)
  226534:	e0ffff17 	ldw	r3,-4(fp)
  226538:	1885883a 	add	r2,r3,r2
  22653c:	10800003 	ldbu	r2,0(r2)
  226540:	10803fcc 	andi	r2,r2,255
  226544:	1080201c 	xori	r2,r2,128
  226548:	10bfe004 	addi	r2,r2,-128
  22654c:	10000a1e 	bne	r2,zero,226578 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
  226550:	e0bffd17 	ldw	r2,-12(fp)
  226554:	10c00217 	ldw	r3,8(r2)
  226558:	e0bffe17 	ldw	r2,-8(fp)
  22655c:	1809883a 	mov	r4,r3
  226560:	e17fff17 	ldw	r5,-4(fp)
  226564:	100d883a 	mov	r6,r2
  226568:	02267d40 	call	2267d4 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
  22656c:	1000021e 	bne	r2,zero,226578 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
  226570:	e0bffd17 	ldw	r2,-12(fp)
  226574:	00000806 	br	226598 <alt_find_file+0x100>
    }
    next = (alt_dev*) next->llist.next;
  226578:	e0bffd17 	ldw	r2,-12(fp)
  22657c:	10800017 	ldw	r2,0(r2)
  226580:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
  226584:	e0fffd17 	ldw	r3,-12(fp)
  226588:	008008f4 	movhi	r2,35
  22658c:	10a2d704 	addi	r2,r2,-29860
  226590:	18bfcb1e 	bne	r3,r2,2264c0 <__alt_data_end+0xffff2c40>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
  226594:	0005883a 	mov	r2,zero
}
  226598:	e037883a 	mov	sp,fp
  22659c:	dfc00117 	ldw	ra,4(sp)
  2265a0:	df000017 	ldw	fp,0(sp)
  2265a4:	dec00204 	addi	sp,sp,8
  2265a8:	f800283a 	ret

002265ac <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
  2265ac:	defffc04 	addi	sp,sp,-16
  2265b0:	df000315 	stw	fp,12(sp)
  2265b4:	df000304 	addi	fp,sp,12
  2265b8:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
  2265bc:	00bffa04 	movi	r2,-24
  2265c0:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  2265c4:	e03ffd15 	stw	zero,-12(fp)
  2265c8:	00001d06 	br	226640 <alt_get_fd+0x94>
  {
    if (!alt_fd_list[i].dev)
  2265cc:	008008b4 	movhi	r2,34
  2265d0:	109e1404 	addi	r2,r2,30800
  2265d4:	e0fffd17 	ldw	r3,-12(fp)
  2265d8:	18c00324 	muli	r3,r3,12
  2265dc:	10c5883a 	add	r2,r2,r3
  2265e0:	10800017 	ldw	r2,0(r2)
  2265e4:	1000131e 	bne	r2,zero,226634 <alt_get_fd+0x88>
    {
      alt_fd_list[i].dev = dev;
  2265e8:	008008b4 	movhi	r2,34
  2265ec:	109e1404 	addi	r2,r2,30800
  2265f0:	e0fffd17 	ldw	r3,-12(fp)
  2265f4:	18c00324 	muli	r3,r3,12
  2265f8:	10c5883a 	add	r2,r2,r3
  2265fc:	e0ffff17 	ldw	r3,-4(fp)
  226600:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
  226604:	008008f4 	movhi	r2,35
  226608:	10a2db04 	addi	r2,r2,-29844
  22660c:	10c00017 	ldw	r3,0(r2)
  226610:	e0bffd17 	ldw	r2,-12(fp)
  226614:	1880040e 	bge	r3,r2,226628 <alt_get_fd+0x7c>
      {
        alt_max_fd = i;
  226618:	008008f4 	movhi	r2,35
  22661c:	10a2db04 	addi	r2,r2,-29844
  226620:	e0fffd17 	ldw	r3,-12(fp)
  226624:	10c00015 	stw	r3,0(r2)
      }
      rc = i;
  226628:	e0bffd17 	ldw	r2,-12(fp)
  22662c:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
  226630:	00000606 	br	22664c <alt_get_fd+0xa0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
  226634:	e0bffd17 	ldw	r2,-12(fp)
  226638:	10800044 	addi	r2,r2,1
  22663c:	e0bffd15 	stw	r2,-12(fp)
  226640:	e0bffd17 	ldw	r2,-12(fp)
  226644:	10800810 	cmplti	r2,r2,32
  226648:	103fe01e 	bne	r2,zero,2265cc <__alt_data_end+0xffff2d4c>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
  22664c:	e0bffe17 	ldw	r2,-8(fp)
}
  226650:	e037883a 	mov	sp,fp
  226654:	df000017 	ldw	fp,0(sp)
  226658:	dec00104 	addi	sp,sp,4
  22665c:	f800283a 	ret

00226660 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
  226660:	defffb04 	addi	sp,sp,-20
  226664:	df000415 	stw	fp,16(sp)
  226668:	df000404 	addi	fp,sp,16
  22666c:	e13ffe15 	stw	r4,-8(fp)
  226670:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
  226674:	e0bfff17 	ldw	r2,-4(fp)
  226678:	10840070 	cmpltui	r2,r2,4097
  22667c:	1000021e 	bne	r2,zero,226688 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
  226680:	00840004 	movi	r2,4096
  226684:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
  226688:	e0fffe17 	ldw	r3,-8(fp)
  22668c:	e0bfff17 	ldw	r2,-4(fp)
  226690:	1885883a 	add	r2,r3,r2
  226694:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
  226698:	e0bffe17 	ldw	r2,-8(fp)
  22669c:	e0bffc15 	stw	r2,-16(fp)
  2266a0:	00000506 	br	2266b8 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
  2266a4:	e0bffc17 	ldw	r2,-16(fp)
  2266a8:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
  2266ac:	e0bffc17 	ldw	r2,-16(fp)
  2266b0:	10800804 	addi	r2,r2,32
  2266b4:	e0bffc15 	stw	r2,-16(fp)
  2266b8:	e0fffc17 	ldw	r3,-16(fp)
  2266bc:	e0bffd17 	ldw	r2,-12(fp)
  2266c0:	18bff836 	bltu	r3,r2,2266a4 <__alt_data_end+0xffff2e24>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
  2266c4:	e0bffe17 	ldw	r2,-8(fp)
  2266c8:	108007cc 	andi	r2,r2,31
  2266cc:	10000226 	beq	r2,zero,2266d8 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
  2266d0:	e0bffc17 	ldw	r2,-16(fp)
  2266d4:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
  2266d8:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
  2266dc:	e037883a 	mov	sp,fp
  2266e0:	df000017 	ldw	fp,0(sp)
  2266e4:	dec00104 	addi	sp,sp,4
  2266e8:	f800283a 	ret

002266ec <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
  2266ec:	defffe04 	addi	sp,sp,-8
  2266f0:	df000115 	stw	fp,4(sp)
  2266f4:	df000104 	addi	fp,sp,4
  2266f8:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
  2266fc:	e0bfff17 	ldw	r2,-4(fp)
  226700:	10bffe84 	addi	r2,r2,-6
  226704:	10c00428 	cmpgeui	r3,r2,16
  226708:	18001a1e 	bne	r3,zero,226774 <alt_exception_cause_generated_bad_addr+0x88>
  22670c:	100690ba 	slli	r3,r2,2
  226710:	008008b4 	movhi	r2,34
  226714:	1099c904 	addi	r2,r2,26404
  226718:	1885883a 	add	r2,r3,r2
  22671c:	10800017 	ldw	r2,0(r2)
  226720:	1000683a 	jmp	r2
  226724:	00226764 	muli	zero,zero,-30307
  226728:	00226764 	muli	zero,zero,-30307
  22672c:	00226774 	movhi	zero,35229
  226730:	00226774 	movhi	zero,35229
  226734:	00226774 	movhi	zero,35229
  226738:	00226764 	muli	zero,zero,-30307
  22673c:	0022676c 	andhi	zero,zero,35229
  226740:	00226774 	movhi	zero,35229
  226744:	00226764 	muli	zero,zero,-30307
  226748:	00226764 	muli	zero,zero,-30307
  22674c:	00226774 	movhi	zero,35229
  226750:	00226764 	muli	zero,zero,-30307
  226754:	0022676c 	andhi	zero,zero,35229
  226758:	00226774 	movhi	zero,35229
  22675c:	00226774 	movhi	zero,35229
  226760:	00226764 	muli	zero,zero,-30307
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
  226764:	00800044 	movi	r2,1
  226768:	00000306 	br	226778 <alt_exception_cause_generated_bad_addr+0x8c>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
  22676c:	0005883a 	mov	r2,zero
  226770:	00000106 	br	226778 <alt_exception_cause_generated_bad_addr+0x8c>

  default:
    return 0;
  226774:	0005883a 	mov	r2,zero
  }
}
  226778:	e037883a 	mov	sp,fp
  22677c:	df000017 	ldw	fp,0(sp)
  226780:	dec00104 	addi	sp,sp,4
  226784:	f800283a 	ret

00226788 <atexit>:
  226788:	200b883a 	mov	r5,r4
  22678c:	000d883a 	mov	r6,zero
  226790:	0009883a 	mov	r4,zero
  226794:	000f883a 	mov	r7,zero
  226798:	0226bcc1 	jmpi	226bcc <__register_exitproc>

0022679c <exit>:
  22679c:	defffe04 	addi	sp,sp,-8
  2267a0:	000b883a 	mov	r5,zero
  2267a4:	dc000015 	stw	r16,0(sp)
  2267a8:	dfc00115 	stw	ra,4(sp)
  2267ac:	2021883a 	mov	r16,r4
  2267b0:	0226ce00 	call	226ce0 <__call_exitprocs>
  2267b4:	008008f4 	movhi	r2,35
  2267b8:	10a2d304 	addi	r2,r2,-29876
  2267bc:	11000017 	ldw	r4,0(r2)
  2267c0:	20800f17 	ldw	r2,60(r4)
  2267c4:	10000126 	beq	r2,zero,2267cc <exit+0x30>
  2267c8:	103ee83a 	callr	r2
  2267cc:	8009883a 	mov	r4,r16
  2267d0:	0226e740 	call	226e74 <_exit>

002267d4 <memcmp>:
  2267d4:	01c000c4 	movi	r7,3
  2267d8:	3980192e 	bgeu	r7,r6,226840 <memcmp+0x6c>
  2267dc:	2144b03a 	or	r2,r4,r5
  2267e0:	11c4703a 	and	r2,r2,r7
  2267e4:	10000f26 	beq	r2,zero,226824 <memcmp+0x50>
  2267e8:	20800003 	ldbu	r2,0(r4)
  2267ec:	28c00003 	ldbu	r3,0(r5)
  2267f0:	10c0151e 	bne	r2,r3,226848 <memcmp+0x74>
  2267f4:	31bfff84 	addi	r6,r6,-2
  2267f8:	01ffffc4 	movi	r7,-1
  2267fc:	00000406 	br	226810 <memcmp+0x3c>
  226800:	20800003 	ldbu	r2,0(r4)
  226804:	28c00003 	ldbu	r3,0(r5)
  226808:	31bfffc4 	addi	r6,r6,-1
  22680c:	10c00e1e 	bne	r2,r3,226848 <memcmp+0x74>
  226810:	21000044 	addi	r4,r4,1
  226814:	29400044 	addi	r5,r5,1
  226818:	31fff91e 	bne	r6,r7,226800 <__alt_data_end+0xffff2f80>
  22681c:	0005883a 	mov	r2,zero
  226820:	f800283a 	ret
  226824:	20c00017 	ldw	r3,0(r4)
  226828:	28800017 	ldw	r2,0(r5)
  22682c:	1880041e 	bne	r3,r2,226840 <memcmp+0x6c>
  226830:	31bfff04 	addi	r6,r6,-4
  226834:	21000104 	addi	r4,r4,4
  226838:	29400104 	addi	r5,r5,4
  22683c:	39bff936 	bltu	r7,r6,226824 <__alt_data_end+0xffff2fa4>
  226840:	303fe91e 	bne	r6,zero,2267e8 <__alt_data_end+0xffff2f68>
  226844:	003ff506 	br	22681c <__alt_data_end+0xffff2f9c>
  226848:	10c5c83a 	sub	r2,r2,r3
  22684c:	f800283a 	ret

00226850 <_putc_r>:
  226850:	defffc04 	addi	sp,sp,-16
  226854:	dc000215 	stw	r16,8(sp)
  226858:	dfc00315 	stw	ra,12(sp)
  22685c:	2021883a 	mov	r16,r4
  226860:	20000226 	beq	r4,zero,22686c <_putc_r+0x1c>
  226864:	20800e17 	ldw	r2,56(r4)
  226868:	10001b26 	beq	r2,zero,2268d8 <_putc_r+0x88>
  22686c:	30800217 	ldw	r2,8(r6)
  226870:	10bfffc4 	addi	r2,r2,-1
  226874:	30800215 	stw	r2,8(r6)
  226878:	10000a16 	blt	r2,zero,2268a4 <_putc_r+0x54>
  22687c:	30800017 	ldw	r2,0(r6)
  226880:	11400005 	stb	r5,0(r2)
  226884:	30800017 	ldw	r2,0(r6)
  226888:	10c00044 	addi	r3,r2,1
  22688c:	30c00015 	stw	r3,0(r6)
  226890:	10800003 	ldbu	r2,0(r2)
  226894:	dfc00317 	ldw	ra,12(sp)
  226898:	dc000217 	ldw	r16,8(sp)
  22689c:	dec00404 	addi	sp,sp,16
  2268a0:	f800283a 	ret
  2268a4:	30c00617 	ldw	r3,24(r6)
  2268a8:	10c00616 	blt	r2,r3,2268c4 <_putc_r+0x74>
  2268ac:	30800017 	ldw	r2,0(r6)
  2268b0:	00c00284 	movi	r3,10
  2268b4:	11400005 	stb	r5,0(r2)
  2268b8:	30800017 	ldw	r2,0(r6)
  2268bc:	11400003 	ldbu	r5,0(r2)
  2268c0:	28fff11e 	bne	r5,r3,226888 <__alt_data_end+0xffff3008>
  2268c4:	8009883a 	mov	r4,r16
  2268c8:	dfc00317 	ldw	ra,12(sp)
  2268cc:	dc000217 	ldw	r16,8(sp)
  2268d0:	dec00404 	addi	sp,sp,16
  2268d4:	0226a5c1 	jmpi	226a5c <__swbuf_r>
  2268d8:	d9400015 	stw	r5,0(sp)
  2268dc:	d9800115 	stw	r6,4(sp)
  2268e0:	02224000 	call	222400 <__sinit>
  2268e4:	d9800117 	ldw	r6,4(sp)
  2268e8:	d9400017 	ldw	r5,0(sp)
  2268ec:	003fdf06 	br	22686c <__alt_data_end+0xffff2fec>

002268f0 <putc>:
  2268f0:	defffc04 	addi	sp,sp,-16
  2268f4:	dc400115 	stw	r17,4(sp)
  2268f8:	044008f4 	movhi	r17,35
  2268fc:	8c62d404 	addi	r17,r17,-29872
  226900:	dc800215 	stw	r18,8(sp)
  226904:	2025883a 	mov	r18,r4
  226908:	89000017 	ldw	r4,0(r17)
  22690c:	dc000015 	stw	r16,0(sp)
  226910:	dfc00315 	stw	ra,12(sp)
  226914:	2821883a 	mov	r16,r5
  226918:	20000226 	beq	r4,zero,226924 <putc+0x34>
  22691c:	20c00e17 	ldw	r3,56(r4)
  226920:	18001a26 	beq	r3,zero,22698c <putc+0x9c>
  226924:	80800217 	ldw	r2,8(r16)
  226928:	10bfffc4 	addi	r2,r2,-1
  22692c:	80800215 	stw	r2,8(r16)
  226930:	10000c16 	blt	r2,zero,226964 <putc+0x74>
  226934:	80800017 	ldw	r2,0(r16)
  226938:	14800005 	stb	r18,0(r2)
  22693c:	80800017 	ldw	r2,0(r16)
  226940:	10c00044 	addi	r3,r2,1
  226944:	80c00015 	stw	r3,0(r16)
  226948:	10800003 	ldbu	r2,0(r2)
  22694c:	dfc00317 	ldw	ra,12(sp)
  226950:	dc800217 	ldw	r18,8(sp)
  226954:	dc400117 	ldw	r17,4(sp)
  226958:	dc000017 	ldw	r16,0(sp)
  22695c:	dec00404 	addi	sp,sp,16
  226960:	f800283a 	ret
  226964:	80c00617 	ldw	r3,24(r16)
  226968:	10c00a16 	blt	r2,r3,226994 <putc+0xa4>
  22696c:	80800017 	ldw	r2,0(r16)
  226970:	00c00284 	movi	r3,10
  226974:	14800005 	stb	r18,0(r2)
  226978:	80800017 	ldw	r2,0(r16)
  22697c:	11400003 	ldbu	r5,0(r2)
  226980:	28ffef1e 	bne	r5,r3,226940 <__alt_data_end+0xffff30c0>
  226984:	89000017 	ldw	r4,0(r17)
  226988:	00000406 	br	22699c <putc+0xac>
  22698c:	02224000 	call	222400 <__sinit>
  226990:	003fe406 	br	226924 <__alt_data_end+0xffff30a4>
  226994:	89000017 	ldw	r4,0(r17)
  226998:	900b883a 	mov	r5,r18
  22699c:	800d883a 	mov	r6,r16
  2269a0:	dfc00317 	ldw	ra,12(sp)
  2269a4:	dc800217 	ldw	r18,8(sp)
  2269a8:	dc400117 	ldw	r17,4(sp)
  2269ac:	dc000017 	ldw	r16,0(sp)
  2269b0:	dec00404 	addi	sp,sp,16
  2269b4:	0226a5c1 	jmpi	226a5c <__swbuf_r>

002269b8 <strcmp>:
  2269b8:	2144b03a 	or	r2,r4,r5
  2269bc:	108000cc 	andi	r2,r2,3
  2269c0:	1000171e 	bne	r2,zero,226a20 <strcmp+0x68>
  2269c4:	20800017 	ldw	r2,0(r4)
  2269c8:	28c00017 	ldw	r3,0(r5)
  2269cc:	10c0141e 	bne	r2,r3,226a20 <strcmp+0x68>
  2269d0:	027fbff4 	movhi	r9,65279
  2269d4:	4a7fbfc4 	addi	r9,r9,-257
  2269d8:	0086303a 	nor	r3,zero,r2
  2269dc:	02202074 	movhi	r8,32897
  2269e0:	1245883a 	add	r2,r2,r9
  2269e4:	42202004 	addi	r8,r8,-32640
  2269e8:	10c4703a 	and	r2,r2,r3
  2269ec:	1204703a 	and	r2,r2,r8
  2269f0:	10000226 	beq	r2,zero,2269fc <strcmp+0x44>
  2269f4:	00001706 	br	226a54 <strcmp+0x9c>
  2269f8:	1000161e 	bne	r2,zero,226a54 <strcmp+0x9c>
  2269fc:	21000104 	addi	r4,r4,4
  226a00:	20c00017 	ldw	r3,0(r4)
  226a04:	29400104 	addi	r5,r5,4
  226a08:	29800017 	ldw	r6,0(r5)
  226a0c:	1a4f883a 	add	r7,r3,r9
  226a10:	00c4303a 	nor	r2,zero,r3
  226a14:	3884703a 	and	r2,r7,r2
  226a18:	1204703a 	and	r2,r2,r8
  226a1c:	19bff626 	beq	r3,r6,2269f8 <__alt_data_end+0xffff3178>
  226a20:	20800007 	ldb	r2,0(r4)
  226a24:	1000051e 	bne	r2,zero,226a3c <strcmp+0x84>
  226a28:	00000606 	br	226a44 <strcmp+0x8c>
  226a2c:	21000044 	addi	r4,r4,1
  226a30:	20800007 	ldb	r2,0(r4)
  226a34:	29400044 	addi	r5,r5,1
  226a38:	10000226 	beq	r2,zero,226a44 <strcmp+0x8c>
  226a3c:	28c00007 	ldb	r3,0(r5)
  226a40:	10fffa26 	beq	r2,r3,226a2c <__alt_data_end+0xffff31ac>
  226a44:	20800003 	ldbu	r2,0(r4)
  226a48:	28c00003 	ldbu	r3,0(r5)
  226a4c:	10c5c83a 	sub	r2,r2,r3
  226a50:	f800283a 	ret
  226a54:	0005883a 	mov	r2,zero
  226a58:	f800283a 	ret

00226a5c <__swbuf_r>:
  226a5c:	defffc04 	addi	sp,sp,-16
  226a60:	dc800215 	stw	r18,8(sp)
  226a64:	dc400115 	stw	r17,4(sp)
  226a68:	dc000015 	stw	r16,0(sp)
  226a6c:	dfc00315 	stw	ra,12(sp)
  226a70:	2025883a 	mov	r18,r4
  226a74:	2823883a 	mov	r17,r5
  226a78:	3021883a 	mov	r16,r6
  226a7c:	20000226 	beq	r4,zero,226a88 <__swbuf_r+0x2c>
  226a80:	20800e17 	ldw	r2,56(r4)
  226a84:	10004126 	beq	r2,zero,226b8c <__swbuf_r+0x130>
  226a88:	80c00617 	ldw	r3,24(r16)
  226a8c:	8180030b 	ldhu	r6,12(r16)
  226a90:	80c00215 	stw	r3,8(r16)
  226a94:	30c0020c 	andi	r3,r6,8
  226a98:	18003526 	beq	r3,zero,226b70 <__swbuf_r+0x114>
  226a9c:	80c00417 	ldw	r3,16(r16)
  226aa0:	18003326 	beq	r3,zero,226b70 <__swbuf_r+0x114>
  226aa4:	3088000c 	andi	r2,r6,8192
  226aa8:	8c403fcc 	andi	r17,r17,255
  226aac:	10001726 	beq	r2,zero,226b0c <__swbuf_r+0xb0>
  226ab0:	80800017 	ldw	r2,0(r16)
  226ab4:	81000517 	ldw	r4,20(r16)
  226ab8:	10c7c83a 	sub	r3,r2,r3
  226abc:	19001d0e 	bge	r3,r4,226b34 <__swbuf_r+0xd8>
  226ac0:	18c00044 	addi	r3,r3,1
  226ac4:	81400217 	ldw	r5,8(r16)
  226ac8:	11000044 	addi	r4,r2,1
  226acc:	81000015 	stw	r4,0(r16)
  226ad0:	297fffc4 	addi	r5,r5,-1
  226ad4:	81400215 	stw	r5,8(r16)
  226ad8:	14400005 	stb	r17,0(r2)
  226adc:	80800517 	ldw	r2,20(r16)
  226ae0:	10c01d26 	beq	r2,r3,226b58 <__swbuf_r+0xfc>
  226ae4:	8080030b 	ldhu	r2,12(r16)
  226ae8:	1080004c 	andi	r2,r2,1
  226aec:	1000181e 	bne	r2,zero,226b50 <__swbuf_r+0xf4>
  226af0:	8805883a 	mov	r2,r17
  226af4:	dfc00317 	ldw	ra,12(sp)
  226af8:	dc800217 	ldw	r18,8(sp)
  226afc:	dc400117 	ldw	r17,4(sp)
  226b00:	dc000017 	ldw	r16,0(sp)
  226b04:	dec00404 	addi	sp,sp,16
  226b08:	f800283a 	ret
  226b0c:	81001917 	ldw	r4,100(r16)
  226b10:	00b7ffc4 	movi	r2,-8193
  226b14:	31880014 	ori	r6,r6,8192
  226b18:	2084703a 	and	r2,r4,r2
  226b1c:	80801915 	stw	r2,100(r16)
  226b20:	80800017 	ldw	r2,0(r16)
  226b24:	81000517 	ldw	r4,20(r16)
  226b28:	8180030d 	sth	r6,12(r16)
  226b2c:	10c7c83a 	sub	r3,r2,r3
  226b30:	193fe316 	blt	r3,r4,226ac0 <__alt_data_end+0xffff3240>
  226b34:	9009883a 	mov	r4,r18
  226b38:	800b883a 	mov	r5,r16
  226b3c:	0221e580 	call	221e58 <_fflush_r>
  226b40:	1000091e 	bne	r2,zero,226b68 <__swbuf_r+0x10c>
  226b44:	80800017 	ldw	r2,0(r16)
  226b48:	00c00044 	movi	r3,1
  226b4c:	003fdd06 	br	226ac4 <__alt_data_end+0xffff3244>
  226b50:	00800284 	movi	r2,10
  226b54:	88bfe61e 	bne	r17,r2,226af0 <__alt_data_end+0xffff3270>
  226b58:	9009883a 	mov	r4,r18
  226b5c:	800b883a 	mov	r5,r16
  226b60:	0221e580 	call	221e58 <_fflush_r>
  226b64:	103fe226 	beq	r2,zero,226af0 <__alt_data_end+0xffff3270>
  226b68:	00bfffc4 	movi	r2,-1
  226b6c:	003fe106 	br	226af4 <__alt_data_end+0xffff3274>
  226b70:	9009883a 	mov	r4,r18
  226b74:	800b883a 	mov	r5,r16
  226b78:	0221d280 	call	221d28 <__swsetup_r>
  226b7c:	1000051e 	bne	r2,zero,226b94 <__swbuf_r+0x138>
  226b80:	8180030b 	ldhu	r6,12(r16)
  226b84:	80c00417 	ldw	r3,16(r16)
  226b88:	003fc606 	br	226aa4 <__alt_data_end+0xffff3224>
  226b8c:	02224000 	call	222400 <__sinit>
  226b90:	003fbd06 	br	226a88 <__alt_data_end+0xffff3208>
  226b94:	80c0030b 	ldhu	r3,12(r16)
  226b98:	00bfffc4 	movi	r2,-1
  226b9c:	18c01014 	ori	r3,r3,64
  226ba0:	80c0030d 	sth	r3,12(r16)
  226ba4:	00c00244 	movi	r3,9
  226ba8:	90c00015 	stw	r3,0(r18)
  226bac:	003fd106 	br	226af4 <__alt_data_end+0xffff3274>

00226bb0 <__swbuf>:
  226bb0:	00c008f4 	movhi	r3,35
  226bb4:	18e2d404 	addi	r3,r3,-29872
  226bb8:	2005883a 	mov	r2,r4
  226bbc:	19000017 	ldw	r4,0(r3)
  226bc0:	280d883a 	mov	r6,r5
  226bc4:	100b883a 	mov	r5,r2
  226bc8:	0226a5c1 	jmpi	226a5c <__swbuf_r>

00226bcc <__register_exitproc>:
  226bcc:	008008f4 	movhi	r2,35
  226bd0:	defffa04 	addi	sp,sp,-24
  226bd4:	10a2d304 	addi	r2,r2,-29876
  226bd8:	dc000315 	stw	r16,12(sp)
  226bdc:	14000017 	ldw	r16,0(r2)
  226be0:	dc400415 	stw	r17,16(sp)
  226be4:	dfc00515 	stw	ra,20(sp)
  226be8:	80805217 	ldw	r2,328(r16)
  226bec:	2023883a 	mov	r17,r4
  226bf0:	10003626 	beq	r2,zero,226ccc <__register_exitproc+0x100>
  226bf4:	10c00117 	ldw	r3,4(r2)
  226bf8:	010007c4 	movi	r4,31
  226bfc:	20c00e16 	blt	r4,r3,226c38 <__register_exitproc+0x6c>
  226c00:	1a400044 	addi	r9,r3,1
  226c04:	8800211e 	bne	r17,zero,226c8c <__register_exitproc+0xc0>
  226c08:	18c00084 	addi	r3,r3,2
  226c0c:	18c7883a 	add	r3,r3,r3
  226c10:	18c7883a 	add	r3,r3,r3
  226c14:	12400115 	stw	r9,4(r2)
  226c18:	10c7883a 	add	r3,r2,r3
  226c1c:	19400015 	stw	r5,0(r3)
  226c20:	0005883a 	mov	r2,zero
  226c24:	dfc00517 	ldw	ra,20(sp)
  226c28:	dc400417 	ldw	r17,16(sp)
  226c2c:	dc000317 	ldw	r16,12(sp)
  226c30:	dec00604 	addi	sp,sp,24
  226c34:	f800283a 	ret
  226c38:	00800034 	movhi	r2,0
  226c3c:	10800004 	addi	r2,r2,0
  226c40:	10002526 	beq	r2,zero,226cd8 <__register_exitproc+0x10c>
  226c44:	01006404 	movi	r4,400
  226c48:	d9400015 	stw	r5,0(sp)
  226c4c:	d9800115 	stw	r6,4(sp)
  226c50:	d9c00215 	stw	r7,8(sp)
  226c54:	00000000 	call	0 <__reset-0x220000>
  226c58:	d9400017 	ldw	r5,0(sp)
  226c5c:	d9800117 	ldw	r6,4(sp)
  226c60:	d9c00217 	ldw	r7,8(sp)
  226c64:	10001c26 	beq	r2,zero,226cd8 <__register_exitproc+0x10c>
  226c68:	80c05217 	ldw	r3,328(r16)
  226c6c:	10000115 	stw	zero,4(r2)
  226c70:	02400044 	movi	r9,1
  226c74:	10c00015 	stw	r3,0(r2)
  226c78:	80805215 	stw	r2,328(r16)
  226c7c:	10006215 	stw	zero,392(r2)
  226c80:	10006315 	stw	zero,396(r2)
  226c84:	0007883a 	mov	r3,zero
  226c88:	883fdf26 	beq	r17,zero,226c08 <__alt_data_end+0xffff3388>
  226c8c:	18d1883a 	add	r8,r3,r3
  226c90:	4211883a 	add	r8,r8,r8
  226c94:	1211883a 	add	r8,r2,r8
  226c98:	41802215 	stw	r6,136(r8)
  226c9c:	01000044 	movi	r4,1
  226ca0:	11806217 	ldw	r6,392(r2)
  226ca4:	20c8983a 	sll	r4,r4,r3
  226ca8:	310cb03a 	or	r6,r6,r4
  226cac:	11806215 	stw	r6,392(r2)
  226cb0:	41c04215 	stw	r7,264(r8)
  226cb4:	01800084 	movi	r6,2
  226cb8:	89bfd31e 	bne	r17,r6,226c08 <__alt_data_end+0xffff3388>
  226cbc:	11806317 	ldw	r6,396(r2)
  226cc0:	3108b03a 	or	r4,r6,r4
  226cc4:	11006315 	stw	r4,396(r2)
  226cc8:	003fcf06 	br	226c08 <__alt_data_end+0xffff3388>
  226ccc:	80805304 	addi	r2,r16,332
  226cd0:	80805215 	stw	r2,328(r16)
  226cd4:	003fc706 	br	226bf4 <__alt_data_end+0xffff3374>
  226cd8:	00bfffc4 	movi	r2,-1
  226cdc:	003fd106 	br	226c24 <__alt_data_end+0xffff33a4>

00226ce0 <__call_exitprocs>:
  226ce0:	008008f4 	movhi	r2,35
  226ce4:	10a2d304 	addi	r2,r2,-29876
  226ce8:	10800017 	ldw	r2,0(r2)
  226cec:	defff404 	addi	sp,sp,-48
  226cf0:	dd800815 	stw	r22,32(sp)
  226cf4:	d8800015 	stw	r2,0(sp)
  226cf8:	10805204 	addi	r2,r2,328
  226cfc:	dd000615 	stw	r20,24(sp)
  226d00:	dc800415 	stw	r18,16(sp)
  226d04:	dfc00b15 	stw	ra,44(sp)
  226d08:	df000a15 	stw	fp,40(sp)
  226d0c:	ddc00915 	stw	r23,36(sp)
  226d10:	dd400715 	stw	r21,28(sp)
  226d14:	dcc00515 	stw	r19,20(sp)
  226d18:	dc400315 	stw	r17,12(sp)
  226d1c:	dc000215 	stw	r16,8(sp)
  226d20:	2025883a 	mov	r18,r4
  226d24:	2829883a 	mov	r20,r5
  226d28:	d8800115 	stw	r2,4(sp)
  226d2c:	05bfffc4 	movi	r22,-1
  226d30:	d8800017 	ldw	r2,0(sp)
  226d34:	14c05217 	ldw	r19,328(r2)
  226d38:	98001d26 	beq	r19,zero,226db0 <__call_exitprocs+0xd0>
  226d3c:	dd400117 	ldw	r21,4(sp)
  226d40:	98800117 	ldw	r2,4(r19)
  226d44:	173fffc4 	addi	fp,r2,-1
  226d48:	e0000d16 	blt	fp,zero,226d80 <__call_exitprocs+0xa0>
  226d4c:	14000044 	addi	r16,r2,1
  226d50:	8421883a 	add	r16,r16,r16
  226d54:	8421883a 	add	r16,r16,r16
  226d58:	84402004 	addi	r17,r16,128
  226d5c:	9c63883a 	add	r17,r19,r17
  226d60:	9c21883a 	add	r16,r19,r16
  226d64:	a0001e26 	beq	r20,zero,226de0 <__call_exitprocs+0x100>
  226d68:	80804017 	ldw	r2,256(r16)
  226d6c:	15001c26 	beq	r2,r20,226de0 <__call_exitprocs+0x100>
  226d70:	e73fffc4 	addi	fp,fp,-1
  226d74:	843fff04 	addi	r16,r16,-4
  226d78:	8c7fff04 	addi	r17,r17,-4
  226d7c:	e5bff91e 	bne	fp,r22,226d64 <__alt_data_end+0xffff34e4>
  226d80:	00800034 	movhi	r2,0
  226d84:	10800004 	addi	r2,r2,0
  226d88:	10000926 	beq	r2,zero,226db0 <__call_exitprocs+0xd0>
  226d8c:	98800117 	ldw	r2,4(r19)
  226d90:	1000311e 	bne	r2,zero,226e58 <__call_exitprocs+0x178>
  226d94:	98800017 	ldw	r2,0(r19)
  226d98:	10003426 	beq	r2,zero,226e6c <__call_exitprocs+0x18c>
  226d9c:	9809883a 	mov	r4,r19
  226da0:	a8800015 	stw	r2,0(r21)
  226da4:	00000000 	call	0 <__reset-0x220000>
  226da8:	acc00017 	ldw	r19,0(r21)
  226dac:	983fe41e 	bne	r19,zero,226d40 <__alt_data_end+0xffff34c0>
  226db0:	dfc00b17 	ldw	ra,44(sp)
  226db4:	df000a17 	ldw	fp,40(sp)
  226db8:	ddc00917 	ldw	r23,36(sp)
  226dbc:	dd800817 	ldw	r22,32(sp)
  226dc0:	dd400717 	ldw	r21,28(sp)
  226dc4:	dd000617 	ldw	r20,24(sp)
  226dc8:	dcc00517 	ldw	r19,20(sp)
  226dcc:	dc800417 	ldw	r18,16(sp)
  226dd0:	dc400317 	ldw	r17,12(sp)
  226dd4:	dc000217 	ldw	r16,8(sp)
  226dd8:	dec00c04 	addi	sp,sp,48
  226ddc:	f800283a 	ret
  226de0:	98800117 	ldw	r2,4(r19)
  226de4:	80c00017 	ldw	r3,0(r16)
  226de8:	10bfffc4 	addi	r2,r2,-1
  226dec:	17001526 	beq	r2,fp,226e44 <__call_exitprocs+0x164>
  226df0:	80000015 	stw	zero,0(r16)
  226df4:	183fde26 	beq	r3,zero,226d70 <__alt_data_end+0xffff34f0>
  226df8:	00800044 	movi	r2,1
  226dfc:	1708983a 	sll	r4,r2,fp
  226e00:	98806217 	ldw	r2,392(r19)
  226e04:	9dc00117 	ldw	r23,4(r19)
  226e08:	2084703a 	and	r2,r4,r2
  226e0c:	1000061e 	bne	r2,zero,226e28 <__call_exitprocs+0x148>
  226e10:	183ee83a 	callr	r3
  226e14:	98800117 	ldw	r2,4(r19)
  226e18:	15ffc51e 	bne	r2,r23,226d30 <__alt_data_end+0xffff34b0>
  226e1c:	a8800017 	ldw	r2,0(r21)
  226e20:	14ffd326 	beq	r2,r19,226d70 <__alt_data_end+0xffff34f0>
  226e24:	003fc206 	br	226d30 <__alt_data_end+0xffff34b0>
  226e28:	98806317 	ldw	r2,396(r19)
  226e2c:	2084703a 	and	r2,r4,r2
  226e30:	1000061e 	bne	r2,zero,226e4c <__call_exitprocs+0x16c>
  226e34:	89400017 	ldw	r5,0(r17)
  226e38:	9009883a 	mov	r4,r18
  226e3c:	183ee83a 	callr	r3
  226e40:	003ff406 	br	226e14 <__alt_data_end+0xffff3594>
  226e44:	9f000115 	stw	fp,4(r19)
  226e48:	003fea06 	br	226df4 <__alt_data_end+0xffff3574>
  226e4c:	89000017 	ldw	r4,0(r17)
  226e50:	183ee83a 	callr	r3
  226e54:	003fef06 	br	226e14 <__alt_data_end+0xffff3594>
  226e58:	98800017 	ldw	r2,0(r19)
  226e5c:	982b883a 	mov	r21,r19
  226e60:	1027883a 	mov	r19,r2
  226e64:	983fb61e 	bne	r19,zero,226d40 <__alt_data_end+0xffff34c0>
  226e68:	003fd106 	br	226db0 <__alt_data_end+0xffff3530>
  226e6c:	0005883a 	mov	r2,zero
  226e70:	003ffa06 	br	226e5c <__alt_data_end+0xffff35dc>

00226e74 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
  226e74:	defffd04 	addi	sp,sp,-12
  226e78:	df000215 	stw	fp,8(sp)
  226e7c:	df000204 	addi	fp,sp,8
  226e80:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
  226e84:	0001883a 	nop
  226e88:	e0bfff17 	ldw	r2,-4(fp)
  226e8c:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
  226e90:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
  226e94:	10000226 	beq	r2,zero,226ea0 <_exit+0x2c>
    ALT_SIM_FAIL();
  226e98:	002af070 	cmpltui	zero,zero,43969
  226e9c:	00000106 	br	226ea4 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
  226ea0:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
  226ea4:	003fff06 	br	226ea4 <__alt_data_end+0xffff3624>
